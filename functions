_SuSEconfig () {
	# undefined
	builtin autoload -XUz
}
__git_aliases () {
	local -a aliases
	__git_extract_aliases
	_describe -t aliases alias aliases $*
}
__git_any_repositories () {
	_alternative 'local-repositories::__git_local_repositories' 'remotes: :__git_remotes' 'remote-repositories::__git_remote_repositories'
}
__git_apply_whitespace_strategies () {
	declare -a strategies
	strategies=('nowarn:turn off the trailing-whitespace warning' 'warn:output trailing-whitespace warning, but apply patch' 'fix:output trailing-whitespace warning and strip trailing whitespace' 'error:output trailing-whitespace warning and refuse to apply patch' 'error-all:same as "error", but output warnings for all files') 
	_describe -t strategies 'trailing-whitespace resolution strategy' strategies $*
}
__git_archive_formats () {
	local expl
	_wanted archive-formats expl 'archive format' compadd $* - ${${(f)"$(_call_program archive-formats git archive --list)"}}
}
__git_attributes () {
	local -a attributes
	attributes=('crlf:line-ending convention' 'ident:ident substitution' 'filter:filters' 'diff:textual diff' 'merge:merging strategy') 
	_describe -t attributes attribute attributes $*
}
__git_blob_objects () {
	_guard '[[:xdigit:]](#c,40)' 'blob object name'
}
__git_blob_tags () {
	__git_tags_of_type blob $*
}
__git_blobs () {
	_alternative 'blob-tags::__git_blob_tags' 'blob-objects::__git_blob_objects'
}
__git_blobs_and_trees_in_treeish () {
	compset -P '*:'
	[[ -n ${IPREFIX} ]] || return 1
	if [[ -n ${IPREFIX%:} ]]
	then
		__git_is_treeish ${IPREFIX%:} && __git_tree_files ${PREFIX:-.} ${IPREFIX%:}
	else
		__git_changed-in-index_files
	fi
}
__git_branch_names () {
	local expl
	declare -a branch_names
	branch_names=(${${(f)"$(_call_program branchrefs git for-each-ref --format='"%(refname)"' refs/heads 2>/dev/null)"}#refs/heads/}) 
	__git_command_successful $pipestatus || return 1
	_wanted branch-names expl branch-name compadd $* - $branch_names
}
__git_browsers () {
	integer ret=1
	local expl
	declare -a userbrowsers builtinbrowsers
	__git_config_get_regexp '^browser\..+\.cmd$' userbrowsers
	builtinbrowsers=(firefox iceweasel konquerer w3m links lynx dillo open start) 
	_tags user-browsers builtin-browsers
	while _tags
	do
		_requested user-browsers expl 'user-defined browser' compadd $* - $userbrowsers && ret=0 
		_requested builtin-browsers expl 'builtin browser' compadd $* - $builtinbrowsers && ret=0 
		(( ret )) || break
	done
	return ret
}
__git_builtin_merge_drivers () {
	local -a builtin_merge_drivers
	builtin_merge_drivers=(text:'normal 3-way file-level merge for text files' binary:'binary file merge driver' union:'run 3-way file-levele merge with lines from both versions') 
	_describe -t builtin-merge-drivers 'builtin merge driver' builtin_merge_drivers $*
}
__git_cached_files () {
	__git_files --cached cached-files 'cached file' $*
}
__git_changed-in-index_files () {
	local files expl
	files=$(_call_program files git diff-index -z --name-only --no-color --cached HEAD 2>/dev/null) 
	__git_command_successful $pipestatus || return 1
	files=(${(0)"$(__git_files_relative $files)"}) 
	__git_command_successful $pipestatus || return 1
	_wanted changed-in-index-files expl 'changed in index file' _multi_parts $@ - / files
}
__git_changed-in-working-tree_files () {
	local files expl
	files=$(_call_program changed-in-working-tree-files git diff -z --name-only --no-color 2>/dev/null) 
	__git_command_successful $pipestatus || return 1
	files=(${(0)"$(__git_files_relative $files)"}) 
	__git_command_successful $pipestatus || return 1
	_wanted changed-in-working-tree-files expl 'changed in working tree file' _multi_parts $@ -f - / files
}
__git_changed_files () {
	_alternative 'changed-in-index-files::__git_changed-in-index_files' 'changed-in-working-tree-files::__git_changed-in-working-tree_files'
}
__git_color_attributes () {
	declare -a attributes
	attributes=(bold dim ul blink reverse) 
	_describe -t attributes attribute attributes $*
}
__git_color_whens () {
	local -a whens
	whens=('always:always use colors' 'never:never use colors' 'auto:use colors if output is to a terminal') 
	_describe -t whens when whens $*
}
__git_colors () {
	declare -a colors
	colors=(black red green yellow blue magenta cyan white) 
	_describe -t colors color colors $*
}
__git_command_successful () {
	if (( ${#*:#0} > 0 ))
	then
		_message 'not a git repository'
		return 1
	fi
	return 0
}
__git_commit_objects () {
	_guard '[[:xdigit:]](#c,40)' 'commit object name'
}
__git_commit_ranges () {
	if compset -P '*..(.|)'
	then
		__git_commits $*
	else
		__git_commits $* -qS ..
	fi
}
__git_commit_ranges2 () {
	_alternative 'commits::__git_commits2' 'ranges::__git_commit_ranges'
}
__git_commit_tags () {
	__git_tags_of_type commit $*
}
__git_commits () {
	_alternative 'heads::__git_heads' 'commit-tags::__git_commit_tags' 'commit-objects::__git_commit_objects'
}
__git_commits2 () {
	compset -P '\\\^'
	__git_commits
}
__git_committish_range_first () {
	print -r -- ${1%..(.|)*}
}
__git_committish_range_last () {
	print -r -- ${1##*..(.|)}
}
__git_committishs () {
	__git_commits
}
__git_compression_levels () {
	__git_config_values -t compression-levels -l 'compression level' -- "$current" "$parts[5]" '-1:default level of compression' '0:do not deflate files' '1:minimum compression' '2:a little more compression' '3:slightly more compression' '4:a bit more compression' '5:even more compression' '6:slightly even more compression' '7:getting there' '8:close to maximum compression' '9:maximum compression'
}
__git_config_booleans () {
	local tag label current default description
	declare -a booleans
	zparseopts -D t=tag l=label
	current=$1 
	default=${2:-true} 
	description=$3 
	shift 3
	booleans=({true,yes,on}":$description" {false,no,off}":do not $description" $*) 
	__git_config_values -t ${tag:-booleans} -l ${label:-boolean} -- "$current" $default $booleans
}
__git_config_get_regexp () {
	declare -A opts
	zparseopts -A opts -D b: a:
	[[ -n $opts[-b] ]] || opts[-b]='*.' 
	[[ -n $opts[-a] ]] || opts[-a]='.[^.]##' 
	[[ $1 = -- ]] && shift
	set -A $2 ${${${(0)"$(_call_program ${3:-$2} "git config -z --get-regexp -- '$1'")"}#${~opts[-b]}}%%${~opts[-a]}$'\n'*}
}
__git_config_sections () {
	declare -a opts
	local regex tag desc
	local -a groups
	zparseopts -a opts -D b: a:
	regex=$1 
	tag=$2 
	desc=$3 
	shift 3
	__git_config_get_regexp $opts -- $regex groups $tag
	_describe -t $tag $desc groups $*
}
__git_config_values () {
	declare -A opts
	local current default key
	declare -a values
	zparseopts -A opts -D t: l:
	[[ $1 = -- ]] && shift
	current=$1 
	default=$2 
	shift 2
	values=($*) 
	[[ -n $current ]] && values[(r)$(__git_pattern_escape $default):*]+=' (current)' 
	values[(r)$(__git_pattern_escape $default):*]+=' (default)' 
	_describe -t ${opts[-t]:-values} ${opts[-l]:-value} values
}
__git_daemon_service () {
	local -a services
	services=('upload-pack:serve git fetch-pack and git ls-remote clients' 'upload-archive:serve git archive --remote clients') 
	_describe -t services service services $*
}
__git_date_formats () {
	declare -a date_formats
	date_formats=(relative:'show dates relative to the current time' local:'show timestamps in local timezone' iso:'show timestamps in ISO 8601 format' rfc:'show timestamps in RFC 2822 format' short:'show only date but not time' raw:'show date in internal raw git format (%s %z)' default:'show timestamp in the original timezone') 
	_describe -t date-formats 'date format' date_formats $*
}
__git_datetimes () {
	_guard '*' 'time specification'
}
__git_deleted_files () {
	__git_files --deleted deleted-files 'deleted file' $*
}
__git_diff-or-merge-tools () {
	local type=$1
	shift
	integer ret=1
	local expl
	declare -a userdifftools usermergetools builtintools builtindifftools builtinmergetools
	[[ $type = diff ]] && __git_config_get_regexp '^difftool\..+\.cmd$' userdifftools
	__git_config_get_regexp '^mergetool\..+\.cmd$' usermergetools
	builtintools=(kdiff3 tkdiff xxdiff meld opendiff vimdiff gvimdiff vimdiff2 gvimdiff2 emerge ecmerge diffuse araxis p4merge) 
	builtindifftools=($builtintools kompare) 
	builtinmergetools=($builtintools tortoisemerge) 
	case $type in
		(diff) _tags user-difftools builtin-difftools user-mergetools ;;
		(merge) _tags user-mergetools builtin-mergetools ;;
	esac
	while _tags
	do
		_requested user-difftools expl 'user-defined difftool' compadd $* - $userdifftools && ret=0 
		_requested user-mergetools expl 'user-defined mergetool' compadd $* - $usermergetools && ret=0 
		_requested builtin-difftools expl 'builtin difftool' compadd $* - $builtindifftools && ret=0 
		_requested builtin-mergetools expl 'builtin mergetool' compadd $* - $builtinmergetools && ret=0 
		(( ret )) || break
	done
	return ret
}
__git_difftools () {
	__git_diff-or-merge-tools diff $*
}
__git_encodings () {
	local expl
	_wanted encodings expl 'encoding' compadd "$@" -M 'm:{a-zA-Z}={A-Za-z} r:|-=* r:|=*' ${${${(f)"$(_call_program encodings iconv --list)"}## #}%//}
}
__git_extract_aliases () {
	aliases=(${^${${(0)"$(_call_program aliases "git config -z --get-regexp '^alias.'")"}#alias.}/$'\n'/:alias for \'}\') 
}
__git_files () {
	local compadd_opts opts tag description gitcdup gitprefix files expl
	zparseopts -D -E -a compadd_opts V: J: 1 2 n f X: M: P: S: r: R: q F:
	zparseopts -D -E -a opts -- -cached -deleted -modified -others -ignored -unmerged -killed x+: --exclude+:
	tag=$1 description=$2 
	shift 2
	gitcdup=$(_call_program gitcdup git rev-parse --show-cdup 2>/dev/null) 
	__git_command_successful $pipestatus || return 1
	gitprefix=$(_call_program gitprefix git rev-parse --show-prefix 2>/dev/null) 
	__git_command_successful $pipestatus || return 1
	local pref=$gitcdup$gitprefix$PREFIX
	files=(${(0)"$(_call_program files git ls-files -z --exclude-standard $opts -- ${pref:+$pref\*} 2>/dev/null)"}) 
	__git_command_successful $pipestatus || return
	_wanted $tag expl $description _multi_parts -f $compadd_opts - / files
}
__git_files_relative () {
	local files file f_parts prefix p_parts tmp
	prefix=$(_call_program gitprefix git rev-parse --show-prefix 2>/dev/null) 
	__git_command_successful $pipestatus || return 1
	if (( $#prefix == 0 ))
	then
		print $1
		return
	fi
	files=() 
	for file in ${${${${${(0)1}//\/\///}//\/.\///}%/.}%/}
	do
		integer i n
		(( n = $#file > $#prefix ? $#file : $#prefix ))
		for ((i = 1; i <= n; i++ )) do
			if [[ $file[i] != $prefix[i] ]]
			then
				while (( i > 0 )) && [[ $file[i-1] != / ]]
				do
					(( i-- ))
				done
				break
			fi
		done
		files+=${(l@${#prefix[i,-1]//[^\/]}*3@@../@)}${file[i,-1]} 
	done
	print ${(pj:\0:)files}
}
__git_gpg_secret_keys () {
	local expl
	_wanted secret-keys expl 'secret key' compadd ${${(Mo)$(_call_program secret-keys gpg --list-secret-keys 2>/dev/null):%<*>}//(<|>)/}
}
__git_guard () {
	declare -A opts
	zparseopts -K -D -A opts M: J: V: 1 2 n F: X:
	[[ "$PREFIX$SUFFIX" != $~1 ]] && return 1
	if (( $+opts[-X] ))
	then
		_message -r $opts[-X]
	else
		_message -e $2
	fi
	[[ -n "$PREFIX$SUFFIX" ]]
}
__git_guard_branch-name () {
	if [[ -n $PREFIX$SUFFIX ]]
	then
		_call_program check-ref-format git check-ref-format "refs/heads/$PREFIX$SUFFIX" &> /dev/null
		(( ${#pipestatus:#0} > 0 )) && return 1
	fi
	_message -e 'branch name'
	[[ -n $PREFIX$SUFFIX ]]
}
__git_guard_bytes () {
	_guard '[[:digit:]]#([kKmMgG]|)' $*
}
__git_guard_diff-stat-width () {
	if [[ $PREFIX = *,* ]]
	then
		compset -P '*,'
		__git_guard_number 'filename width'
	else
		compset -S ',*'
		__git_guard_number width
	fi
}
__git_guard_number () {
	declare -A opts
	zparseopts -K -D -A opts M: J: V: 1 2 n F: X:
	_guard '[[:digit:]]#' ${1:-number}
}
__git_heads () {
	local gitdir expl start
	declare -a heads
	heads=(${${(f)"$(_call_program headrefs git for-each-ref --format='"%(refname)"' refs/heads refs/remotes 2>/dev/null)"}#refs/(heads|remotes)/}) 
	gitdir=$(_call_program gitdir git rev-parse --git-dir 2>/dev/null) 
	if __git_command_successful $pipestatus
	then
		for f in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD
		do
			[[ -f $gitdir/$f ]] && heads+=$f 
		done
	fi
	_wanted heads expl head compadd $* - $heads
}
__git_ignore_line () {
	declare -a ignored
	ignored=() 
	((CURRENT > 1)) && ignored+=(${line[1,CURRENT-1]//(#m)[\[\]()\\*?#<>~\^]/\\$MATCH}) 
	((CURRENT < $#line)) && ignored+=(${line[CURRENT+1,-1]//(#m)[\[\]()\\*?#<>~\^]/\\$MATCH}) 
	$* -F ignored
}
__git_ignore_line_inside_arguments () {
	declare -a compadd_opts
	zparseopts -D -E -a compadd_opts V: J: 1 2 n f X: M: P: S: r: R: q F:
	__git_ignore_line $* $compadd_opts
}
__git_ignore_submodules_whens () {
	local -a whens
	whens=(none:'submodule is dirty when it contains untracked or modified files' untracked:'submodule is dirty when it contains untracket files' dirty:'ignore all changes to submodules, showing only changes to commits stored in superproject' all:'ignore all changes to submodules (default)') 
	_describe -t whens when whens $*
}
__git_ignored_cached_files () {
	__git_files --ignored --cached ignored-cached-files 'ignored cached file' $*
}
__git_ignored_other_files () {
	__git_files --ignored --others ignored-untracked-files 'ignored untracked file' $*
}
__git_is_blob () {
	__git_is_type blob $1
}
__git_is_committish () {
	__git_is_type commit $1
}
__git_is_committish_range () {
	[[ $1 = *..(.|)* ]] && __git_is_committish $(__git_committish_range_first $1) && __git_is_committish $(__git_committish_range_last $1)
}
__git_is_in_middle_of_merge () {
	local gitdir
	gitdir=$(_call_program gitdir git rev-parse --git-dir 2>/dev/null) 
	__git_command_successful $pipestatus || return
	[[ -f $gitdir/MERGE_HEAD ]]
}
__git_is_initial_commit () {
	git rev-parse -q --verify HEAD > /dev/null 2> /dev/null
	(( $? == 1 ))
}
__git_is_treeish () {
	__git_is_type tree $1
}
__git_is_type () {
	git rev-parse -q --verify "$2^{$1}" 2> /dev/null > /dev/null
}
__git_killed_files () {
	__git_files --killed killed-files 'killed file' $*
}
__git_local_references () {
	local references expl
	references=(${${(M)${${(f)"$(_call_program references git ls-remote ./. 2>/dev/null)"}#*$'\t'}:#refs/notes/*}#refs/notes/}) 
	__git_command_successful $pipestatus || return 1
	_wanted references expl reference compadd - $references
}
__git_local_repositories () {
	local expl
	_wanted local-repositories expl 'local repositories' _directories
}
__git_log_decorate_formats () {
	declare -a log_decorate_formats
	log_decorate_formats=(short:'do not show ref name prefixes' full:'show ref name prefixes' no:'do not show ref names') 
	_describe -t log-decorate-formats 'log decorate format' log_decorate_formats $*
}
__git_man_viewers () {
	__git_config_sections '^man\..+\.cmd$' man-viewers 'man viewer' $*
}
__git_merge_drivers () {
	__git_config_sections '^merge\..+\.name$' merge-drivers 'merge driver' $*
}
__git_merge_strategies () {
	local expl
	local -a merge_strategies
	merge_strategies=(${=${${(M)${(f)"$(_call_program merge-strategies "git merge -s '' 2>&1")"}:#[Aa]vailable (custom )#strategies are: *}#[Aa]vailable (custom )#strategies are: }%.}) 
	__git_command_successful $pipestatus || return 1
	_wanted merge-strategies expl 'merge strategy' compadd $* - $merge_strategies
}
__git_mergetools () {
	__git_diff-or-merge-tools merge $*
}
__git_modified_files () {
	__git_files --modified modified-files 'modified file' $*
}
__git_notes_refs () {
	local expl
	declare -a notes_refs
	notes_refs=(${${(f)"$(_call_program notes-refs git for-each-ref --format='"%(refname)"' refs/notes 2>/dev/null)"}#$type refs/notes/}) 
	__git_command_successful $pipestatus || return 1
	_wanted notes-refs expl 'notes ref' compadd $* - $notes_refs
}
__git_objects () {
	compset -P '*:'
	if [[ -n $IPREFIX ]]
	then
		__git_tree_files "$PREFIX" "${IPREFIX%:}"
	else
		_alternative 'revisions::__git_revisions' 'files::__git_cached_files'
	fi
}
__git_other_files () {
	__git_files --others untracked-files 'untracked file' $*
}
__git_pattern_escape () {
	print -r -n ${1//(#m)[\[\]()\\*?#<>~\^]/\\$MATCH}
}
__git_ref_sort_keys () {
	compset -P '-'
	local -a sort_keys
	sort_keys=('refname:the name of the ref' 'objecttype:the type of the object' 'objectsize:the size of the object' 'objectname:the object name (SHA-1)' 'tree:the tree header-field' 'parent:the parent header-field' 'numparent:undocumented' 'object:the object header-field' 'type:the type header-field' 'tag:the tag header-field' 'author:the author header-field' 'authorname:the name component of the author header-field' 'authoremail:the email component of the author header-field' 'authordate:the date component of the author header-field' 'committername:the name component of the committer header-field' 'committeremail:the email component of the committer header-field' 'committerdate:the date component of the committer header-field' 'taggername:the name component of the tagger header-field' 'taggeremail:the email component of the tagger header-field' 'taggerdate:the date component of the tagger header-field' 'creatorname:the name component of the creator header-field' 'creatordate:the date component of the creator header-field' 'subject:the subject of the message' 'body:the body of the message' 'body:the contents of the message (subject and body)') 
	_describe -t sort-keys 'sort key' sort_keys $*
}
__git_ref_specs () {
	if compset -P '*:'
	then
		__git_heads
	else
		compset -P '+'
		if compset -S ':*'
		then
			__git_heads
		else
			_alternative 'commit-tags::__git_commit_tags' 'heads::__git_heads -qS :'
		fi
	fi
}
__git_references () {
	local expl
	if [[ $_git_refs_cache_pwd != $PWD ]]
	then
		_git_refs_cache=(${${${(f)"$(_call_program references git ls-remote ./. 2>/dev/null)"}#*$'\t'}#refs/(heads|tags)/}) 
		__git_command_successful $pipestatus || return 1
		_git_refs_cache_pwd=$PWD 
	fi
	_wanted references expl 'references' compadd - $_git_refs_cache
}
__git_reflog_entries () {
	local expl
	declare -a reflog_entries
	reflog_entries=(${${${(f)"$(_call_program reflog-entries git reflog 2>/dev/null)"}#* }%%:*}) 
	__git_command_successful $pipestatus || return 1
	if compset -P '*@'
	then
		reflog_entries=(${${(M)reflog_entries:#$IPREFIX*}#$IPREFIX}) 
		_wanted reflog-entries expl 'reflog entry' compadd $* - $reflog_entries
	else
		reflog_entries=(${reflog_entries%@*}) 
		_wanted reflog-entries expl 'reflog entry' compadd -qS @ $* - $reflog_entries
	fi
}
__git_remote-groups () {
	__git_config_sections -a '(|)' '^remotes\..+$' remotes-groups 'remotes group' $*
}
__git_remote_branch_names () {
	local expl
	declare -a branch_names
	branch_names=(${${(f)"$(_call_program remote-branch-refs git for-each-ref --format='"%(refname)"' refs/remotes 2>/dev/null)"}#refs/remotes/}) 
	__git_command_successful $pipestatus || return 1
	_wanted remote-branch-names expl 'remote branch name' compadd $* - $branch_names
}
__git_remote_references () {
	__git_references
}
__git_remote_repositories () {
	local service
	service= _ssh
	if compset -P '*:'
	then
		_remote_files -/ -- ssh
	else
		_ssh_hosts -S:
	fi
}
__git_remotes () {
	local remotes expl
	remotes=(${(f)"$(_call_program remotes git remote 2>/dev/null)"}) 
	_wanted remotes expl remote compadd $* - $remotes
}
__git_remotes_groups () {
	local expl
	_wanted remotes-groups expl 'remotes group' compadd $* - ${${${(0)"$(_call_program remotes-groups git config --get-regexp -z '"^remotes\..*$"')"}%%$'\n'*}#remotes.}
}
__git_repositories () {
	_alternative 'local-repositories::__git_local_repositories' 'remote-repositories::__git_remote_repositories'
}
__git_repository_permissions () {
	if [[ -prefix [0-7] ]]
	then
		_message -e number 'numeric mode'
	else
		declare -a permissions
		permissions=({umask,false,no,off}':use permissions reported by umask()' {group,true,yes,on}':files and objects are group-writable' {all,world,everybody}':files and objects are readable by all users and group-shareable') 
		_describe -t permissions permission permissions $*
	fi
}
__git_revisions () {
	__git_commits $*
}
__git_sendemail_confirm_values () {
	__git_config_values -- "$current" "$parts[5]" always:'always confirm before sending' never:'never confirm before sending' cc:'confirm before sending to automatically added Cc-addresses' compose:'confirm before sending first message when using --compose' auto:'same as cc together with compose'
}
__git_sendemail_identities () {
	__git_config_sections '^sendemail\..+\.[^.]+$' identities 'sendemail identity' $*
}
__git_sendemail_smtpencryption_values () {
	__git_config_values -- "$current" "$parts[5]" ssl:'use SSL' tls:'use TLS'
}
__git_sendemail_suppresscc_values () {
	__git_config_values -- "$current" "$parts[5]" author:'avoid including patch author' self:'avoid including sender' cc:'avoid including anyone mentioned in Cc lines except for self' bodycc:'avoid including anyone mentiond in Cc lines in patch body except for self' sob:'avoid including anyone mentiond in Signed-off-by lines except for self' cccmd:'avoid running --cc-cmd' body:'equivalent to sob + bodycc' all:'avoid all auto Cc values'
}
__git_setup_apply_options () {
	apply_options=('--whitespace=[detect a new or modified line that ends with trailing whitespaces]: :__git_apply_whitespace_strategies' '-p-[remove N leading slashes from traditional diff paths]: :_guard  "[[\:digit\:]]#" "number of slashes to remove"' '-C-[ensure at least N lines of context match before and after each change]: :_guard  "[[\:digit\:]]#" "number of lines of context"' '--reject[apply hunks that apply and leave rejected hunks in .rej files]' '(--ignore-space-change --ignore-whitespace)'{--ignore-space-change,--ignore-whitespace}'[ignore changes in whitespace in context lines]' '--directory=[root to prepend to all filenames]:root:_directories') 
}
__git_setup_diff_options () {
	local diff_types='(-p -u --patch -U --unified --raw --patch-with-raw --stat --numstat --shortstat --dirstat --dirstat-by-file --summary --patch-with-stat --name-only --name-status --cumulative)'
	diff_options=($diff_types{-p,-u,--patch}'[generate diff in patch format]' $diff_types{-U,--unified=}'[generate diff with given lines of context]: :__git_guard_number lines' $diff_types'--raw[generate default raw diff output]' $diff_types'--patch-with-raw[generate patch but also keep the default raw diff output]' '--patience[generate diffs with patience algorithm]' $diff_types'--stat=-[generate diffstat instead of patch]:: :__git_guard_diff-stat-width' $diff_types'--numstat[generate more machine-friendly diffstat]' $diff_types'--shortstat[generate summary diffstat]' $diff_types'--dirstat=-[generate dirstat by amount of changes]:: :__git_guard_number limit' $diff_types'--dirstat-by-file=-[generate dirstat by number of files]:: :__git_guard_number limit' $diff_types'--summary[generate condensed summary of extended header information]' $diff_types'--patch-with-stat[generate patch and prepend its diffstat]' '-z[use NUL termination on output]' $diff_types'--name-only[show only names of changed files]' $diff_types'--name-status[show only names and status of changed files]' '--submodule=-[select output format for submodule differences]::format:((short\:"show pairs of commit names"
                                                                            log\:"list commits like git submodule does (default)"))' '(        --no-color --color-words)--color=-[show colored diff]:: :__git_color_whens' '(--color            --color-words)--no-color[turn off colored diff]' '--word-diff=-[show word diff]::mode:((color\:"highlight changed words using color"
                                          plain\:"wrap deletions and insertions with markers"
                                          porcelain\:"use special line-based format for scripts"
                                          none\:"disable word diff"))' '--word-diff-regex=-[specify what constitutes a word]:word regex' '(--color --no-color              )--color-words=-[show colored-word diff]::word regex' '--no-renames[turn off rename detection]' '--check[warn if changes introduce trailing whitespace or space/tab indents]' '--full-index[show full object name of pre- and post-image blob]' '(--full-index)--binary[in addition to --full-index, output binary diffs for git-apply]' '--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' '(-B --break-rewrites)'{-B-,--break-rewrites=-}'[break complete rewrite changes into pairs of given size]:: :__git_guard_number size' '(-M --detect-renames)'{-M-,--detect-renames=-}'[detect renames with given scope]:: :__git_guard_number size' '(-C --detect-copies)'{-C-,--detect-copies=-}'[detect copies as well as renames with given scope]:: :__git_guard_number size' '--find-copies-harder[try harder to find copies]' '-l-[limit number of rename/copy targets to run]: :__git_guard_number' '--diff-filter=-[select certain kinds of files for diff]: :_guard "[ACDMRTUXB*]#" kinds' '-S-[look for differences that contain the given string]:string' '--pickaxe-all[when -S finds a change, show all changes in that changeset]' '--pickaxe-regex[treat argument of -S as regular expression]' '-O-[output patch in the order of glob-pattern lines in given file]: :_files' '-R[do a reverse diff]' '--relative=-[exclude changes outside and output relative to given directory]:: :_directories' '(-a --text)'{-a,--text}'[treat all files as text]' '--ignore-space-at-eol[ignore changes in whitespace at end of line]' '(-b --ignore-space-change -w --ignore-all-space)'{-b,--ignore-space-change}'[ignore changes in amount of white space]' '(-b --ignore-space-change -w --ignore-all-space)'{-w,--ignore-all-space}'[ignore white space when comparing lines]' '--inter-hunk-context=[combine hunks closer than n lines]:n' '--exit-code[report exit code 1 if differences, 0 otherwise]' '(--exit-code)--quiet[disable all output]' '(           --no-ext-diff)--ext-diff[allow external diff helper to be executed]' '(--ext-diff              )--no-ext-diff[disallow external diff helper to be executed]' '--ignore-submodules[ignore changes to submodules]:: :__git_ignore_submodules_whens' '(--no-prefix)--src-prefix=[use given prefix for source]:prefix' '(--no-prefix)--dst-prefix=[use given prefix for destination]:prefix' '(--src-prefix --dst-prefix)--no-prefix[do not show any source or destination prefix]' '(-0 -1 -2 -3 --base --ours --theirs -c --cc --no-index)'{-1,--base}'[diff against "base" version]' '(-0 -1 -2 -3 --base --ours --theirs -c --cc --no-index)'{-2,--ours}'[diff against "our branch" version]' '(-0 -1 -2 -3 --base --ours --theirs -c --cc --no-index)'{-3,--theirs}'[diff against "their branch" version]' '(-0 -1 -2 -3 --base --ours --theirs -c --cc --no-index)-0[omit diff output for unmerged entries]' '(-0 -1 -2 -3 --base --ours --theirs -c --cc --no-index)'{-c,--cc}'[compare "our branch", "their branch" and working tree files]' '-q[remain silent even on nonexisting files]' '--cumulative[undocumented]' '--follow[undocumented]' '--textconv[undocumented]' '--no-textconv[undocumented]' '-G[undocumented]' '--output[undocumented]:undocumented') 
}
__git_setup_fetch_options () {
	fetch_options=('(: *)--all[fetch all remotes]' '(-a --append)'{-a,--append}'[append ref names and object names of fetched refs to "$GIT_DIR/FETCH_HEAD"]' '--depth=[deepen the history of a shallow repository by the given number of commits]: :__git_guard_number depth' '--dry-run[show what would be done, without making any changes]' '(-f --force)'{-f,--force}'[allow refs that are not ancestors to be updated]' '(-k --keep)'{-k,--keep}'[keep downloaded pack]' '(-p --prune)'{-p,--prune}'[remove any remote tracking branches that no longer exist remotely]' '(-n --no-tags -t --tags)'{-n,--no-tags}'[disable automatic tag following]' '(--no-tags -t --tags)'{-t,--tags}'[fetch remote tags]' '(-u --update-head-ok)'{-u,--update-head-ok}'[allow updates of current branch head]' '--upload-pack=[specify path to git-upload-pack on remote side]:remote path' '(-q --quiet -v --verbose --progress)'{-q,--quiet}'[suppress all output]' '(-q --quiet -v --verbose)'{-v,--verbose}'[output additional information]' '(-q --quiet)--progress[output progress information]') 
}
__git_setup_log_options () {
	log_options=('(- *)-h[display help]' '(           --no-decorate)--decorate=-[print out ref names of any commits that are shown]: :__git_log_decorate_formats' '(--decorate              )--no-decorate[do not print out ref names of any commits that are shown]' '--source[show which ref each commit is reached from]') 
}
__git_setup_merge_options () {
	merge_options=('(         --no-commit)--commit[perform the merge and commit the result]' '(--commit            )--no-commit[perform the merge but do not commit the result]' '(     --no-ff)--ff[do not generate a merge commit if the merge resolved as a fast-forward]' '(--ff        )--no-ff[generate a merge commit even if the merge resolved as a fast-forward]' '(      --no-log)--log[fill in one-line descriptions of the commits being merged in the log message]' '(--log         )--no-log[do not list one-line descriptions of the commits being merged in the log message]' '(-n --no-stat)--stat[show a diffstat at the end of the merge]' '(--stat -n --no-stat)'{-n,--no-stat}'[do not show diffstat at the end of the merge]' '(         --no-squash)--squash[merge, but do not commit]' '(--squash            )--no-squash[merge and commit]' '--ff-only[refuse to merge unless HEAD is up to date or merge can be resolved as a fast-forward]' '*'{-s,--strategy=}'[use given merge strategy]:merge strategy:__git_merge_strategies' '*'{-X,--strategy-option=}'[pass merge-strategy-specific option to merge strategy]' '(-q --quiet -v --verbose)'{-q,--quiet}'[suppress all output]' '(-q --quiet -v --verbose)'{-v,--verbose}'[output additional information]') 
}
__git_setup_revision_options () {
	local -a diff_options
	__git_setup_diff_options
	revision_options=($diff_options '(-v --header)'{--pretty=-,--format=-}'[pretty print commit messages]::format:((oneline\:"commit-ids and subject of messages"
                                                                                    short\:"few headers and only subject of messages"
                                                                                    medium\:"most parts of messages"
                                                                                    full\:"all parts of commit messages"
                                                                                    fuller\:"like full and includes dates"
                                                                                    email\:"use email headers like From and Subject"
                                                                                    raw\:"the raw commits"
                                                                                    format\:"specify own format"))' '--abbrev-commit[show only partial prefixes of commit object names]' '--oneline[shorthand for --pretty=oneline --abbrev-commit]' '--encoding=-[output log messages in given encoding]:: :__git_encodings' '(--no-notes --show-notes --standard-notes --no-standard-notes)--no-notes[do not show notes that annotate commit]' '(--no-notes --show-notes --standard-notes --no-standard-notes)--show-notes[do not show notes that annotate commit]:: :__git_note_references' '(--no-notes --show-notes --standard-notes --no-standard-notes)--no-standard-notes[enable populating notes ref list from core.notesRef and notes.displayRef]' '(--no-notes --show-notes --standard-notes --no-standard-notes)--no-standard-notes[disable populating notes ref list from core.notesRef and notes.displayRef]' '(                --date)--relative-date[show dates relative to current time]' '(--relative-date       )--date=-[format of date output]: :__git_date_formats' '--parents[display parents of commit]' '--children[display children of commit]' '--left-right[mark which side of symmetric diff commit is reachable from]' '--graph[display graphical representation of commit history]' '--count[display how many commits would have been listed]' '(-n --max-count)'{-n+,--max-count=}'[maximum number of commits to display]: :__git_guard_number' '--skip=[skip given number of commits before output]: :__git_guard_number' '(--max-age --since --after)'{--since=,--after=}'[show commits more recent than given date]:date' '(--min-age --until --before)'{--until=,--before=}'[show commits older than given date]: :__git_guard_number timestamp' '(          --since --after)--max-age=-[maximum age of commits to output]: :__git_guard_number timestamp' '(          --until --before)--min-age[minimum age of commits to output]: :__git_guard_number timestamp' '*--author=[limit commits to those by given author]:author' '*--committer=[limit commits to those by given committer]:committer' '*--grep=[limit commits to those with log messages matching the given pattern]:pattern' '--all-match[limit commits to ones matching all --grep, --author, and --committer]' '(-i --regexp-ignore-case)'{-i,--regexp-ignore-case}'[match regexps ignoring case]' '(-E --extended-regexp)'{-E,--extended-regexp}'[use POSIX extended regexps]' '(-F --fixed-strings)'{-F,--fixed-strings}'[do not interpret patterns as regexps]' '--remove-empty[stop when given path disappears from tree]' '--merges[display only merge commits]' '--no-merges[do not display commits with more than one parent]' '--first-parent[follow only first parent from merge commits]' '*--not[reverses meaning of ^ prefix for revisions that follow]' '--all[show all commits from refs]' '--branches=-[show all commits from refs/heads]::pattern' '--tags=[-show all commits from refs/tags]::pattern' '--remotes=[-show all commits from refs/remotes]::pattern' '--glob=[show all commits from refs matching glob]:pattern' '--stdin[read commit objects from standard input]' '--cherry-pick[omit any same-change commits]' '(-g --walk-reflogs --reverse)'{-g,--walk-reflogs}'[walk reflog entries from most recent to oldest]' '--merge[after a failed merge, show refs that touch files having a conflict]' '--boundary[output uninteresting commits at boundary]' '--simplify-by-decoration[show only commits that are referenced by a ref]' '(               --dense --sparse --simplify-merges --ancestry-path)--full-history[do not prune history]' '(--full-history         --sparse --simplify-merges --ancestry-path)--dense[only display selected commits, plus meaningful history]' '(--full-history --dense          --simplify-merges --ancestry-path)--sparse[when paths are given, display only commits that changes any of them]' '(--full-history --dense --sparse                   --ancestry-path)--simplify-merges[milder version of --full-history]' '(--full-history --dense --sparse --simplify-merges                )--ancestry-path[only display commits that exists directly on ancestry chains]' '(             --date-order)--topo-order[display commits in topological order]' '(--topo-order             )--date-order[display commits in date order]' '(-g --walk-reflogs)--reverse[display commits in reverse order]' '(          --objects-edge)--objects[display object ids of objects referenced by listed commits]' '(--objects               )--objects-edge[display object ids of objects referenced by listed and excluded commits]' '(          --do-walk)--no-walk[only display given revs, do not traverse their ancestors]' '(--no-walk          )--do-walk[only display given revs, traversing their ancestors]' '--reflog[show all commits from reflogs]' '--default[use argument as default revision]:default revision:__git_revisions' '(-c --cc            )--full-diff[undocumented]' '--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' '--no-abbrev[undocumented]' '--early-output=-[undocumented]::undocumented' '--log-size[undocumented]') 
	if (( words[(I)--objects(|-edge)] ))
	then
		revision_options+=('--unpacked[print object IDs not in packs]') 
	fi
}
__git_signoff_file () {
	_alternative 'signoffs:signoff:(yes true me please)' 'files:signoff file:_files'
}
__git_stages () {
	__git_guard $* '[[:digit:]]#' 'stage'
}
__git_stashes () {
	local expl
	declare -a stashes
	stashes=(${${(f)"$(_call_program stashes git stash list 2>/dev/null)"}/: */}) 
	__git_command_successful $pipestatus || return 1
	_wanted stashes expl stash compadd $* - $stashes
}
__git_submodules () {
	local expl
	declare -a submodules
	submodules=(${${(f)"$(_call_program submodules git submodule 2>/dev/null)"}#* }) 
	__git_command_successful $pipestatus || return 1
	_wanted submodules expl submodule compadd $* - $submodules
}
__git_svn-remotes () {
	__git_config_sections -a '(|)' '^svn-remote\..+$' svn-remotes 'svn remote' $*
}
__git_svn_base_revisions () {
	declare -a symbolic_revisions
	symbolic_revisions=('BASE:the bottommost revision of the SVN repository') 
	_describe -t symbolic-revisions 'symbolic revision' symbolic_revisions -S ':' -r ': '
}
__git_svn_revision_numbers () {
	__git_guard_number 'revision number'
}
__git_svn_revisions () {
	if [[ -prefix *: ]]
	then
		compset -P '*:'
		_alternative 'revision-numbers::__git_svn_revision_numbers' 'symbolic-revisions:symbolic revision:((HEAD:"the topmost revision of the SVN repository"))'
	else
		_alternative 'revision-numbers::__git_svn_revision_numbers' 'symbolic-revisions:symbolic revision:__git_svn_base_revisions'
	fi
}
__git_tags () {
	local expl
	declare -a tags
	tags=(${${(f)"$(_call_program tagrefs git for-each-ref --format='"%(refname)"' refs/tags 2>/dev/null)"}#refs/tags/}) 
	__git_command_successful $pipestatus || return 1
	_wanted tags expl tag compadd $* - $tags
}
__git_tags_of_type () {
	local type expl
	declare -a tags
	type=$1 
	shift
	tags=(${${(M)${(f)"$(_call_program $type-tag-refs "git for-each-ref --format='%(*objecttype)%(objecttype) %(refname)' refs/tags 2>/dev/null")"}:#$type(tag|) *}#$type(tag|) refs/tags/}) 
	__git_command_successful $pipestatus || return 1
	_wanted $type-tags expl "$type tag" compadd $* - $tags
}
__git_tree_files () {
	local multi_parts_opts
	local tree Path
	integer at_least_one_tree_added
	local -a tree_files compadd_opts
	zparseopts -D -E -a compadd_opts V: J: 1 2 n f X: M: P: S: r: R: q F:
	[[ "$1" = */ ]] && Path="$1"  || Path="${1:h}/" 
	shift
	(( at_least_one_tree_added = 0 ))
	for tree in $*
	do
		tree_files+=(${(ps:\0:)"$(_call_program tree-files git ls-tree --name-only -z $tree $Path 2>/dev/null)"}) 
		__git_command_successful $pipestatus && (( at_least_one_tree_added = 1 ))
	done
	if (( !at_least_one_tree_added ))
	then
		return 1
	fi
	local expl
	_wanted files expl 'tree file' _multi_parts -f $compadd_opts -- / tree_files
}
__git_tree_ishs () {
	__git_commits
}
__git_trees () {
	__git_objects
}
__git_unmerged_files () {
	__git_files --unmerged unmerged-files 'unmerged file' $*
}
_a2ps () {
	# undefined
	builtin autoload -XUz
}
_a2utils () {
	# undefined
	builtin autoload -XUz
}
_aap () {
	# undefined
	builtin autoload -XUz
}
_acpi () {
	# undefined
	builtin autoload -XUz
}
_acpitool () {
	# undefined
	builtin autoload -XUz
}
_acroread () {
	# undefined
	builtin autoload -XUz
}
_adb () {
	# undefined
	builtin autoload -XUz
}
_alias () {
	# undefined
	builtin autoload -XUz
}
_aliases () {
	# undefined
	builtin autoload -XUz
}
_all_labels () {
	local __gopt __len __tmp __pre __suf __ret=1 __descr __spec __prev
	if [[ "$1" = - ]]
	then
		__prev=- 
		shift
	fi
	__gopt=() 
	zparseopts -D -a __gopt 1 2 V J x
	__tmp=${argv[(ib:4:)-]} 
	__len=$# 
	if [[ __tmp -lt __len ]]
	then
		__pre=$(( __tmp-1 )) 
		__suf=$__tmp 
	elif [[ __tmp -eq $# ]]
	then
		__pre=-2 
		__suf=$(( __len+1 )) 
	else
		__pre=4 
		__suf=5 
	fi
	while comptags "-A$__prev" "$1" curtag __spec
	do
		(( $#funcstack > _tags_level )) && _comp_tags="${_comp_tags% * }" 
		_tags_level=$#funcstack 
		_comp_tags="$_comp_tags $__spec " 
		if [[ "$curtag" = *[^\\]:* ]]
		then
			zformat -f __descr "${curtag#*:}" "d:$3"
			_description "$__gopt[@]" "${curtag%:*}" "$2" "$__descr"
			curtag="${curtag%:*}" 
			"$4" "${(P@)2}" "${(@)argv[5,-1]}" && __ret=0 
		else
			_description "$__gopt[@]" "$curtag" "$2" "$3"
			"${(@)argv[4,__pre]}" "${(P@)2}" "${(@)argv[__suf,-1]}" && __ret=0 
		fi
	done
	return __ret
}
_all_matches () {
	# undefined
	builtin autoload -XUz
}
_alternative () {
	local tags def expl descr action mesgs nm="$compstate[nmatches]" subopts
	local opt ws curcontext="$curcontext"
	subopts=() 
	while getopts 'O:C:' opt
	do
		case "$opt" in
			(O) subopts=("${(@P)OPTARG}")  ;;
			(C) curcontext="${curcontext%:*}:$OPTARG"  ;;
		esac
	done
	shift OPTIND-1
	[[ "$1" = -(|-) ]] && shift
	mesgs=() 
	_tags "${(@)argv%%:*}"
	while _tags
	do
		for def
		do
			if _requested "${def%%:*}"
			then
				descr="${${def#*:}%%:*}" 
				action="${def#*:*:}" 
				_description "${def%%:*}" expl "$descr"
				if [[ "$action" = \ # ]]
				then
					mesgs=("$mesgs[@]" "${def%%:*}:$descr") 
				elif [[ "$action" = \(\(*\)\) ]]
				then
					eval ws\=\( "${action[3,-3]}" \)
					_describe -t "${def%%:*}" "$descr" ws -M 'r:|[_-]=* r:|=*' "$subopts[@]"
				elif [[ "$action" = \(*\) ]]
				then
					_all_labels "${def%%:*}" expl "$descr" compadd "$subopts[@]" - ${=action[2,-2]}
				elif [[ "$action" = \{*\} ]]
				then
					while _next_label "${def%%:*}" expl "$descr"
					do
						eval "$action[2,-2]"
					done
				elif [[ "$action" = \ * ]]
				then
					eval "action=( $action )"
					while _next_label "${def%%:*}" expl "$descr"
					do
						"$action[@]"
					done
				else
					eval "action=( $action )"
					while _next_label "${def%%:*}" expl "$descr"
					do
						"$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}"
					done
				fi
			fi
		done
		[[ nm -ne compstate[nmatches] ]] && return 0
	done
	for descr in "$mesgs[@]"
	do
		_message -e "${descr%%:*}" "${descr#*:}"
	done
	return 1
}
_analyseplugin () {
	# undefined
	builtin autoload -XUz
}
_ant () {
	# undefined
	builtin autoload -XUz
}
_antiword () {
	# undefined
	builtin autoload -XUz
}
_apachectl () {
	# undefined
	builtin autoload -XUz
}
_apm () {
	# undefined
	builtin autoload -XUz
}
_approximate () {
	# undefined
	builtin autoload -XUz
}
_apt () {
	# undefined
	builtin autoload -XUz
}
_apt-file () {
	# undefined
	builtin autoload -XUz
}
_apt-move () {
	# undefined
	builtin autoload -XUz
}
_apt-show-versions () {
	# undefined
	builtin autoload -XUz
}
_aptitude () {
	# undefined
	builtin autoload -XUz
}
_arch_archives () {
	# undefined
	builtin autoload -XUz
}
_arch_namespace () {
	# undefined
	builtin autoload -XUz
}
_arg_compile () {
	# undefined
	builtin autoload -XUz
}
_arguments () {
	local long cmd="$words[1]" descr odescr mesg subopts opt opt2 usecc autod
	local oldcontext="$curcontext" hasopts rawret optarg singopt alwopt
	local setnormarg start rest
	local -a match mbegin mend
	long=$argv[(I)--] 
	if (( long ))
	then
		local name tmp tmpargv
		if [[ long -eq 1 ]]
		then
			tmpargv=() 
		else
			tmpargv=("${(@)argv[1,long-1]}") 
		fi
		name=${~words[1]} 
		[[ "$name" = [^/]*/* ]] && name="$PWD/$name" 
		name="_args_cache_${name}" 
		name="${name//[^a-zA-Z0-9_]/_}" 
		if (( ! ${(P)+name} ))
		then
			local iopts sopts pattern tmpo dir cur cache
			typeset -U lopts
			cache=() 
			set -- "${(@)argv[long+1,-1]}"
			iopts=() 
			sopts=() 
			while [[ "$1" = -[is]* ]]
			do
				if [[ "$1" = -??* ]]
				then
					tmp="${1[3,-1]}" 
					cur=1 
				else
					tmp="$2" 
					cur=2 
				fi
				if [[ "$tmp[1]" = '(' ]]
				then
					tmp=(${=tmp[2,-2]}) 
				else
					tmp=("${(@P)tmp}") 
				fi
				if [[ "$1" = -i* ]]
				then
					iopts+=("$tmp[@]") 
				else
					sopts+=("$tmp[@]") 
				fi
				shift cur
			done
			tmp=() 
			_call_program options ${~words[1]} --help 2>&1 | while IFS= read -r opt
			do
				if (( ${#tmp} ))
				then
					if [[ $opt = [[:space:]][[:space:]][[:space:]]*[[:alpha:]]* ]]
					then
						opt=${opt##[[:space:]]##} 
						lopts+=("${^tmp[@]}":${${${opt//:/-}//\[/(}//\]/)}) 
						tmp=() 
						continue
					else
						lopts+=("${tmp[@]}") 
						tmp=() 
					fi
				fi
				while [[ $opt = [,[:space:]]#(#b)(-[^,[:space:]]#)(*) ]]
				do
					start=${match[1]} 
					rest=${match[2]} 
					if [[ -z ${tmp[(r)${start%%[^a-zA-Z0-9_-]#}]} ]]
					then
						if [[ $start = (#b)(*)\[(*)\](*) ]]
						then
							tmp+=("${match[1]}${match[2]}${match[3]}" "${match[1]}${match[3]}") 
						else
							tmp+=($start) 
						fi
					fi
					opt=$rest 
				done
				opt=${opt## [^[:space:]]##  } 
				opt=${opt##[[:space:]]##} 
				if [[ -n $opt ]]
				then
					lopts+=("${^tmp[@]}":${${${opt//:/-}//\[/(}//\]/)}) 
					tmp=() 
				fi
			done
			if (( ${#tmp} ))
			then
				lopts+=("${tmp[@]}") 
			fi
			tmp=() 
			for opt in "${(@)${(@)lopts:#--}%%[\[:=]*}"
			do
				let "$tmpargv[(I)(|\([^\)]#\))(|\*)${opt}(|[-+]|=(|-))(|\[*\])(|:*)]" || tmp+=("$lopts[(r)$opt(|[\[:=]*)]") 
			done
			lopts=("$tmp[@]") 
			while (( $#iopts ))
			do
				lopts=(${lopts:#$~iopts[1](|[\[:=]*)}) 
				shift iopts
			done
			while (( $#sopts ))
			do
				lopts+=(${lopts/$~sopts[1]/$sopts[2]}) 
				shift 2 sopts
			done
			argv+=('*=FILE*:file:_files' '*=(DIR|PATH)*:directory:_files -/' '*=*:=: ' '*: :  ') 
			while (( $# ))
			do
				pattern="${${${(M)1#*[^\\]:}[1,-2]}//\\\\:/:}" 
				descr="${1#${pattern}}" 
				if [[ "$pattern" = *\(-\) ]]
				then
					pattern="$pattern[1,-4]" 
					dir=- 
				else
					dir= 
				fi
				shift
				tmp=("${(@M)lopts:##$~pattern(|:*)}") 
				lopts=("${(@)lopts:##$~pattern(|:*)}") 
				(( $#tmp )) || continue
				opt='' 
				tmpo=("${(@M)tmp:#*\[\=*}") 
				if (( $#tmpo ))
				then
					tmp=("${(@)tmp:#*\[\=*}") 
					for opt in "$tmpo[@]"
					do
						if [[ $opt = (#b)(*):([^:]#) ]]
						then
							opt=$match[1] 
							odescr="[${match[2]}]" 
						else
							odescr= 
						fi
						if [[ $opt = (#b)(*)\[\=* ]]
						then
							opt2=${${match[1]}//[^a-zA-Z0-9_-]}=-${dir}${odescr} 
						else
							opt2=${${opt}//[^a-zA-Z0-9_-]}=${dir}${odescr} 
						fi
						if [[ "$descr" = :\=* ]]
						then
							cache+=("${opt2}::${(L)${opt%\]}#*\=}: ") 
						elif [[ "$descr" = ::* ]]
						then
							cache+=("${opt2}${descr}") 
						else
							cache+=("${opt2}:${descr}") 
						fi
					done
				fi
				tmpo=("${(@M)tmp:#*\=*}") 
				if (( $#tmpo ))
				then
					tmp=("${(@)tmp:#*\=*}") 
					for opt in "$tmpo[@]"
					do
						if [[ $opt = (#b)(*):([^:]#) ]]
						then
							opt=$match[1] 
							odescr="[${match[2]}]" 
						else
							odescr= 
						fi
						opt2="${${opt%%\=*}//[^a-zA-Z0-9_-]}=${dir}${odescr}" 
						if [[ "$descr" = :\=* ]]
						then
							cache+=("${opt2}:${(L)${opt%\]}#*\=}: ") 
						else
							cache+=("${opt2}${descr}") 
						fi
					done
				fi
				if (( $#tmp ))
				then
					tmp=("${(@)^${(@)tmp:#^*:*}//:/[}]" "${(@)${(@)tmp:#*:*}//[^a-zA-Z0-9_-]}") 
					if [[ -n "$descr" && "$descr" != ': :  ' ]]
					then
						cache+=("${(@)^tmp}${descr}") 
					else
						cache+=("$tmp[@]") 
					fi
				fi
			done
			set -A "$name" "${(@)cache:# #}"
		fi
		set -- "$tmpargv[@]" "${(@P)name}"
	fi
	subopts=() 
	singopt=() 
	while [[ "$1" = -(O*|[CRWnsw]) ]]
	do
		case "$1" in
			(-C) usecc=yes 
				shift ;;
			(-O) subopts=("${(@P)2}") 
				shift 2 ;;
			(-O*) subopts=("${(@P)${1[3,-1]}}") 
				shift ;;
			(-R) rawret=yes 
				shift ;;
			(-n) setnormarg=yes 
				NORMARG=-1 
				shift ;;
			(-w) optarg=yes 
				shift ;;
			(-s) singopt=(-s) 
				shift ;;
			(-W) alwopt=arg 
				shift ;;
		esac
	done
	[[ "$PREFIX" = [-+] ]] && alwopt=arg 
	zstyle -s ":completion:${curcontext}:options" auto-description autod
	if (( $# )) && comparguments -i "$autod" "$singopt[@]" "$@"
	then
		local action noargs aret expl local tried ret=1
		local next direct odirect equal single matcher matched ws tmp1 tmp2 tmp3
		local opts subc tc prefix suffix descrs actions subcs anum
		local origpre="$PREFIX" origipre="$IPREFIX" nm="$compstate[nmatches]"
		if comparguments -D descrs actions subcs
		then
			if comparguments -O next direct odirect equal
			then
				opts=yes 
				_tags "$subcs[@]" options
			else
				_tags "$subcs[@]"
			fi
		else
			if comparguments -a
			then
				noargs='no more arguments' 
			else
				noargs='no arguments' 
			fi
			if comparguments -O next direct odirect equal
			then
				opts=yes 
				_tags options
			elif [[ $? -eq 2 ]]
			then
				compadd -Q - "${PREFIX}${SUFFIX}"
				return 0
			else
				_message "$noargs"
				return 1
			fi
		fi
		comparguments -M matcher
		context=() 
		state=() 
		state_descr=() 
		while true
		do
			while _tags
			do
				anum=1 
				if [[ -z "$tried" ]]
				then
					while [[ anum -le $#descrs ]]
					do
						action="$actions[anum]" 
						descr="$descrs[anum]" 
						subc="$subcs[anum++]" 
						if [[ $subc = argument* && -n $setnormarg ]]
						then
							comparguments -n NORMARG
						fi
						if [[ -n "$matched" ]] || _requested "$subc"
						then
							curcontext="${oldcontext%:*}:$subc" 
							_description "$subc" expl "$descr"
							if [[ "$action" = \=\ * ]]
							then
								action="$action[3,-1]" 
								words=("$subc" "$words[@]") 
								(( CURRENT++ ))
							fi
							if [[ "$action" = -\>* ]]
							then
								action="${${action[3,-1]##[ 	]#}%%[ 	]#}" 
								if (( ! $state[(I)$action] ))
								then
									comparguments -W line opt_args
									state+=("$action") 
									state_descr+=("$descr") 
									if [[ -n "$usecc" ]]
									then
										curcontext="${oldcontext%:*}:$subc" 
									else
										context+=("$subc") 
									fi
									compstate[restore]='' 
									aret=yes 
								fi
							else
								if [[ -z "$local" ]]
								then
									local line
									typeset -A opt_args
									local=yes 
								fi
								comparguments -W line opt_args
								if [[ "$action" = \ # ]]
								then
									_message -e "$subc" "$descr"
									mesg=yes 
									tried=yes 
									alwopt=${alwopt:-yes} 
								elif [[ "$action" = \(\(*\)\) ]]
								then
									eval ws\=\( "${action[3,-3]}" \)
									_describe -t "$subc" "$descr" ws -M "$matcher" "$subopts[@]" || alwopt=${alwopt:-yes} 
									tried=yes 
								elif [[ "$action" = \(*\) ]]
								then
									eval ws\=\( "${action[2,-2]}" \)
									_all_labels "$subc" expl "$descr" compadd "$subopts[@]" -a - ws || alwopt=${alwopt:-yes} 
									tried=yes 
								elif [[ "$action" = \{*\} ]]
								then
									while _next_label "$subc" expl "$descr"
									do
										eval "$action[2,-2]" && ret=0 
									done
									(( ret )) && alwopt=${alwopt:-yes} 
									tried=yes 
								elif [[ "$action" = \ * ]]
								then
									eval "action=( $action )"
									while _next_label "$subc" expl "$descr"
									do
										"$action[@]" && ret=0 
									done
									(( ret )) && alwopt=${alwopt:-yes} 
									tried=yes 
								else
									eval "action=( $action )"
									while _next_label "$subc" expl "$descr"
									do
										"$action[1]" "$subopts[@]" "$expl[@]" "${(@)action[2,-1]}" && ret=0 
									done
									(( ret )) && alwopt=${alwopt:-yes} 
									tried=yes 
								fi
							fi
						fi
					done
				fi
				if _requested options && [[ -z "$hasopts" && -z "$matched" && ( -z "$aret" || "$PREFIX" = "$origpre" ) ]] && {
						! zstyle -T ":completion:${oldcontext%:*}:options" prefix-needed || [[ "$origpre" = [-+]* || -z "$aret$mesg$tried" ]]
					}
				then
					local prevpre="$PREFIX" previpre="$IPREFIX" prevcontext="$curcontext"
					curcontext="${oldcontext%:*}:options" 
					hasopts=yes 
					PREFIX="$origpre" 
					IPREFIX="$origipre" 
					if [[ -z "$alwopt" || -z "$tried" || "$alwopt" = arg ]] && comparguments -s single
					then
						if [[ "$single" = direct ]]
						then
							_all_labels options expl option compadd -QS '' - "${PREFIX}${SUFFIX}"
						elif [[ -z "$optarg" && "$single" = next ]]
						then
							_all_labels options expl option compadd -Q - "${PREFIX}${SUFFIX}"
						elif [[ "$single" = equal ]]
						then
							_all_labels options expl option compadd -QqS= - "${PREFIX}${SUFFIX}"
						else
							tmp1=("$next[@]" "$direct[@]" "$odirect[@]" "$equal[@]") 
							[[ "$PREFIX" = [-+]* ]] && tmp1=("${(@M)tmp1:#${PREFIX[1]}*}") 
							[[ "$single" = next ]] && tmp1=("${(@)tmp1:#[-+]${PREFIX[-1]}((#e)|:*)}") 
							[[ "$PREFIX" != --* ]] && tmp1=("${(@)tmp1:#--*}") 
							tmp3=("${(M@)tmp1:#[-+]?[^:]*}") 
							tmp1=("${(M@)tmp1:#[-+]?(|:*)}") 
							tmp2=("${PREFIX}${(@M)^${(@)${(@)tmp1%%:*}#[-+]}:#?}") 
							_describe -O option tmp1 tmp2 -Q -S '' -- tmp3 -Q
							[[ -n "$optarg" && "$single" = next && nm -eq $compstate[nmatches] ]] && _all_labels options expl option compadd -Q - "${PREFIX}${SUFFIX}"
						fi
						single=yes 
					else
						next+=("$odirect[@]") 
						_describe -O option next -Q -M "$matcher" -- direct -QS '' -M "$matcher" -- equal -QqS= -M "$matcher"
					fi
					PREFIX="$prevpre" 
					IPREFIX="$previpre" 
					curcontext="$prevcontext" 
				fi
				[[ -n "$tried" && "${${alwopt:+$origpre}:-$PREFIX}" != [-+]* ]] && break
			done
			if [[ -n "$opts" && -z "$aret" && -z "$matched" && ( -z "$tried" || -n "$alwopt" ) && nm -eq compstate[nmatches] ]]
			then
				PREFIX="$origpre" 
				IPREFIX="$origipre" 
				prefix="${PREFIX#*\=}" 
				suffix="$SUFFIX" 
				PREFIX="${PREFIX%%\=*}" 
				SUFFIX='' 
				compadd -M "$matcher" -D equal - "${(@)equal%%:*}"
				if [[ $#equal -eq 1 ]]
				then
					PREFIX="$prefix" 
					SUFFIX="$suffix" 
					IPREFIX="${IPREFIX}${equal[1]%%:*}=" 
					matched=yes 
					comparguments -L "${equal[1]%%:*}" descrs actions subcs
					_tags "$subcs[@]"
					continue
				fi
			fi
			break
		done
		[[ -z "$aret" || -z "$usecc" ]] && curcontext="$oldcontext" 
		if [[ -n "$aret" ]]
		then
			[[ -n $rawret ]] && return 300
		else
			[[ -n "$noargs" && nm -eq "$compstate[nmatches]" ]] && _message "$noargs"
		fi
		[[ nm -ne "$compstate[nmatches]" ]]
	else
		return 1
	fi
}
_arp () {
	# undefined
	builtin autoload -XUz
}
_arping () {
	# undefined
	builtin autoload -XUz
}
_arrays () {
	# undefined
	builtin autoload -XUz
}
_assign () {
	# undefined
	builtin autoload -XUz
}
_at () {
	# undefined
	builtin autoload -XUz
}
_attr () {
	# undefined
	builtin autoload -XUz
}
_auto-apt () {
	# undefined
	builtin autoload -XUz
}
_autocd () {
	# undefined
	builtin autoload -XUz
}
_awk () {
	# undefined
	builtin autoload -XUz
}
_axi-cache () {
	# undefined
	builtin autoload -XUz
}
_bash_completions () {
	# undefined
	builtin autoload -XUz
}
_baz () {
	# undefined
	builtin autoload -XUz
}
_be_name () {
	# undefined
	builtin autoload -XUz
}
_beadm () {
	# undefined
	builtin autoload -XUz
}
_bind_addresses () {
	# undefined
	builtin autoload -XUz
}
_bindkey () {
	# undefined
	builtin autoload -XUz
}
_bison () {
	# undefined
	builtin autoload -XUz
}
_bittorrent () {
	# undefined
	builtin autoload -XUz
}
_bogofilter () {
	# undefined
	builtin autoload -XUz
}
_brace_parameter () {
	# undefined
	builtin autoload -XUz
}
_brctl () {
	# undefined
	builtin autoload -XUz
}
_bsd_pkg () {
	# undefined
	builtin autoload -XUz
}
_btrfs () {
	# undefined
	builtin autoload -XUz
}
_bts () {
	# undefined
	builtin autoload -XUz
}
_bug () {
	# undefined
	builtin autoload -XUz
}
_builtin () {
	# undefined
	builtin autoload -XUz
}
_bzip2 () {
	# undefined
	builtin autoload -XUz
}
_bzr () {
	# undefined
	builtin autoload -XUz
}
_cache_invalid () {
	# undefined
	builtin autoload -XUz
}
_cal () {
	# undefined
	builtin autoload -XUz
}
_calendar () {
	# undefined
	builtin autoload -XUz
}
_call_function () {
	local _name _ret
	[[ "$1" != (|-) ]] && _name="$1" 
	shift
	if (( $+functions[$1] ))
	then
		"$@"
		_ret="$?" 
		[[ -n "$_name" ]] && eval "${_name}=${_ret}"
		compstate[restore]='' 
		return 0
	fi
	return 1
}
_call_program () {
	local tmp
	if zstyle -s ":completion:${curcontext}:${1}" command tmp
	then
		if [[ "$tmp" = -* ]]
		then
			eval "$tmp[2,-1]" "$argv[2,-1]"
		else
			eval "$tmp"
		fi
	else
		eval "$argv[2,-1]"
	fi
}
_canonical_paths () {
	# undefined
	builtin autoload -XUz
}
_ccal () {
	# undefined
	builtin autoload -XUz
}
_cd () {
	# undefined
	builtin autoload -XUz
}
_cdbs-edit-patch () {
	# undefined
	builtin autoload -XUz
}
_cdcd () {
	# undefined
	builtin autoload -XUz
}
_cdr () {
	# undefined
	builtin autoload -XUz
}
_cdrdao () {
	# undefined
	builtin autoload -XUz
}
_cdrecord () {
	# undefined
	builtin autoload -XUz
}
_chflags () {
	# undefined
	builtin autoload -XUz
}
_chkconfig () {
	# undefined
	builtin autoload -XUz
}
_chmod () {
	# undefined
	builtin autoload -XUz
}
_chown () {
	# undefined
	builtin autoload -XUz
}
_chrt () {
	# undefined
	builtin autoload -XUz
}
_clay () {
	# undefined
	builtin autoload -XUz
}
_combination () {
	# undefined
	builtin autoload -XUz
}
_comm () {
	# undefined
	builtin autoload -XUz
}
_command () {
	# undefined
	builtin autoload -XUz
}
_command_names () {
	# undefined
	builtin autoload -XUz
}
_compdef () {
	# undefined
	builtin autoload -XUz
}
_complete () {
	local comp name oldcontext ret=1 service
	typeset -T curcontext="$curcontext" ccarray
	oldcontext="$curcontext" 
	if [[ -n "$compcontext" ]]
	then
		if [[ "${(t)compcontext}" = *array* ]]
		then
			local expl
			_wanted values expl value compadd -a - compcontext
		elif [[ "${(t)compcontext}" = *assoc* ]]
		then
			local expl tmp i
			tmp=() 
			for i in "${(@k)compcontext[(R)*[^[:blank:]]]}"
			do
				tmp=("$tmp[@]" "${i}:${compcontext[$i]}") 
			done
			tmp=("$tmp[@]" "${(k@)compcontext[(R)[[:blank:]]#]}") 
			_describe -t values value tmp
		elif [[ "$compcontext" = *:*:* ]]
		then
			local tag="${${compcontext%%:*}:-values}"
			local descr="${${${compcontext#${tag}:}%%:*}:-value}"
			local action="${compcontext#${tag}:${descr}:}" expl ws ret=1
			case "$action" in
				(\ #) _message -e "$tag" "$descr" ;;
				(\(\(*\)\)) eval ws\=\( "${action[3,-3]}" \)
					_describe -t "$tag" "$descr" ws ;;
				(\(*\)) eval ws\=\( "${action[2,-2]}" \)
					_wanted "$tag" expl "$descr" compadd -a - ws ;;
				(\{*\}) _tags "$tag"
					while _tags
					do
						while _next_label "$tag" expl "$descr"
						do
							eval "$action[2,-2]" && ret=0 
						done
						(( ret )) || break
					done ;;
				(\ *) eval ws\=\( "$action" \)
					_tags "$tag"
					while _tags
					do
						while _next_label "$tag" expl "$descr"
						do
							"$ws[@]"
						done
						(( ret )) || break
					done ;;
				(*) eval ws\=\( "$action" \)
					_tags "$tag"
					while _tags
					do
						while _next_label "$tag" expl "$descr"
						do
							"$ws[1]" "$expl[@]" "${(@)ws[2,-1]}"
						done
						(( ret )) || break
					done ;;
			esac
		else
			ccarray[3]="$compcontext" 
			comp="$_comps[$compcontext]" 
			[[ -n "$comp" ]] && eval "$comp"
		fi
		return
	fi
	comp="$_comps[-first-]" 
	if [[ -n "$comp" ]]
	then
		service="${_services[-first-]:--first-}" 
		ccarray[3]=-first- 
		eval "$comp" && ret=0 
		if [[ "$_compskip" = all ]]
		then
			_compskip= 
			return ret
		fi
	fi
	[[ -n $compstate[vared] ]] && compstate[context]=vared 
	ret=1 
	if [[ "$compstate[context]" = command ]]
	then
		curcontext="$oldcontext" 
		_normal -s && ret=0 
	else
		local cname="-${compstate[context]:s/_/-/}-"
		ccarray[3]="$cname" 
		comp="$_comps[$cname]" 
		service="${_services[$cname]:-$cname}" 
		if [[ -z "$comp" ]]
		then
			if [[ "$_compskip" = *default* ]]
			then
				_compskip= 
				return 1
			fi
			comp="$_comps[-default-]" 
			service="${_services[-default-]:--default-}" 
		fi
		[[ -n "$comp" ]] && eval "$comp" && ret=0 
	fi
	_compskip= 
	return ret
}
_complete_debug () {
	# undefined
	builtin autoload -XUz
}
_complete_help () {
	# undefined
	builtin autoload -XUz
}
_complete_help_generic () {
	# undefined
	builtin autoload -XUz
}
_complete_tag () {
	# undefined
	builtin autoload -XUz
}
_compress () {
	# undefined
	builtin autoload -XUz
}
_condition () {
	# undefined
	builtin autoload -XUz
}
_configure () {
	# undefined
	builtin autoload -XUz
}
_coreadm () {
	# undefined
	builtin autoload -XUz
}
_correct () {
	# undefined
	builtin autoload -XUz
}
_correct_filename () {
	# undefined
	builtin autoload -XUz
}
_correct_word () {
	# undefined
	builtin autoload -XUz
}
_cowsay () {
	# undefined
	builtin autoload -XUz
}
_cp () {
	_arguments -s '(-a --archive)'{-a,--archive}'[same as -dpR]' '(-b --backup)-b[backup]' '(-b --backup)--backup=[backup]:method:(none off numbered t existing nil simple never)' '--copy-contents[copy contents of special files when recursive]' '-d[same as --no-dereference --preserve=links]' '(-f --force)'{-f,--force}'[remove and retry for destinations that cannot be opened]' '(-i --interactive)'{-i,--interactive}'[prompt before overwrite]' '-H[follow command-line symbolic links]' '(-l --link)'{-l,--link}'[link files instead of copying]' '(-L --dereference)'{-L,--dereference}'[always follow symbolic links]' '(-n --no-clobber)'{-n,--no-clobber}'[do not overwrite an existing file]' '(-P --no-dereference)'{-P,--no-dereference}'[never follow symbolic links]' '-p[same as --preserve=mode,ownership,timestamps]' '--preserve=[preserve specified attributes]:attributes to preserve:_values -s , mode timestamps ownership links context xattr all' '--no-preserve=[don'\''t preserve specified attributes]:attributes not to preserve:_values -s , mode timestamps ownership links context xattr all' '--parents[append source path to target directory]' '(-R -r --recursive)'{-R,-r,--recursive}'[copy directories recursively]' '--reflink=[control clone/CoW copies]:when to perform a lightweight copy:(always auto)' '--remove-destination[remove each existing destination file before attempting to open it]' '--sparse=[control creation of sparse files]:when to create sparse files:(auto always never)' '--strip-trailing-slashes[remove any trailing slashes from each source argument]' '(-s --symbolic-link)'{-s,--symbolic-link}'[make symbolic links instead of copies of non-directories]' '(-S --suffix)'{-S,--suffix=}'[override the usual backup suffix]:backup suffix:' '(-t --target-directory)'{-t,--target-directory=}'[copy all source arguments into target directory]:target directory:_files -/' '(-T --no-target-directory)'{-T,--no-target-directory}'[treat DEST as a normal file]' '(-u --update)'{-u,--update}'[copy only when source is newer than destination or destination is missing]' '(-v --verbose)'{-v,--verbose}'[explain what is being done]' '(-x --one-file-system)'{-x,--one-file-system}'[stay on this file system]' '--help' '--version' '*:file or directory:_files'
}
_cpio () {
	# undefined
	builtin autoload -XUz
}
_cplay () {
	# undefined
	builtin autoload -XUz
}
_cryptsetup () {
	# undefined
	builtin autoload -XUz
}
_cssh () {
	# undefined
	builtin autoload -XUz
}
_csup () {
	# undefined
	builtin autoload -XUz
}
_ctags_tags () {
	# undefined
	builtin autoload -XUz
}
_cut () {
	# undefined
	builtin autoload -XUz
}
_cvs () {
	# undefined
	builtin autoload -XUz
}
_cvsup () {
	# undefined
	builtin autoload -XUz
}
_cygcheck () {
	# undefined
	builtin autoload -XUz
}
_cygpath () {
	# undefined
	builtin autoload -XUz
}
_cygrunsrv () {
	# undefined
	builtin autoload -XUz
}
_cygserver () {
	# undefined
	builtin autoload -XUz
}
_cygstart () {
	# undefined
	builtin autoload -XUz
}
_dak () {
	# undefined
	builtin autoload -XUz
}
_darcs () {
	# undefined
	builtin autoload -XUz
}
_date () {
	# undefined
	builtin autoload -XUz
}
_dbus () {
	# undefined
	builtin autoload -XUz
}
_dchroot () {
	# undefined
	builtin autoload -XUz
}
_dchroot-dsa () {
	# undefined
	builtin autoload -XUz
}
_dcop () {
	# undefined
	builtin autoload -XUz
}
_dd () {
	# undefined
	builtin autoload -XUz
}
_deb_packages () {
	# undefined
	builtin autoload -XUz
}
_debchange () {
	# undefined
	builtin autoload -XUz
}
_debdiff () {
	# undefined
	builtin autoload -XUz
}
_debfoster () {
	# undefined
	builtin autoload -XUz
}
_debsign () {
	# undefined
	builtin autoload -XUz
}
_default () {
	local ctl
	if {
			zstyle -s ":completion:${curcontext}:" use-compctl ctl || zmodload -e zsh/compctl
		} && [[ "$ctl" != (no|false|0|off) ]]
	then
		local opt
		opt=() 
		[[ "$ctl" = *first* ]] && opt=(-T) 
		[[ "$ctl" = *default* ]] && opt=("$opt[@]" -D) 
		compcall "$opt[@]" || return 0
	fi
	_files "$@" && return 0
	if [[ -o magicequalsubst && "$PREFIX" = *\=* ]]
	then
		compstate[parameter]="${PREFIX%%\=*}" 
		compset -P 1 '*='
		_value "$@"
	else
		return 1
	fi
}
_defaults () {
	# undefined
	builtin autoload -XUz
}
_delimiters () {
	# undefined
	builtin autoload -XUz
}
_describe () {
	# undefined
	builtin autoload -XUz
}
_description () {
	local name gropt nopt xopt format gname hidden hide match opts tag sort
	opts=() 
	gropt=(-J) 
	xopt=(-X) 
	nopt=() 
	zparseopts -K -D -a nopt 1 2 V=gropt J=gropt x=xopt
	3="${${3##[[:blank:]]#}%%[[:blank:]]#}" 
	[[ -n "$3" ]] && _lastdescr=("$_lastdescr[@]" "$3") 
	zstyle -s ":completion:${curcontext}:$1" group-name gname && [[ -z "$gname" ]] && gname="$1" 
	_setup "$1" "${gname:--default-}"
	name="$2" 
	zstyle -s ":completion:${curcontext}:$1" format format || zstyle -s ":completion:${curcontext}:descriptions" format format
	if zstyle -s ":completion:${curcontext}:$1" hidden hidden && [[ "$hidden" = (all|yes|true|1|on) ]]
	then
		[[ "$hidden" = all ]] && format='' 
		opts=(-n) 
	fi
	zstyle -s ":completion:${curcontext}:$1" matcher match && opts=($opts -M "$match") 
	[[ -n "$_matcher" ]] && opts=($opts -M "$_matcher") 
	if {
			zstyle -s ":completion:${curcontext}:$1" sort sort || zstyle -s ":completion:${curcontext}:" sort sort
		} && [[ "$gropt" = -J && $sort != menu ]]
	then
		if [[ "$sort" = (yes|true|1|on) ]]
		then
			gropt=(-J) 
		else
			gropt=(-V) 
		fi
	fi
	if [[ -z "$_comp_no_ignore" ]]
	then
		zstyle -a ":completion:${curcontext}:$1" ignored-patterns _comp_ignore || _comp_ignore=() 
		zstyle -s ":completion:${curcontext}:$1" ignore-line hidden && case "$hidden" in
			(true|yes|on|1) _comp_ignore=("$_comp_ignore[@]" ${(q)"${words[@]}"})  ;;
			(current) _comp_ignore=("$_comp_ignore[@]" "${(q)words[CURRENT]}")  ;;
			(current-shown) [[ "$compstate[old_list]" = *shown* ]] && _comp_ignore=("$_comp_ignore[@]" "${(q)words[CURRENT]}")  ;;
			(other) _comp_ignore=("$_comp_ignore[@]" "${(@q)words[1,CURRENT-1]}" "${(@q)words[CURRENT+1,-1]}")  ;;
		esac
		(( $#_comp_ignore )) && opts=(-F _comp_ignore $opts) 
	else
		_comp_ignore=() 
	fi
	tag="$1" 
	shift 2
	if [[ -z "$1" && $# -eq 1 ]]
	then
		format= 
	elif [[ -n "$format" ]]
	then
		zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
	fi
	if [[ -n "$gname" ]]
	then
		if [[ -n "$format" ]]
		then
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" "$gname" "$xopt" "$format"
		else
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" "$gname"
		fi
	else
		if [[ -n "$format" ]]
		then
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" -default- "$xopt" "$format"
		else
			set -A "$name" "$opts[@]" "$nopt[@]" "$gropt" -default-
		fi
	fi
	if ! (( ${funcstack[2,-1][(I)_description]} ))
	then
		local fakestyle descr
		for fakestyle in fake fake-always
		do
			zstyle -a ":completion:${curcontext}:$tag" $fakestyle match || continue
			descr=("${(@M)match:#*[^\\]:*}") 
			opts=("${(@P)name}") 
			if [[ $fakestyle = fake-always && $opts[1,2] = "-F _comp_ignore" ]]
			then
				shift 2 opts
			fi
			compadd "${(@)opts}" - "${(@)${(@)match:#*[^\\]:*}:s/\\:/:/}"
			(( $#descr )) && _describe -t "$tag" '' descr "${(@)opts}"
		done
	fi
	return 0
}
_devtodo () {
	# undefined
	builtin autoload -XUz
}
_dhclient () {
	# undefined
	builtin autoload -XUz
}
_dhcpinfo () {
	# undefined
	builtin autoload -XUz
}
_dict () {
	# undefined
	builtin autoload -XUz
}
_dict_words () {
	# undefined
	builtin autoload -XUz
}
_diff () {
	# undefined
	builtin autoload -XUz
}
_diff_options () {
	# undefined
	builtin autoload -XUz
}
_diffstat () {
	# undefined
	builtin autoload -XUz
}
_dir_list () {
	# undefined
	builtin autoload -XUz
}
_directories () {
	# undefined
	builtin autoload -XUz
}
_directory_stack () {
	# undefined
	builtin autoload -XUz
}
_dirs () {
	# undefined
	builtin autoload -XUz
}
_disable () {
	# undefined
	builtin autoload -XUz
}
_dispatch () {
	local comp pat val name i ret=1 _compskip="$_compskip"
	local curcontext="$curcontext" service str noskip
	local -a match mbegin mend
	if [[ "$1" = -s ]]
	then
		noskip=yes 
		shift
	fi
	[[ -z "$noskip" ]] && _compskip= 
	curcontext="${curcontext%:*:*}:${1}:" 
	shift
	if [[ "$_compskip" != (all|*patterns*) ]]
	then
		for str in "$@"
		do
			[[ -n "$str" ]] || continue
			service="${_services[$str]:-$str}" 
			for i in "${(@)_patcomps[(K)$str]}"
			do
				if [[ $i = (#b)"="([^=]#)"="(*) ]]
				then
					service=$match[1] 
					i=$match[2] 
				fi
				eval "$i" && ret=0 
				if [[ "$_compskip" = *patterns* ]]
				then
					break
				elif [[ "$_compskip" = all ]]
				then
					_compskip='' 
					return ret
				fi
			done
		done
	fi
	ret=1 
	for str in "$@"
	do
		[[ -n "$str" ]] || continue
		str=${(Q)str} 
		name="$str" 
		comp="${_comps[$str]}" 
		service="${_services[$str]:-$str}" 
		[[ -z "$comp" ]] || break
	done
	if [[ -n "$comp" && "$name" != "${argv[-1]}" ]]
	then
		_compskip=patterns 
		eval "$comp" && ret=0 
		[[ "$_compskip" = (all|*patterns*) ]] && return ret
	fi
	if [[ "$_compskip" != (all|*patterns*) ]]
	then
		for str
		do
			[[ -n "$str" ]] || continue
			service="${_services[$str]:-$str}" 
			for i in "${(@)_postpatcomps[(K)$str]}"
			do
				_compskip=default 
				eval "$i" && ret=0 
				if [[ "$_compskip" = *patterns* ]]
				then
					break
				elif [[ "$_compskip" = all ]]
				then
					_compskip='' 
					return ret
				fi
			done
		done
	fi
	[[ "$name" = "${argv[-1]}" && -n "$comp" && "$_compskip" != (all|*default*) ]] && service="${_services[$name]:-$name}"  && eval "$comp" && ret=0 
	_compskip='' 
	return ret
}
_django () {
	# undefined
	builtin autoload -XUz
}
_dladm () {
	# undefined
	builtin autoload -XUz
}
_dlocate () {
	# undefined
	builtin autoload -XUz
}
_dmidecode () {
	# undefined
	builtin autoload -XUz
}
_domains () {
	# undefined
	builtin autoload -XUz
}
_dpatch-edit-patch () {
	# undefined
	builtin autoload -XUz
}
_dpkg () {
	# undefined
	builtin autoload -XUz
}
_dpkg-buildpackage () {
	# undefined
	builtin autoload -XUz
}
_dpkg-cross () {
	# undefined
	builtin autoload -XUz
}
_dpkg-repack () {
	# undefined
	builtin autoload -XUz
}
_dpkg_source () {
	# undefined
	builtin autoload -XUz
}
_dput () {
	# undefined
	builtin autoload -XUz
}
_dtrace () {
	# undefined
	builtin autoload -XUz
}
_du () {
	# undefined
	builtin autoload -XUz
}
_dumpadm () {
	# undefined
	builtin autoload -XUz
}
_dumper () {
	# undefined
	builtin autoload -XUz
}
_dupload () {
	# undefined
	builtin autoload -XUz
}
_dvi () {
	# undefined
	builtin autoload -XUz
}
_dynamic_directory_name () {
	# undefined
	builtin autoload -XUz
}
_ecasound () {
	# undefined
	builtin autoload -XUz
}
_echotc () {
	# undefined
	builtin autoload -XUz
}
_echoti () {
	# undefined
	builtin autoload -XUz
}
_elinks () {
	# undefined
	builtin autoload -XUz
}
_elm () {
	# undefined
	builtin autoload -XUz
}
_email_addresses () {
	# undefined
	builtin autoload -XUz
}
_emulate () {
	# undefined
	builtin autoload -XUz
}
_enable () {
	# undefined
	builtin autoload -XUz
}
_enscript () {
	# undefined
	builtin autoload -XUz
}
_env () {
	# undefined
	builtin autoload -XUz
}
_equal () {
	# undefined
	builtin autoload -XUz
}
_espeak () {
	# undefined
	builtin autoload -XUz
}
_ethtool () {
	# undefined
	builtin autoload -XUz
}
_expand () {
	# undefined
	builtin autoload -XUz
}
_expand_alias () {
	# undefined
	builtin autoload -XUz
}
_expand_word () {
	# undefined
	builtin autoload -XUz
}
_fakeroot () {
	# undefined
	builtin autoload -XUz
}
_fc () {
	# undefined
	builtin autoload -XUz
}
_feh () {
	# undefined
	builtin autoload -XUz
}
_fetch () {
	# undefined
	builtin autoload -XUz
}
_fetchmail () {
	# undefined
	builtin autoload -XUz
}
_ffmpeg () {
	# undefined
	builtin autoload -XUz
}
_figlet () {
	# undefined
	builtin autoload -XUz
}
_file_descriptors () {
	# undefined
	builtin autoload -XUz
}
_file_systems () {
	# undefined
	builtin autoload -XUz
}
_files () {
	local opts tmp glob pat pats expl tag i def descr end ign ret=1 match tried
	local type sdef ignvars ignvar prepath oprefix rfiles rfile
	zparseopts -a opts '/=tmp' 'f=tmp' 'g+:-=tmp' q n 1 2 P: S: r: R: W: X+: M+: F: J+: V+:
	type="${(@j::M)${(@)tmp#-}#?}" 
	if (( $tmp[(I)-g*] ))
	then
		glob="${${${${(@M)tmp:#-g*}#-g}##[[:blank:]]#}%%[[:blank:]]#}" 
		[[ "$glob" = *[^\\][[:blank:]]* ]] && glob="{${glob//(#b)([^\\])[[:blank:]]##/${match[1]},}}" 
		[[ "$glob" = (#b)(*\()([^\|\~]##\)) && $match[2] != \#q* ]] && glob="${match[1]}#q${match[2]}" 
	fi
	tmp=$opts[(I)-F] 
	if (( tmp ))
	then
		ignvars=($=opts[tmp+1]) 
		if [[ $ignvars = _comp_ignore ]]
		then
			ign=($_comp_ignore) 
		else
			ign=() 
			for ignvar in $ignvars
			do
				ign+=(${(P)ignvar}) 
			done
			opts[tmp+1]=_comp_ignore 
		fi
	else
		ign=() 
	fi
	if zstyle -a ":completion:${curcontext}:" file-patterns tmp
	then
		[[ "$type" = */* ]] && glob="$glob,*(-/)" 
		pats=() 
		for i in ${tmp//\%p/${${glob:-\*}//:/\\:}}
		do
			if [[ $i = *[^\\]:* ]]
			then
				pats=("$pats[@]" " $i ") 
			else
				pats=("$pats[@]" " ${i}:files ") 
			fi
		done
	elif zstyle -t ":completion:${curcontext}:" list-dirs-first
	then
		if [[ "$type" = *g* ]]
		then
			if [[ "$glob" = (#b)(*\(\#q)(*\)) ]]
			then
				[[ $match[2] != \^-/* ]] && glob="${match[1]}^-/,${match[2]}" 
			else
				glob="$glob(#q^-/)" 
			fi
			pats=(" *(-/):directories:directories ${glob//:/\\:}:globbed-files") 
		elif [[ "$type" = */* ]]
		then
			pats=('*(-/):directories ' '*:all-files ') 
		else
			pats=('*(-/):directories:directories *(^-/):other-files ') 
		fi
	else
		if [[ "$type" = *g* ]]
		then
			pats=(" ${glob//:/\\:}:globbed-files *(-/):directories" '*:all-files ') 
		elif [[ "$type" = */* ]]
		then
			pats=('*(-/):directories ' '*:all-files ') 
		else
			pats=('*:all-files ') 
		fi
	fi
	tried=() 
	for def in "$pats[@]"
	do
		eval "def=( ${${def//\\:/\\\\\\:}//(#b)([][()|*?^#~<>])/\\${match[1]}} )"
		tmp="${(@M)def#*[^\\]:}" 
		(( $tried[(I)${(q)tmp}] )) && continue
		tried=("$tried[@]" "$tmp") 
		for sdef in "$def[@]"
		do
			tag="${${sdef#*[^\\]:}%%:*}" 
			pat="${${sdef%%:${tag}*}//\\:/:}" 
			if [[ "$sdef" = *:${tag}:* ]]
			then
				descr="${(Q)sdef#*:${tag}:}" 
			else
				if (( $opts[(I)-X] ))
				then
					descr= 
				else
					descr=file 
				fi
				end=yes 
			fi
			_tags "$tag"
			while _tags
			do
				_comp_ignore=() 
				while _next_label "$tag" expl "$descr"
				do
					_comp_ignore=($_comp_ignore $ign) 
					if [[ -n "$end" ]]
					then
						if _path_files -g "$pat" "$opts[@]" "$expl[@]"
						then
							ret=0 
						elif [[ $PREFIX$SUFFIX != */* ]] && zstyle -a ":completion:${curcontext}:$tag" recursive-files rfiles
						then
							for rfile in $rfiles
							do
								if [[ $PWD/ = ${~rfile} ]]
								then
									for prepath in **/*(/)
									do
										oprefix=$PREFIX 
										PREFIX=$prepath/$PREFIX 
										_path_files -g "$pat" "$opts[@]" "$expl[@]" && ret=0 
										PREFIX=$oprefix 
									done
									break
								fi
							done
						fi
					else
						_path_files "$expl[@]" -g "$pat" "$opts[@]" && ret=0 
					fi
				done
				(( ret )) || break
			done
			[[ "$pat" = '*' ]] && return ret
		done
		(( ret )) || return 0
	done
	return 1
}
_find () {
	# undefined
	builtin autoload -XUz
}
_finger () {
	# undefined
	builtin autoload -XUz
}
_fink () {
	# undefined
	builtin autoload -XUz
}
_first () {
	
}
_flasher () {
	# undefined
	builtin autoload -XUz
}
_flex () {
	# undefined
	builtin autoload -XUz
}
_floppy () {
	# undefined
	builtin autoload -XUz
}
_flowadm () {
	# undefined
	builtin autoload -XUz
}
_fmadm () {
	# undefined
	builtin autoload -XUz
}
_fortune () {
	# undefined
	builtin autoload -XUz
}
_freebsd-update () {
	# undefined
	builtin autoload -XUz
}
_fsh () {
	# undefined
	builtin autoload -XUz
}
_fstat () {
	# undefined
	builtin autoload -XUz
}
_functions () {
	# undefined
	builtin autoload -XUz
}
_fuse_arguments () {
	# undefined
	builtin autoload -XUz
}
_fuse_values () {
	# undefined
	builtin autoload -XUz
}
_fuser () {
	# undefined
	builtin autoload -XUz
}
_fusermount () {
	# undefined
	builtin autoload -XUz
}
_gcc () {
	# undefined
	builtin autoload -XUz
}
_gcore () {
	# undefined
	builtin autoload -XUz
}
_gdb () {
	# undefined
	builtin autoload -XUz
}
_generic () {
	# undefined
	builtin autoload -XUz
}
_genisoimage () {
	# undefined
	builtin autoload -XUz
}
_getclip () {
	# undefined
	builtin autoload -XUz
}
_getconf () {
	# undefined
	builtin autoload -XUz
}
_getent () {
	# undefined
	builtin autoload -XUz
}
_getfacl () {
	# undefined
	builtin autoload -XUz
}
_getmail () {
	# undefined
	builtin autoload -XUz
}
_git () {
	if (( CURRENT > 2 ))
	then
		local -a aliases
		local -A git_aliases
		aliases=(${(f)${${${(f)"$(_call_program aliases git config --get-regexp '\^alias\.')"}#alias.}/ /$'\n'}/(#e)/$'\n'}) 
		(( $#aliases % 2 == 0 )) && git_aliases=($aliases) 
		if (( $+git_aliases[$words[2]] && !$+commands[git-$words[2]] && !$+functions[_git-$words[2]] ))
		then
			local -a tmpwords expalias
			expalias=(${(z)git_aliases[$words[2]]}) 
			tmpwords=(${words[1]} ${expalias}) 
			if [[ -n "${words[3,-1]}" ]]
			then
				tmpwords+=(${words[3,-1]}) 
			fi
			[[ -n ${words[$CURRENT]} ]] || tmpwords+=('') 
			(( CURRENT += ${#expalias} - 1 ))
			words=("${tmpwords[@]}") 
			unset tmpwords expalias
		fi
		unset git_aliases aliases
	fi
	integer ret=1
	if [[ $service = git ]]
	then
		local curcontext=$curcontext state line
		declare -A opt_args
		_arguments -C '(- :)--version[display version information]' '(- :)--help[display help message]' '-c[pass configuration parameter to command]:parameter' '--exec-path=-[path containing core git-programs]:: :_directories' '--html-path[display path to HTML documentation and exit]' '(-p --paginate)'{-p,--paginate}'[pipe output into $PAGER]' '--no-pager[do not pipe git output into a pager]' '--git-dir=-[path to repository]: :_directories' '--work-tree=-[path to working tree]: :_directories' '--bare[use $PWD as repository]' '--no-replace-objects[do not use replacement refs to replace git objects]' '(-): :->command' '(-)*:: :->option-or-argument' && return
		case $state in
			(command) _git_commands && ret=0  ;;
			(option-or-argument) curcontext=${curcontext%:*:*}:git-$words[1]: 
				if (( $+functions[_git-$words[1]] ))
				then
					_call_function ret _git-$words[1]
				elif zstyle -T :completion:$curcontext: use-fallback
				then
					_files && ret=0 
				else
					_message 'unknown sub-command'
				fi ;;
		esac
	else
		_call_function ret _$service
	fi
	return ret
}
_git-add () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	local ignore_missing=
	if (( words[(I)-n|--dry-run] ))
	then
		ignore_missing='--ignore-missing[check if files (even missing) are ignored in dry run]' 
	fi
	_arguments -w -C -S -s '(-n --dry-run)'{-n,--dry-run}'[do not actually add files; only show which ones would be added]' '(-v --verbose)'{-v,--verbose}'[show files as they are added]' '(-f --force)'{-f,--force}'[allow adding otherwise ignored files]' '(-i --interactive : -)'{-i,--interactive}'[add contents interactively to index]' '(-p --patch)'{-p,--patch}'[like -i but go directly into patch mode for specified files]' '(-e --edit)'{-e,--edit}'[open diff against index in editor]' '(-u --update -A --all)'{-u,--update}'[update only files git already knows about]' '(-A --all -u --update)'{-A,--all}'[act as both add . and add -u]' '(-N --intent-to-add)'{-N,--intent-to-add}'[record only that path will be added later]' '--refresh[do not add files, but refresh their stat() info in index]' '--ignore-errors[continue adding if an error occurs]' $ignore_missing '*:: :->file' && return
	case $state in
		(file) declare -a ignored_files_alternatives
			if [[ -n ${opt_args[(I)-f|--force]} ]]
			then
				ignored_files_alternatives=('ignored-modified-files:ignored modified files:__git_ignore_line_inside_arguments __git_modified_files --ignored' 'ignored-other-files:ignored other files:__git_ignore_line_inside_arguments __git_other_files --ignored') 
			fi
			_alternative 'modified-files::__git_ignore_line_inside_arguments __git_modified_files' 'other-files::__git_ignore_line_inside_arguments __git_other_files' $ignored_files_alternatives && ret=0  ;;
	esac
	return ret
}
_git-am () {
	local -a apply_options
	__git_setup_apply_options
	_arguments -S '(-s --signoff)'{-s,--signoff}'[add Signed-off-by: line to the commit message]' '(-k --keep)'{-k,--keep}'[pass -k to git mailinfo]' '(          --no-keep-cr)--keep-cr[pass --keep-cr to git mailsplit]' '(--keep-cr             )--no-keep-cr[do not pass --keep-cr to git mailsplit]' '(-c --scissors --no-scissors)'{-c,--scissors}'[strip everything before a scissors line]' '(-c --scissors --no-scissors)--no-scissors[ignore scissors lines]' '(-q --quiet)'{-q,--quiet}'[only print error messages]' '(-u --utf8 --no-utf8)'{-u,--utf8}'[pass -u to git mailinfo]' '(-u --utf8 --no-utf8)--no-utf8[pass -n to git mailinfo]' '(-3 --3way)'{-3,--3way}'[use 3-way merge if patch does not apply cleanly]' $apply_options '(-i --interactive)'{-i,--interactive}'[apply patches interactively]' '--committer-date-is-author-date[use author date as committer date]' '--ignore-date[use committer date as author date]' '--skip[skip the current patch]' '(--continue -r --resolved)'{--continue,-r,--resolved}'[continue after resolving patch failure by hand]' '--abort[restore the original branch and abort the patching operation]' '--patch-format=-[specify format patches are in]:patch format:((mbox\:"mbox format"
                                                                    stgit-series\:"StGit patch series"
                                                                    stgit\:"stgit format"))' '*:mbox file:_files'
}
_git-apply () {
	local -a apply_options
	__git_setup_apply_options
	_arguments -w -S -s $apply_options '--stat[output diffstat for input (turns off "apply")]' '--numstat[same as --stat but in decimal notation and complete pathnames (turns off "apply")]' '--summary[output summary of git-diff extended headers (turns off "apply")]' '--check[check if patches are applicable (turns off "apply")]' '(        --cached)--index[make sure that patch is applicable to index]' '(--index         )--cached[apply patches without touching working tree]' '--build-face-ancestor[build temporary index for blobs with ambiguous origin]:index:_files' '(-R --reverse)'{-R,--reverse}'[apply patches in reverse]' '-z[use NUL termination on output]' '--unidiff-zero[disable unified-diff-context check]' '--apply[apply patches that would otherwise not be applied]' '--no-add[ignore additions made by the patch]' '*--exclude=[skip files matching specified pattern]:pattern' '*--include=[include files matching specified pattern]:pattern' '--inaccurate-eof[work around missing-new-line-at-EOF bugs]' '(-v --verbose)'{-v,--verbose}'[display progress on stderr]' '--recount[do not trust line counts in hunk headers]' '*:patch:_files'
}
_git-applymbox () {
	_arguments -A '-*' '-k[do not modify "Subject:" header]' '-m[apply patches with "git-apply" and fail if patch is unclean]' '-q[apply patches interactively]' '-u[encode commit information in UTF-8]' '(1)-c[restart command after fixing an unclean patch]:patch:_files -g ".dotest/0*"' ':mbox file:_files' '::signoff file:__git_signoff_file'
}
_git-archimport () {
	_arguments '-h[display usage]' '-v[verbose output]' '-T[create tag for every commit]' '-f[use fast patchset import strategy]' '-o[use old-style branch names]' '-D[attempt to import trees that have been merged from]: :__git_guard_number depth' '-a[auto-register archives at http://mirrors.sourcecontrol.net]' '-t[use given directory as temporary directory]: :_directories' '*:archive/branch'
}
_git-archive () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	declare -a backend_args
	if (( words[(I)--format=*] > 0 && words[(I)--format=*] < CURRENT ))
	then
		case ${words[$words[(I)--format=*]]#--format=} in
			(zip) backend_args=('-0[do not deflate files]' '-1[minimum compression]' '-2[a little more compression]' '-3[slightly more compression]' '-4[a bit more compression]' '-5[even more compression]' '-6[slightly even more compression]' '-7[getting there]' '-8[close to maximum compression]' '-9[maximum compression]')  ;;
		esac
	fi
	_arguments -w -C -S -s '--format=-[format of the resulting archive]:archive format:__git_archive_formats' '(- :)'{-l,--list}'[list available archive formats]' '(-v --verbose)'{-v,--verbose}'[report progress to stderr]' '--prefix=-[prepend the given path prefix to each filename]:path prefix:_directories -r ""' '--output=[write archive to argument instead of stdout]:archive:_files' '--worktree-attributes[look for attributes in .gitattributes in working directory too]' $backend_args '--remote=[archive remote repository]:remote repository:__git_any_repositories' '--exec=[path to git-receive-pack on remote]:remote path:_files' ': :__git_tree_ishs' '*: :->file' && ret=0 
	case $state in
		(file) __git_tree_files ${PREFIX:-.} $line[1] && ret=0  ;;
	esac
	return ret
}
_git-bisect () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C '--help[display git-bisect manual page]' ': :->command' '*:: :->option-or-argument' && ret=0 
	case $state in
		(command) declare -a commands
			commands=(help:'display a short usage description' start:'reset bisection state and start a new bisection' bad:'mark current or given revision as bad' good:'mark current or given revision as good' skip:'choose a nearby commit' next:'find next bisection to test and check it out' reset:'finish bisection search and return to the given branch (or master)' visualize:'show the remaining revisions in gitk' view:'show the remaining revisions in gitk' replay:'replay a bisection log' log:'show the log of the current bisection' run:'run evaluation script') 
			_describe -t commands command commands && ret=0  ;;
		(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
			case $line[1] in
				(start) _arguments -C ':bad revision:__git_commits' '*: :->revision-or-path' && ret=0 
					case $state in
						(revision-or-path) if compset -N '--' || ! __git_is_committish $line[CURRENT-1]
							then
								__git_cached_files && ret=0 
							else
								_alternative 'revisions::__git_revisions' 'files::__git_cached_files' && ret=0 
							fi ;;
					esac ;;
				(bad) _arguments ': :__git_commits' && ret=0  ;;
				(good|skip) _arguments '*: :__git_commits' && ret=0  ;;
				(replay) _arguments ':log file:_files' && ret=0  ;;
				(reset) _arguments ': :__git_heads' && ret=0  ;;
				(run) _arguments '*:: : _normal' && ret=0  ;;
				(view|visualize) local -a log_options revision_options
					__git_setup_log_options
					__git_setup_revision_options
					_arguments -w -C -s $log_options $revision_options && ret=0 
					(
						*
					)
					_nothing ;;
			esac ;;
	esac
	return ret
}
_git-blame () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	declare -a revision_options
	__git_setup_revision_options
	_arguments -w -C -S -s '-b[show blank SHA-1 for boundary commits]' '--root[do not treat root commits as boundaries]' '--show-stats[include additional statistics at the end of blame output]' '-L[annotate only the given line range]: :->line-range' '-l[show long rev]' '-t[show raw timestamp]' '-S[use revs from revs-file]:revs-file:_files' '--reverse[walk histor forward instead of backward]' '(-p --porcelain)'{-p,--porcelain}'[show results designed for machine processing]' '--incremental[show results incrementally for machine processing]' '--contents[annotate against the given file if no rev is specified]: :_files' '(-h --help)'{-h,--help}'[show help message]' '-c[use same output format as git annotate]' '--score-debug[output debugging information relating to -C and -M line movement]' '(-f --show-name)'{-f,--show-name}'[show the filename of the original commit]' '(-n --show-number)'{-n,--show-number}'[show the line number in the original commit]' '-s[suppress author name and timestamp]' '-w[ignore whitespace when finding lines]' $revision_options ': :__git_cached_files' ':: :__git_revisions' && ret=0 
	case $state in
		(line-range) if compset -P '([[:digit:]]#|/[^/]#(\\?[^/]#)#/),'
			then
				_alternative 'line-numbers::__git_guard_number "line number"' 'regexes::_guard "(/[^/]#(\\?[^/]#)#(/|)|)" regex' 'offsets::_guard "([+-][[:digit:]]#|)" "line offset"' && ret=0 
			else
				_alternative 'line-numbers::__git_guard_number "line number"' 'regexes::_guard "(/[^/]#(\\?[^/]#)#(/|)|)" regex' && ret=0 
			fi ;;
	esac
	return ret
}
_git-branch () {
	# undefined
	builtin autoload -XUz
}
_git-buildpackage () {
	# undefined
	builtin autoload -XUz
}
_git-bundle () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C ': :->command' '*:: :->option-or-argument' && ret=0 
	case $state in
		(command) declare -a commands
			commands=('create:create a bundle' 'verify:check that a bundle is valid and will apply cleanly' 'list-heads:list references defined in bundle' 'unbundle:unbundle a bundle to repository') 
			_describe -t commands command commands && ret=0  ;;
		(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
			case $line[1] in
				(create) if (( CURRENT == 2 ))
					then
						_arguments ':bundle:_files' && ret=0 
					else
						local revision_options
						__git_setup_revision_options
						_arguments -w -S -s $revision_options ': :_files' '*: :__git_commit_ranges2' && ret=0 
					fi ;;
				(verify) _arguments ':bundle:_files' && ret=0  ;;
				(list-heads|unbundle) _arguments '*: :__git_ref_specs' && ret=0  ;;
			esac ;;
	esac
	return ret
}
_git-cat-file () {
	_arguments -w -S -s '(- 1)-t[show type of given object]' '(- 1)-s[show size of given object]' '(- 1)-e[exit with zero status if object exists]' '(- 1)-p[pretty-print given object]' '(- 1)--textconv[show content as transformed by a textconv filter]' '(- :)--batch[print SHA1, type, size, and contents of each object provided on stdin]' '(- :)--batch-check[print SHA1, type, and size of each object provided on stdin]' '(-):object type:(blob commit tag tree)' ': :__git_objects'
}
_git-check-attr () {
	local z_opt=
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	if (( words[(I)--stdin] ))
	then
		z_opt='-z[paths are separated with NUL character when reading from stdin]' 
	fi
	_arguments -C '--stdin[read file names from stdin instead of from command line]' $z_opt '(-)--[interpret preceding arguments as attributes and following arguments as path names]' '*:: :->attribute-or-file' && ret=0 
	case $state in
		(attribute-or-file) local -a attributes
			attributes=(crlf ident filter diff merge) 
			local only_attributes=1
			for ((i = 2; i < $#words; i++ )) do
				if (( attributes[(I)$words[i]] == 0 ))
				then
					only_attributes=0 
					break
				fi
			done
			if (( !only_attributes )) || [[ -n ${opt_args[(I)--]} ]]
			then
				__git_cached_files && ret=0 
			else
				_alternative 'attributes::__git_attributes' 'files::__git_cached_files' && ret=0 
			fi ;;
	esac
	return ret
}
_git-check-ref-format () {
	_arguments '-h[display usage information]' '--print[display canonicalized name of hypothetical reference of given name]' '--branch[expand previous branch syntax]' ': :__git_references'
}
_git-checkout () {
	local new_branch_reflog_opt
	if (( words[(I)-b|-B] ))
	then
		new_branch_reflog_opt="(--patch)-l[create the new branch's reflog]" 
	fi
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -s '(-q --quiet)'{-q,--quiet}'[suppress feedback messages]' '(-f --force -m --merge --conflict --patch)'{-f,--force}'[force branch switch/ignore unmerged entries]' '(-q --quiet        --theirs --patch)--ours[check out stage #2 for unmerged paths]' '(-q --quiet --ours          --patch)--theirs[check out stage #3 for unmerged paths]' '(   -B --orphan --ours --theirs --conflict --patch)-b[create a new branch based at given commit]: :__git_branch_names' '(-b    --orphan --ours --theirs --conflict --patch)-B[create or update branch based at given commit]: :__git_branch_names' '(-t --track --orphan --patch)'{-t,--track}'[set up configuration so pull merges from the base commit]' '(--patch)--no-track[override the branch.autosetupmerge configuration variable]' $new_branch_reflog_opt '(-b -B -t --track --patch)--orphan[create a new orphan branch based at given commit]: :__git_branch_names' '(-q --quiet -f --force -m --merge --conflict --patch)'{-m,--merge}'[3way merge current branch, working tree and new branch]' '(-q --quiet -f --force -m --merge --patch)--conflict[same as --merge, using given merge style]:style:(merge diff3)' '(-)'{-p,--patch}'[interactively select hunks in diff between given tree-ish and working tree]' '(-)--[start file arguments]' '*:: :->branch-or-tree-ish-or-file' && ret=0 
	case $state in
		(branch-or-tree-ish-or-file) [[ $line[CURRENT] = -* ]] && return
			if (( CURRENT == 1 )) && [[ -z $opt_args[(I)--] ]]
			then
				local branch_arg='branches::__git_revisions' tree_ish_arg='tree-ishs::__git_tree_ishs' file_arg='modified-files::__git_modified_files'
				if [[ -n ${opt_args[(I)-b|-B|--orphan]} ]]
				then
					tree_ish_arg= 
					file_arg= 
				elif [[ -n $opt_args[(I)--track] ]]
				then
					branch_arg='remote-branches::__git_remote_branch_names' 
					tree_ish_arg= 
					file_arg= 
				elif [[ -n ${opt_args[(I)--ours|--theirs|-m|--conflict|--patch]} ]]
				then
					branch_arg= 
				fi
				_alternative $branch_arg $tree_ish_arg $file_arg && ret=0 
			elif [[ -n ${opt_args[(I)-b|-B|-t|--track|--orphan]} ]]
			then
				_nothing
			elif [[ -n $line[1] ]] && __git_is_treeish $line[1]
			then
				__git_ignore_line __git_tree_files ${PREFIX:-.} $line[1] && ret=0 
			else
				__git_ignore_line __git_modified_files && ret=0 
			fi ;;
	esac
	return ret
}
_git-checkout-index () {
	local z_opt=
	if (( words[(I)--stdin] ))
	then
		z_opt='-z[paths are separated with NUL character when reading from standard input]' 
	fi
	_arguments -w -S -s '(-u --index)'{-u,--index}'[update stat information in index]' '(-q --quiet)'{-q,--quiet}'[do not complain about existing files or missing files]' '(-f --force)'{-f,--force}'[force overwrite of existing files]' '(-a --all --stdin *)'{-a,--all}'[check out all files in index]' '(-n --no-create)'{-n,--no-create}'[do not checkout new files]' '--prefix=-[prefix to use when creating files]:directory:_directories' '--stage=-[check out files from named stage]:stage:(1 2 3 all)' '--temp[write content to temporary files]' '(-a --all *)--stdin[read list of paths from the standard input]' $z_opt '*: :__git_cached_files'
}
_git-cherry () {
	_arguments '(-v --verbose)'{-v,--verbose}'[output additional information]' '--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' ':upstream commit:__git_commits' '::head commit:__git_commits' '::limit commit:__git_commits'
}
_git-cherry-pick () {
	_arguments '(-e --edit --ff)'{-e,--edit}'[edit commit before committing the revert]' '(--ff)-x[append information about what commit was cherry-picked]' '(-m --mainline)'{-m,--mainline}'[specify mainline when cherry-picking a merge commit]:parent number' '(-n --no-commit --ff)'{-n,--no-commit}'[do not make the actually commit]' '(-s --signoff --ff)'{-s,--signoff}'[add Signed-off-by line at the end of the commit message]' '(-e --edit -x -n --no-commit -s --signoff)--ff[fast forward, if possible]' ': :__git_revisions'
}
_git-citool () {
	_nothing
}
_git-clean () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '-d[also remove untracked directories]' '(-f --force)'{-f,--force}'[required when clean.requireForce is true (default)]' '(-n --dry-run)'{-n,--dry-run}'[only show what would and what would not be removed]' '(-q --quiet)'{-q,--quiet}'[only report errors]' '*'{-e,--exclude=}'[skip files matching specified pattern]:pattern' '(-X   )-x[also remove ignored files]' '(   -x)-X[remove only ignored files]' '*: :->file' && ret=0 
	case $state in
		(file) local exclusion ignored_other_files_alt other_files_alt
			declare -a exclusions
			for spec in $opt_args[-e] $opt_args[--exclude]
			do
				integer i
				for ((i = 1; i <= $#spec; i++ )) do
					case $spec[i] in
						(\\) if (( i + 1 <=  $#spec )) && [[ $spec[i+1] = : ]]
							then
								(( i++ ))
								exclusion+=: 
							else
								exclusion+=$spec[i] 
							fi ;;
						(:) exclusions+=(-x $exclusion) exclusion=  ;;
						(*) exclusion+=$spec[i]  ;;
					esac
				done
			done
			[[ -n $exclusion ]] && exclusions+=(-x $exclusion) 
			if [[ -n ${opt_args[(I)-x|-X]} ]]
			then
				ignored_other_files_alt="ignored-untracked-files::__git_ignored_other_files $exclusions" 
			fi
			if [[ -z ${opt_args[(I)-X]} ]]
			then
				other_files_alt="untracked-files::__git_other_files $exclusions" 
			fi
			_alternative $ignored_other_files_alt $other_files_alt && ret=0  ;;
	esac
	return ret
}
_git-clone () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '(-l --local)'{-l,--local}'[clone locally, hardlink refs and objects if possible]' '--no-hardlinks[copy files instead of hardlinking when doing a local clone]' '(-s --shared)'{-s,--shared}'[share the objects with the source repository (warning: see man page)]' '--reference[reference repository]:repository:_directories' '(-q --quiet)'{-q,--quiet}'[operate quietly]' '(-v --verbose)'{-v,--verbose}'[always display the progressbar]' '--progress[output progress even if stderr is not a terminal]' '(-n --no-checkout)'{-n,--no-checkout}'[do not checkout HEAD after clone is complete]' '(-o --origin)--bare[make a bare GIT repository]' '(--bare)--mirror[clone refs into refs/* instead of refs/remotes/origin/*]' '(-o --origin --bare)'{-o,--origin}'[use given remote name instead of "origin"]: :__git_guard_branch-name' '(-b --branch)'{-b,--branch}'[point HEAD to the given branch]: :__git_guard_branch-name' '(-u --upload-pack)'{-u,--upload-pack=}'[specify path to git-upload-pack on remote side]:remote path' '--template=[directory to use as a template for the object database]: :_directories' '--depth[create a shallow clone, given number of revisions deep]: :__git_guard_number depth' '--recursive[initialize all contained submodules]' ': :->repository' ': :_directories' && ret=0 
	case $state in
		(repository) if [[ -n ${opt_args[(I)-l|--local|--no-hardlinks|-s|--shared|--reference]} ]]
			then
				__git_local_repositories && ret=0 
			else
				__git_any_repositories && ret=0 
			fi ;;
	esac
	return ret
}
_git-commit () {
	local amend_opt='--amend[amend the tip of the current branch]'
	if __git_is_initial_commit || __git_is_in_middle_of_merge
	then
		amend_opt= 
	fi
	local reset_author_opt=
	if (( words[(I)-C|--reuse-message(=*|)|-c|--reedit-message(=*|)|--amend] ))
	then
		reset_author_opt='(--author)--reset-author[make committer the author of the commit]' 
	fi
	_arguments -w -S -s '(-a --all --interactive -o --only -i --include *)'{-a,--all}'[stage all modified and deleted paths]' $reset_author_opt '(        --porcelain --dry-run)--short[output dry run in short format]' '(--short             --dry-run)--porcelain[output dry run in porcelain-ready format]' '(--short --porcelain --dry-run -z --null)'{-z,--null}'[separate dry run entry output with NUL]' '(--reset-author)--author[override the author name used in the commit]:author name' '--date=[override the author date used in the commit]:date' '(-s --signoff)'{-s,--signoff}'[add Signed-off-by line at the end of the commit message]' '(-n --no-verify)'{-n,--no-verify}'[do not look for suspicious lines the commit introduces]' '--allow-empty[allow recording an empty commit]' '--allow-empty-message[allow recording a commit with an empty message]' '--cleanup=[specify how the commit message should be cleaned up]:mode:((verbatim\:"don'\''t change the commit message at all"
                                                                            whitespace\:"remove leading and trailing whitespace lines"
                                                                            strip\:"remove both whitespace and commentary lines"
                                                                            default\:"act as '\''strip'\'' if the message is to be edited and as '\''whitespace'\'' otherwise"))' '(-e --edit)'{-e,--edit}'[edit the commit message before committing]' '(-a --all --interactive -o --only -i --include)'{-i,--include}'[update the given files and commit the whole index]' '(-a --all --interactive -o --only -i --include)'{-o,--only}'[commit only the given files]' '(-u --untracked-files)'{-u-,--untracked-files=}'[show files in untracked directories]::mode:((no\:"show no untracked files"
                                                                                                  normal\:"show untracked files and directories"
                                                                                                  all\:"show individual files in untracked directories"))' '(-q --quiet -v --verbose)'{-v,--verbose}'[show unified diff of all file changes]' '(-q --quiet -v --verbose)'{-q,--quiet}'[suppress commit summary message]' '--dry-run[only show list of paths that are to be commited or not, and any untracked]' '(         --no-status)--status[include the output of git status in the commit message template]' '(--status            )--no-status[do not include the output of git status in the commit message template]' '(-a --all --interactive -o --only -i --include *)--interactive[interactively update paths in the index file]' '*: :__git_ignore_line_inside_arguments __git_changed_files' - '(message)' {-C,--reuse-message=}'[use existing commit object with same log message]: :__git_commits' {-c,--reedit-message=}'[use existing commit object and edit log message]: :__git_commits' {-F,--file=}'[read commit message from given file]: :_files' {-m,--message=}'[use the given message as the commit message]:message' {-t,--template=}'[use file as a template commit message]:template:_files' $amend_opt
}
_git-commit-tree () {
	if (( CURRENT == 2 ))
	then
		_arguments '-h[display usage]' ': :__git_trees'
	elif [[ $words[CURRENT-1] = -p ]]
	then
		local expl
		_description commits expl 'parent commit'
		__git_objects $expl
	else
		compadd - '-p'
	fi
}
_git-config () {
	local name_arg value_arg
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	if (( words[(I)--get-regexp] ))
	then
		name_arg=':name regex' 
	elif (( words[(I)--get-colorbool] ))
	then
		name_arg=':: :->is-a-tty' 
	elif (( words[(I)--get-color] ))
	then
		name_arg='::default' 
	elif (( words[(I)--remove-section|--rename-section] ))
	then
		name_arg=': :->section' 
	elif (( words[(I)--get|--get-all] ))
	then
		name_arg=': :->gettable-option' 
	else
		name_arg=': :->option' 
	fi
	if (( words[(I)--rename-section] ))
	then
		value_arg=': :->section' 
	else
		value_arg=': :->value' 
	fi
	_arguments -w -C -S -s '(         --system --local -f --file)--global[use user-global config file]' '(--global          --local -f --file)--system[use system-wide config file]' '(--global --system         -f --file)--local[use local config file]' '(--global --system -f --file)'{-f+,--file=}'[use given config file]:config file:_files' '(       --int --bool-or-int --path)--bool[setting is a boolean]' '(--bool       --bool-or-int --path)--int[setting is an integer]' '(--bool --int               --path)--bool-or-int[setting is an integer]' '(--bool --int --bool-or-int       )--path[setting is a path]' '(-z --null)'{-z,--null}'[end values with NUL and newline between key and value]' $name_arg $value_arg '::value regex' - '(actions)' '(-z --null)--replace-all[replace all values of the given key]' '(3 -z --null)--add[add new value without altering any existing ones]' '(2)--get[get the first matching value of the key]' '(2)--get-all[get all matching values of the key]' '(3 --bool --int --bool-or-int --path -z --null)--remove-section[remove the given section]' '(3 --bool --int --bool-or-int --path -z --null)--rename-section[rename the given section]' '(2 --bool --int --bool-or-int --path -z --null)--unset[remove the first matching value of the key]' '(2 --bool --int --bool-or-int --path -z --null)--unset-all[remove all matching values of the key]' '(: --bool --int --bool-or-int --path)'{-l,--list}'[list all variables set in config file]' '(2)--get-regexp[like "--get-all", but interpret "name" as a regular expression]' '(2 3 --bool --int --bool-or-int --path -z --null)--get-colorbool[check if color should be used]: :->gettable-colorbool-option' '(2 3 --bool --int --bool-or-int --path -z --null)--get-color[find color setting]: :->gettable-color-option' '(-e --edit --bool --int --bool-or-int --path -z --null)'{-e,--edit}'[open config file for editing]' && ret=0 
	declare -a git_options_static
	git_options_static=(advice.pushNonFastForward:'show advice when git push refuses non-fast-forward refs::->bool:true' advice.statusHints:'show advice in output of git status::->bool:true' advice.commitBeforeMerge:'show advice when git merge refuses to merge::->bool:true' advice.resolveConflict:'show advice when conflict prevents operation from being performed::->bool:true' advice.implicitIdentity:'show advice when identity is guessed from system settings::->bool:true' advice.detachedHead:'show advice when entering detached-HEAD state::->bool:true' blame.blankboundary:'show blank SHA-1 for boundary commits::->bool:false' blame.showroot:'show root commits as normal commits::->bool:false' blame.date:'date format to use in output::__git_date_formats:iso' core.fileMode:'track changes to the executable bit of files::->bool:true' core.ignoreCygwinFSTricks:'use Cygwin stat()/lstat()::->bool:true' core.ignorecase:'use workarounds for non-case-sensitive filesystems::->bool:false' core.trustctime:'trust inode change time::->bool:true' core.quotepath:'escape characters in paths on output::->bool:false' core.eol:'line ending type::->core.eol:native' core.safecrlf:'verify that CRLF conversion is reversible::->core.safecrlf:false' core.autocrlf:'convert CRLFs to and from system specific::->core.autocrlf:false' core.symlinks:'create symbolic links for indexed symbolic links upon creation::->bool:true' core.gitProxy:'command to execute to establish a connection to remote server:proxy command:_path_commands' core.ignoreStat:'ignore modification times of files::->bool:false' core.preferSymlinkRefs:'use symbolic links for symbolic-reference files::->bool:false' core.bare:'use a repository without a working tree::->bool:false' core.worktree:'path to the root of the work tree:work tree:_directories' core.logAllRefUpdates:'log updates of references::->bool:true' core.repositoryFormatVersion:'internal variable determining the repository version:version:->string' core.sharedRepository:'what kind of sharing is done for this repository::->permission:false' core.warnAmbiguousRefs:'warn if a ref name is ambiguous::->bool:true' core.compression:'level of compression to apply to packs::->compression:-1' core.loosecompression:'level of compression to apply to non-pack files::->compression:1' core.packedGitWindowSize:'size of mappings of pack files:pack window size:->bytes' core.packedGitLimit:'maximum number of bytes to map from pack files:maximum pack file map size:->bytes' core.deltaBaseCacheLimit:'maximum size of cache for base objects:maximum base objects cache size:->bytes:16m' core.bigFileThreshold:'maximum size of files to compress:maximum compress size:->bytes:512m' core.excludesfile:'additional file to use for exclusion:excludes file:_files' core.askpass:'program to use for asking for passwords:password command:_path_commands' core.editor:'editor to use for editing messages:editor:_path_commands' core.pager:'pager to use for paginating output:pager:_path_commands' core.whitespace:'list of common whitespace problems to notice::->core.whitespace' core.fsyncobjectfiles:'fsync() when writing object files::->bool:false' core.preloadindex:'use parallel index preload for operations like git diff::->bool:false' core.createObject:'take steps to prevent overwriting existing objects::->core.createObject:link' core.notesRef:'show notes in given refs:refs:->string:refs/notes/commits' core.sparseCheckout:'use sparse checkout::->bool:false' add.ignore-errors:'ignore indexing errors when adding files::->bool:false' am.keepcr:'keep CR characters when splitting mails::->bool:false' apply.ignorewhitespace:'ignore whitespace changes::->apply.ignorewhitespace:no' apply.whitespace:'default value for the --whitespace option::->apply.whitespace:error' branch.autosetupmerge:'set up new branches for git pull::->bool:true' branch.autosetuprebase:'rebase new branches of merge for autosetupmerge::->branch.autosetuprebase:never' 'branch.*.remote:what remote git fetch and git push should fetch form/push to::__git_remotes' 'branch.*.merge:default refspec to be marked for merging::__git_ref_specs' 'branch.*.mergeoptions:default options for merging::->branch.mergeoptions' 'branch.*.rebase:rebase on top of fetched branch::->bool:false' 'browser.*.cmd:browser command to use:browser:_path_commands' 'browser.*.path:path to use for the browser:absolute browser path:_files -g "*(*)"' clean.requireForce:'require --force for git clean to actually do something::->bool:true' color.branch:'color output of git branch::->color-bool' color.branch.current:'color of the current branch::->color' color.branch.local:'color of a local branch::->color' color.branch.remote:'color of a remote branch::->color' color.branch.plain:'color of other branches::->color' color.diff:'color output of git diff::->color-bool' color.diff.plain:'color of context text::->color' color.diff.meta:'color of meta-information::->color' color.diff.frag:'color of hunk headers::->color' color.diff.func:'color of function in hunk header::->color' color.diff.old:'color of removed lines::->color' color.diff.new:'color of added lines::->color' color.diff.commit:'color of commit headers::->color' color.diff.whitespace:'color of whitespace errors::->color' color.decorate.branch:'color of branches::->color' color.decorate.remoteBranch:'color of remote branches::->color' color.decorate.tag:'color of tags::->color' color.decorate.stash:'color of stashes::->color' color.decorate.HEAD:'color of HEAD::->color' color.grep:'whether or not to color output of git grep::->color-bool' color.grep.context:'color of non-matching text in context lines::->color' color.grep.filename:'color of filename prefix::->color' color.grep.function:'color of function name lines::->color' color.grep.linenumber:'color of line number prefix::->color' color.grep.match:'color of matching text::->color' color.grep.selected:'color of non-matching text in selected lines::->color' color.grep.separator:'color of separators between fields in a line::->color' color.interactive:'whether or not to color in interactive mode::->color-bool' color.interactive.prompt:'color of prompt::->color' color.interactive.header:'color of header::->color' color.interactive.help:'color of help::->color' color.interactive.error:'color of error::->color' color.pager:'feed colored output to pager::->bool:true' color.showbranch:'color output of git show-branch::->color-bool' color.status:'color output of git status::->color-bool' color.status.header:'color of header text::->color' color.status.added:'color of added, but not yet committed, files::->color' color.status.updated:'color of updated, but not yet committed, files::->color' color.status.changed:'color of changed, but not yet added in the index, files::->color' color.status.untracked:'color of files not currently being tracked::->color' color.status.nobranch:'color of no-branch warning::->color' color.ui:'color output of capable git commands::->color-bool' commit.status:'include status information in commit message template::->bool:true' commit.template:'template file for commit messages:template:_files' diff.autorefreshindex:'run git update-index --refresh before git diff::->bool:true' diff.external:'command to generate diff with:diff command:_path_commands' diff.mnemonicprefix:'use mnemonic source and destination prefixes::->bool:false' diff.noprefix:'strip source and destination prefixes::->bool:false' diff.renameLimit:'number of files to consider when detecting copy/renames:rename limit:->int' diff.renames:'try to detect renames::->diff.renames:true' diff.ignoreSubmodules:'ignore submodules::->bool:false' diff.suppressBlankEmpty:'inbihit printing space before empty output lines::->bool:false' diff.tool:'diff tool to use::__git_difftools' 'difftool.*.cmd:command to invoke for the diff tool::_path_commands' 'difftool.*.path:path to use for the diff tool:absolute diff tool path:_files -g "*(*)"' difftool.prompt:'prompt before each invocation of the diff tool::->bool:true' diff.wordRegex:'regex used to determine what a word is when performing word-by-word diff:regex:->string' diff.guitool:'diff tool with gui to use::__git_difftools' fetch.unpackLimit:'maximum number of objects to unpack when fetching:unpack limit:->int' format.attach:'use multipart/mixed attachments::->bool:false' format.numbered:'use sequence numbers in patch subjects::->format.numbered:auto' format.headers:'additional email headers to include in email patches:headers:->string' format.to:'additional email recipients of patches::->string' format.cc:'additional carbon-copy email recipients of patches:recipients:->string' format.subjectprefix:'prefix to use for subjects:prefix:->string' format.signature:'signature to use:signature:->string' format.suffix:'default suffix for output files from git-format-patch:suffix:->string' format.pretty:'pretty format for log/show/whatchanged:format:->string' format.thread:'threading style to use::->format.thread:false' format.signoff:'enable --signoff by default::->bool:false' 'gc.*.reflogexpire:grace period for git reflog expire::->days:90' 'gc.*.reflogexpireunreachable:grace period for git reflog expire for unreachable entries::->days:30' gc.aggressiveWindow:'window size used in delta compression algorithm:->int:250' gc.auto:'minimum limit for packing loose objects with --auto::->int:6700' gc.autopacklimit:'minimum limit for packing packs with --auto::->int:50' gc.packrefs:'allow git gc to run git pack-refs::->gc.packrefs:true' gc.pruneexpire:'grace period for pruning::->days+now' gc.reflogexpire:'grace period for git reflog expire::->days:90' gc.reflogexpireunreachable:'grace period for git reflog expire for unreachable entries::->days:30' gc.rerereresolved:'number of days to keep records of resolved merges::->days:60' gc.rerereunresolved:'number of days to keep records of unresolved merges::->days:15' gitcvs.commitmsgannotation:'string to append to each commit message::->string' gitcvs.enabled:'enable the cvs server interface::->bool:false' gitcvs.logfile:'name of log file for cvs pserver:log file:_files' gitcvs.dbname:'name of database to use:database name:->string' gitcvs.dbdriver:'name of DBI driver to use::->gitcvs.dbdriver:SQLite' gitcvs.dbuser:'username to connect to database as:database user:_users' gitcvs.dbpass:'password to use when connecting to database:password:->string' gitcvs.dbTableNamePrefix:'database table name prefix:prefix:->string' 'gitcvs.*.commitmsgannotation:string to append to each commit message:annotation:->string' 'gitcvs.*.enabled:enable the cvs server interface::->bool:false' 'gitcvs.*.logfile:name of log file for cvs pserver:log file:_files' 'gitcvs.*.dbname:name of database to use:database name:->string' 'gitcvs.*.dbdriver:name of DBI driver to use:DBI driver:->string' 'gitcvs.*.dbuser:username to connect to database as::_users' 'gitcvs.*.dbpass:password to use when connecting to database:password:->string' 'gitcvs.*.dbTableNamePrefix:database table name prefix:prefix:->string' gitcvs.usecrlfattr:'use end-of-line conversion attributes::->bool:false' gitcvs.allbinary:'treat all files from CVS as binary::->bool:false' gui.commitmsgwidth:'width of commit message window:width:->int:75' gui.diffcontext:'number of context lines used in diff window:context:->int:5' gui.encoding:'encoding to use for displaying file contents::->encoding' gui.matchtrackingbranch:'create branches that track remote branches::->bool:false' gui.newbranchtemplate:'suggested name for new branches:template:->string' gui.pruneduringfetch:'prune tracking branches when performing a fetch::->bool:false' gui.trustmtime:'trust file modification timestamp::->bool:false' gui.spellingdictionary:'dictionary to use for spell checking commit messages:dictionary:_files' gui.fastcopyblame:'try harder during blame detection::->bool:false' gui.copyblamethreshold:'threshold to use in blame location detection:threshold:->string' gui.blamehistoryctx:'specify radius of history context in days for selected commit::->days' guitool.cmd:'shell command line to execute::_path_commands' guitool.needsfile:'require that a diff is selected for command to be available::->bool:false' guitool.noconsole:'suppress command output::->bool:false' guitool.norescan:'skip rescanning for changes to the working directory::->bool:false' guitool.confirm:'show a confirmation dialog::->bool:false' guitool.argprompt:'prompt for arguments:argument prompt:->string' guitool.revprompt:'prompt for a single revision:revision prompt:->string' guitool.revunmerged:'show only unmerged branches in revprompt::->bool:false' guitool.title:'title of prompt dialog:prompt title:->string' guitool.prompt:'prompt to display:prompt:->string' help.browser:'browser used to display help in web format::__git_browsers' help.format:'default help format used by git help::->help.format' help.autocorrect:'execute corrected mistyped commands::->bool:false' http.proxy:'HTTP proxy to use:proxy:_urls' http.sslVerify:'verify the SSL certificate for HTTPS::->bool:true' http.sslCert:'file containing SSL certificates for HTTPS:SSL certificate file:_files' http.sslKey:'file containing the SSL private key for HTTPS:SSL private key file:_files' http.sslCertPasswordProtected:'prompt for a password for the SSL certificate::->bool:false' http.sslCAInfo:'file containing CA certificates to verify against for HTTPS:CA certificates file:_files' http.sslCAPath:'directory containing files with CA certificates to verify against for HTTPS:CA certificates directory:_directories' http.maxRequests:'how many HTTP requests to launch in parallel:maximum number of requests:->int:5' http.minSessions:'number of curl sessions to keep across requests:mininmum number of sessions:->int:1' http.postBuffer:'maximum size of buffer used by smart HTTP transport when POSTing:maximum POST buffer size:->bytes:1m' http.lowSpeedLimit:'lower limit for HTTP transfer-speed:low transfer-speed limit:->int' http.lowSpeedTime:'duration for http.lowSpeedLimit:time:->int' http.noEPSV:'disable the use of the EPSV ftp-command::->bool:false' http.useragent:'user agent presented to HTTP server:user agent string:->string' http.getanyfile:'allow clients to read any file within repository::->bool:true' http.uploadpack:'serve git fetch-pack and git ls-remote clients::->bool:true' http.receivepack:'serve git send-pack clients::->bool:true' i18n.commitEncoding:'character encoding commit messages are stored in::->encoding' i18n.logOutputEncoding:'character encoding commit messages are output in::->encoding' imap.folder:'IMAP folder to use with git imap-send:IMAP folder name::_mailboxes' imap.tunnel:'tunneling command to use for git imap-send:tunnel command:_path_commands' imap.host:'host git imap-send should connect to::_hosts' imap.user:'user git imap-send should log in as::_users' imap.pass:'password git imap-send should use when logging in:password:->string' imap.port:'port git imap-send should connect on::_ports' imap.sslverify:'verify server certificate::->bool:true' imap.preformattedHTML:'use HTML encoding when sending a patch::->bool:false' imap.authMethod:'authentication method used::->imap.authMethod' init.templatedir:'directory from which templates are copied:template directory:_directories' instaweb.browser:'browser to use when browsing with gitweb::__git_browsers' instaweb.httpd:'HTTP-daemon command-line to execute for instaweb:daemon:_path_commands' instaweb.local:'bind to 127.0.0.1::->bool:false' instaweb.modulepath:'module path for the Apache HTTP-daemon for instaweb:module directory:_directories' instaweb.port:'port to bind HTTP daemon to for instaweb::_ports' interactive.singlekey:'accept one-letter input without Enter::->bool:false' log.date:'default date-time mode::__git_date_formats' log.decorate:'type of ref names to show::__git_log_decorate_formats' log.showroot:'show initial commit as a diff against an empty tree::->bool:true' mailinfo.scissors:'remove everything in body before a scissors line::->bool:false' mailmap.file:'augmenting mailmap file:mailmap file:_files' man.viewer:'man viewer to use for help in man format::__git_man_viewers' 'man.*.cmd:the command to invoke the specified man viewer:man command:_path_commands' 'man.*.path:path to use for the man viewer:absolute man tool path:_files -g "*(*)"' merge.conflictstyle:'style used for conflicted hunks::->merge.conflictstyle:merge' merge.log:'include summaries of merged commits in new merge commit messsages::->bool:false' merge.renameLimit:'number of files to consider when detecting copy/renames during merge:limit:->int' merge.renormalize:'use canonical representation of files during merge::->bool:false' merge.stat:'print the diffstat between ORIG_HEAD and merge at end of merge::->bool:true' merge.tool:'tool used by git mergetool during merges::__git_mergetools' merge.verbosity:'amount of output shown by recursive merge strategy::->merge.verbosity:2' 'merge.*.name:human-readable name for custom low-level merge driver:name:->string' 'merge.*.driver:command that implements a custom low-level merge driver:merge command:_path_commands' 'merge.*.recursive:low-level merge driver to use when performing internal merge between common ancestors::__git_builtin_merge_drivers' 'mergetool.*.path:path to use for the merge tool:absolute merge tool path:_files -g "*(*)"' 'mergetool.*.cmd:command to invoke for the merge tool:merge command:_path_commands' 'mergetool.*.trustExitCode:trust the exit code of the merge tool::->bool:false' mergetool.keepBackup:'keep the original file with conflict markers::->bool:true' mergetool.keepTemporaries:'keep temporary files::->bool:false' mergetool.prompt:'prompt before each invocation of the merge tool::->bool:true' notes.displayRef:'refname to show notes from::->refname' notes.rewrite.amend:'copy notes from original to rewritten commit when running git amend::->bool:true' notes.rewrite.rebase:'copy notes from original to rewritten commit when running git rebase::->bool:true' notes.rewriteMode:'what to do when target commit already has a not when rewriting::->notes.rewriteMode' notes.rewriteRef:'refname to use when rewriting::->refname' pack.window:'size of window:window size:->int:10' pack.depth:'maximum delta depth:maximum delta depth:->int:50' pack.windowMemory:'window size limit:maximum window size:->bytes:0' pack.compression:'compression level::->compression:-1' pack.deltaCacheSize:'maximum amount of memory for caching deltas:maximum delta cache size:->bytes:256m' pack.deltaCacheLimit:'maximum size of deltas:maximum delta size:->int:1000' pack.threads:'number of threads to use for searching for best delta matches:number of threads:->int' pack.indexVersion:'default pack index version:index version:->string' pack.packSizeLimit:'maximum size of packs:maximum size of packs:->bytes' pull.octopus:'default merge strategy to use when pulling multiple branches::__git_merge_strategies' pull.twohead:'default merge strategy to use when pulling a single branch::__git_merge_strategies' push.default:'action git push should take if no refspec is given::->push.default' rebase.stat:'show a diffstat of what changed upstream since last rebase::->bool:false' rebase.autosquash:'autosquash by default::->bool:false' receive.autogc:'run git gc --auto after receiving data::->bool:true' receive.fsckObjects:'check all received objects::->bool:true' receive.unpackLimit:'maximum number of objects received for unpacking into loose objects:unpack limit:->int' receive.denyDeletes:'deny a ref update that deletes a ref::->bool:false' receive.denyDeleteCurrent:'deny a ref update that deletes currently checked out branch::->bool:false' receive.denyCurrentBranch:'deny a ref update of currently checked out branch::->receive.denyCurrentBranch' receive.denyNonFastForwards:'deny a ref update that is not a fast-forward::->bool:false' receive.updateserverinfo:'run git update-server-info after receiving data::->bool:false' 'remote.*.url:URL of a remote repository::__git_any_repositories' 'remote.*.pushurl:push URL of a remote repository::__git_any_repositories' 'remote.*.proxy:URL of proxy to use for a remote repository::_urls' 'remote.*.fetch:default set of refspecs for git fetch::__git_ref_specs' 'remote.*.push:default set of refspecs for git push::__git_ref_specs' 'remote.*.mirror:push with --mirror::->bool:false' 'remote.*.skipDefaultUpdate:skip this remote by default::->bool:false' 'remote.*.skipFetchAll:skip this remote by default::->bool:false' 'remote.*.receivepack:default program to execute on remote when pushing:git receive-pack command:_path_commands' 'remote.*.uploadpack:default program to execute on remote when fetching:git upload-pack command:_path_commands' 'remote.*.tagopt:options for retrieving remote tags::->remote.tagopt' 'remote.*.vcs:interact with the remote through git-remote helper:remote VCS:->string' repack.usedeltabaseoffset:'use delta-base offsets::->bool:true' rerere.autoupdate:'update index after resolution::->bool:false' rerere.enabled:'record resolved conflicts::->bool' sendemail.smtpencryption:'encryption method to use::->sendemail.smtpencryption' sendemail.aliasesfile:'file containing email aliases:email aliases file:_files' sendemail.aliasfiletype:'format of aliasesfile::->sendemail.aliasfiletype' sendemail.bcc:'value of Bcc\: header::_email_addresses' sendemail.cc:'value of Cc\: header::_email_addresses' sendemail.cccmd:'command to generate Cc\: header with:Cc\: command:_path_commands' sendemail.chainreplyto:'send each email as a reply to the previous one::->bool:false' sendemail.confirm:'type of confirmation required before sending::->sendemail.confirm:auto' sendemail.envelopesender:'envelope sender to send emails as::_email_addresses' sendemail.from:'sender email address::_email_addresses' sendemail.multiedit:'edit all files at once::->bool:false' sendemail.signedoffbycc:'add Signed-off-by\: or Cc\: lines to Cc\: header::->bool:true' sendemail.smtppass:'password to use for SMTP-AUTH:password:->string' sendemail.suppresscc:'rules for suppressing Cc\:::->sendemail.suppresscc' sendemail.suppressfrom:'add From\: address to the Cc\: list::->bool:false' sendemail.to:'value of To\: header::_email_addresses' sendemail.smtpdomain:'FQDN to use for HELO/EHLO commands to SMTP server:smtp domain:_domains' sendemail.smtpserver:'SMTP server to connect to:smtp host:_hosts' sendemail.smtpserverport:'port to connect to SMTP server on:smtp port:_ports' sendemail.smtpuser:'user to use for SMTP-AUTH:smtp user:_users' sendemail.thread:'set In-Reply-To\: and References\: headers::->bool:true' sendemail.validate:'perform sanity checks on patches::->bool:true' 'sendemail.*.aliasesfile:file containing email aliases::_files' 'sendemail.*.aliasfiletype:format of aliasesfile::->sendemail.aliasfiletype' 'sendemail.*.bcc:value of Bcc\: header::_email_addresses' 'sendemail.*.cc:value of Cc\: header::_email_addresses' 'sendemail.*.cccmd:command to generate Cc\: header with:Cc\: command:_path_commands' 'sendemail.*.chainreplyto:send each email as a reply to the previous one::->bool:false' 'sendemail.*.confirm:type of confirmation required before sending::->sendemail.confirm:auto' 'sendemail.*.envelopesender:envelope sender to send emails as::_email_addresses' 'sendemail.*.from:sender email address::_email_addresses' 'sendemail.*.multiedit:edit all files at once::->bool:false' 'sendemail.*.signedoffbycc:add Signed-off-by\: or Cc\: lines to Cc\: header::->bool:true' 'sendemail.*.smtppass:password to use for SMTP-AUTH:password:->string' 'sendemail.*.suppresscc:rules for suppressing Cc\:::->sendemail.suppresscc' 'sendemail.*.suppressfrom:rules for suppressing From\:::->sendemail.suppressfrom' 'sendemail.*.to:value of To\: header::_email_addresses' 'sendemail.*.smtpdomain:FQDN to use for HELO/EHLO commands to SMTP server:smtp domain:_domains' 'sendemail.*.smtpserver:SMTP server to connect to:smtp host:_hosts' 'sendemail.*.smtpserverport:port to connect to SMTP server on:smtp port:_ports' 'sendemail.*.smtpuser:user to use for SMTP-AUTH:smtp user:_users' 'sendemail.*.thread:set In-Reply-To\: and References\: headers::->bool:true' 'sendemail.*.validate:perform sanity checks on patches::->bool:true' sendemail.assume8bitEncoding:'encoding to use for non-ASCII messages::__git_encodings' showbranch.default:'default set of branches for git show-branch::->branch' status.relativePaths:'show paths relative to current directory::->bool:false' status.showUntrackedFiles:'show untracked files::->status.showUntrackedFiles:normal' status.submodulesummary:'include submodule summary::->bool:false' 'submodule.*.path:path within project:submodule directory:_directories -qS \:' 'submodule.*.url:URL to update from::__git_any_repositories' 'submodule.*.update:update strategy to use::->submodule.update' 'submodule.*.ignore:ignore modifications to submodules with git status and git diff-*::->submodule.ignore' svn.noMetadata:'disable git-svn-id: lines at end of commits::->bool:false' svn.useSvmProps:'use remappings of URLs and UUIDs from mirrors::->bool:false' svn.useSvnsyncProps:'use remappings of URLs and UUIDs for the svnsync command::->bool:false' svn.ignore-paths:'regular expression of paths to not check out:regular expression:->string' svn.brokenSymlinkWorkaround:'apply the broken-symlink check::->bool:true' svn.pathnameencoding:'encoding to recode pathnames into::->encoding' svn.followparent:'follow parent commit::->bool:true' svn.authorsFile:'default authors file:authors file:_files' svn.quiet:'produce less output::->bool:false' 'svn-remote.*.noMetadata:disable git-svn-id: lines at end of commits::->bool:false' 'svn-remote.*.useSvmProps:use remappings of URLs and UUIDs from mirrors::->bool:false' 'svn-remote.*.useSvnsyncProps:use remappings of URLs and UUIDs for the svnsync command::->bool:false' 'svn-remote.*.rewriteRoot:alternate root URL to use:root url:_urls' 'svn-remote.*.rewriteUUID:remap URLs and UUIDs for mirrors manually::->bool:false' 'svn-remote.*.ignore-paths:regular expression of paths to not check out:regular expression:->string' 'svn-remote.*.url:URL to connect to::_urls' 'svn-remote.*.fetch:fetch specification::__git_ref_specs' 'svn-remote.*.branches:branch mappings:branch mapping:->string' 'svn-remote.*.tags:tag mappings:tag mapping:->string' tar.umask:'umask to apply::->umask' transfer.unpackLimit:'default value for fetch.unpackLimit and receive.unpackLimit:unpack limit:->int:100' 'url.*.insteadOf:string to start URLs with:prefix:->string' 'url.*.pushInsteadOf:string to start URLs to push to with:prefix:->string' user.email:'email address used for commits::_email_addresses' user.name:'full name used for commits:name:->string' user.signingkey:'default GPG key to use when creating signed tags::__git_gpg_secret_keys' web.browser:'web browser to use::__git_browsers') 
	case $state in
		(section) __git_config_sections -b '(|)' '^' section-names 'section name' $* && ret=0  ;;
		(is-a-tty) declare -a values
			values=(true false auto) 
			_describe -t values 'stdout is a tty' values && ret=0  ;;
		(option) local label=option
			declare -a sections sections_and_options options
			[[ -prefix *. ]] && label="${line[1]%.*} option" 
			if compset -P '[^.]##.*.'
			then
				declare -a match mbegin mend
				options+=(${${${${(M)git_options_static:#(#i)${IPREFIX}[^.:]##:*}#(#i)${IPREFIX}}/#(#b)([^:]##:)([^\\:]#(\\?[^\\:]#)#:[^\\:]#(\\?[^\\:]#)#:->bool)/$match[1]whether or not to $match[2]}/#(#b)([^:]##:([^\\:]#(\\?[^\\:]#)#))*/$match[1]}) 
				options+=(${${${${(M)git_options_static:#(#i)${IPREFIX%%.*}.\*.[^.:]##:*}#(#i)${IPREFIX%%.*}.\*.}/#(#b)([^:]##:)([^\\:]#(\\?[^\\:]#)#:[^\\:]#(\\?[^\\:]#)#:->bool)/$match[1]whether or not to $match[2]}/#(#b)([^:]##:([^\\:]#(\\?[^\\:]#)#))*/$match[1]}) 
				declare -a labels
				labels=('branch.*.:${${line[1]#branch.}%.*} branch option' 'browser.*.:${${line[1]#browser.}%.*} browser option' 'color.branch.:branch-specific color option' 'color.diff.:diff-specific color option' 'color.decorate.:git-log---decorate-specific color option' 'color.grep.:git-grep-specific color option' 'color.interactive.:interaction-specific color option' 'color.status.:git-status-specific color option' 'difftool.*.:${${line[1]#difftool.}%.*}-specific option' 'gc.*.:${${line[1]#gc.}%.*}-specific gc option' 'gitcvs.*.:gitcvs ${${line[1]#gitcvs.}%.*}-specific option' 'guitool.*.:${${line[1]#gc.}%.*}-specific option' 'man.*.:${${line[1]#man.}%.*}-specific man option' 'merge.*.:${${line[1]#merge.}%.*}-specific merge option' 'mergetool.*.:${${line[1]#mergetool.}%.*}-specific option' 'sendemail.*.:${${line[1]#sendemail.}%.*}-specific sendemail option' 'submodule.*.:${${line[1]#submodule.}%.*}-submodule-specific option' 'url.*.:${${line[1]#url.}%.*}-specific option' 'svn-remote.*.:git-svn ${${line[1]#svn-remote.}%.*}-specific option') 
				local found
				found=${${${(M)labels:#(${IPREFIX}|${IPREFIX%%.*}.\*.):*}[1]}#*:} 
				[[ -n $found ]] && label=${(Q)"$(eval "print -rn -- $found")"} 
			elif compset -P '[^.]##.'
			then
				local opt
				declare -a match mbegin mend
				for opt in ${${${${(M)git_options_static:#(#i)${IPREFIX}[^.:]##:*}#(#i)${IPREFIX}}/#(#b)([^:]##:)([^\\:]#(\\?[^\\:]#)#:[^\\:]#(\\?[^\\:]#)#:->bool)/$match[1]whether or not to $match[2]}/#(#b)([^:]##:([^\\:]#(\\?[^\\:]#)#))*/$match[1]}
				do
					if (( ${git_options_static[(I)${opt%%:*}.*]} ))
					then
						sections_and_options+=$opt 
					else
						options+=$opt 
					fi
				done
				declare -a subsections
				subsections=('color.decorate:git log --decorate options' 'gitcvs.ext:ext-connection-method-specific options' 'gitcvs.pserver:pserver-connection-method-specific options' 'notes.rewrite:commands to copy notes from original for when rewriting commits') 
				sections+=(${${(M)subsections:#${IPREFIX}[^.:]##(.|):*}#${IPREFIX}}) 
				case $IPREFIX in
					(alias.) __git_aliases && ret=0  ;;
					(branch.) __git_branch_names -S . && ret=0  ;;
					(browser.) __git_browsers -S . && ret=0  ;;
					(difftool.) __git_difftools -S . && ret=0  ;;
					(gc.) __git_config_sections '^gc\..+\.[^.]+$' refpatterns 'ref pattern' -S . && ret=0  ;;
					(guitool.) __git_config_sections '^guitool\..+\.[^.]+$' guitools 'gui tool' -S . && ret=0  ;;
					(man.) __git_man_viewers -S . && ret=0  ;;
					(merge.) __git_merge_drivers -S . && ret=0  ;;
					(mergetool.) __git_mergetools -S . && ret=0  ;;
					(pager.) _git_commands && ret=0  ;;
					(pretty.) __git_config_sections -a '(|)' '^pretty\..+\.[^.]+$' prettys 'pretty format string' && ret=0  ;;
					(remote.) __git_remotes -S . && ret=0  ;;
					(remotes.) __git_remote-groups && ret=0  ;;
					(sendemail.) __git_sendemail_identities -S . && ret=0  ;;
					(submodule.) __git_submodules -S . && ret=0  ;;
					(url.) __git_config_sections '^url\..+\.[^.]+$' bases base -S . && ret=0  ;;
					(svn-remote.) __git_svn-remotes -S . && ret=0  ;;
				esac
			else
				sections=(advice:'options controlling advice' core:'options controlling git core' add:'git add options' alias:'command aliases' am:'git am options' apply:'git apply options' branch:'branch options' browser:'browser options' clean:'git clean options' color:'color options' commit:'git commit options' diff:'diff options' difftool:'difftools' fetch:'git fetch options' format:'format options' gc:'git gc options' gitcvs:'git-cvs options' gui:'git gui options' guitool:'git gui tool options' help:'git help options' http:'http options' i18n:'internationalization options' imap:'IMAP options' init:'git init options' instaweb:'git web options' interactive:'options controlling interactivity' log:'git log options' mailmap:'mailmap options' man:'man options' merge:'git merge options' mergetool:'mergetools' notes:'git notes options' pack:'options controlling packing' pager:'pager options' pretty:'pretty formats' pull:'git pull options' push:'git push options' rebase:'git rebase options' receive:'git receive options' remote:'remotes' remotes:'remotes groups' repack:'repack options' rerere:'git rerere options' sendemail:'git send-email options' showbranch:'showbranch options' status:'git status options' submodule:'git submodule options' tar:'git tar-tree options' transfer:'options controlling transfers' url:'URL prefixes' user:'options controlling user identity' web:'web options' svn:'git svn options' svn-remote:'git svn remotes') 
			fi
			_describe -t option-names $label sections -M 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' -S . -- sections_and_options -M 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' -qS . -- options -M 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' && ret=0  ;;
		(gettable-option) _describe -t git-options option ${${${(0)"$(_call_program gettable-options git config -z --list)"}%%$'\n'*}//:/\\:} && ret=0  ;;
		(gettable-colorbool-option) __git_config_sections -b '(|)' -a '(|)' '^color\.[^.]+$' gettable-colorbool-options option && ret=0  ;;
		(gettable-color-option) __git_config_sections -b '(|)' -a '(|)' '^color\.[^.]+\..*$' gettable-color-options option && ret=0  ;;
		(value) local current=${${(0)"$(_call_program current "git config $opt_args[(I)--system|--global|--local] ${(kv)opt_args[(I)-f|--file]} -z --get '$line[1]'")"}#*$'\n'}
			case $line[1] in
				(alias.*) if [[ -n $current ]]
					then
						compadd - $current && ret=0 
					else
						_message 'command'
					fi
					return ;;
				(remotes.*) compset -P '* '
					local suffix
					if [[ $words[CURRENT] = [\"\']* ]]
					then
						suffix=' ' 
					else
						suffix='\ ' 
					fi
					__git_remotes -S $suffix -q && ret=0 
					return ret ;;
			esac
			local z=$'\0'
			declare -a parts
			parts=("${(S@0)${git_options_static[(r)(#i)${line[1]}:*]}//(#b)(*[^\\]|):/$match[1]$z}") 
			if (( $#parts < 2 )) && [[ $line[1] = [^.]##.*.[^.]## ]]
			then
				parts=("${(S@0)${git_options_static[(r)(#i)${line[1]%%.*}.\*.${line[1]##*.}:*]}//(#b)(*[^\\]|):/$match[1]$z}") 
			fi
			(( $#parts > 0 )) || return ret
			case $parts[4] in
				('->'*) case ${parts[4]#->} in
						(apply.ignorewhitespace) __git_config_values -- "$current" "$parts[5]" {no,false,never,none}':do not ignore whitespace' change:'ignore changes in whitespace' && ret=0  ;;
						(apply.whitespace) __git_apply_whitespace_strategies && ret=0  ;;
						(bool) __git_config_booleans "$current" "$parts[5]" "$parts[2]" && ret=0  ;;
						(branch) __git_branch_names && ret=0  ;;
						(branch.autosetuprebase) __git_config_values -- "$current" "$parts[5]" never:'never set branch.*.rebase to true' local:'set branch.*.rebase to true for tracked branches of local branches' remote:'set branch.*.rebase to true for tracked branches of remote branches' always:'set branch.*.rebase to true for all tracking branches' && ret=0  ;;
						(branch.mergeoptions) _message 'git-merge options' ;;
						(bytes) __git_guard_bytes "$parts[2]" && ret=0  ;;
						(color) compset -P '* '
							case ($words[CURRENT]) in
								(?*' '?*' '*) if [[ $words[CURRENT] = *(bold|dim|ul|blink|reverse)* ]]
									then
										__git_colors && ret=0 
									else
										__git_color_attributes && ret=0 
									fi ;;
								(*) local suffix q_flag
									if [[ $words[CURRENT] = [\"\']* ]]
									then
										suffix=' ' 
										q_flag=-q 
									else
										suffix='\ ' 
									fi
									if [[ $words[CURRENT] = *(bold|dim|ul|blink|reverse)* ]]
									then
										__git_colors -S $suffix $q_flag && ret=0 
									else
										_alternative 'colors::__git_colors -S $suffix $q_flag' 'attributes::__git_color_attributes -S $suffix $q_flag' && ret=0 
									fi ;;
							esac ;;
						(color-bool) __git_config_values -t booleans -l boolean -- "$current" false {never,false,no,off}:"do not $parts[2]" always:"always $parts[2]" {auto,true,yes,on}:$parts[2] && ret=0  ;;
						(compression) __git_compression_levels && ret=0  ;;
						(core.autocrlf) __git_config_booleans "$current" "$parts[5]" "$parts[2]" input:'convert CRLFs on input only' && ret=0  ;;
						(core.createObject) __git_config_values -- "$current" "$parts[5]" rename:'rename source objects' link:'hardlink, then delete source objects' && ret=0  ;;
						(core.safecrlf) __git_config_booleans "$current" "$parts[5]" "$parts[2]" warn:'only warn about irreversible CRLF conversions' && ret=0  ;;
						(core.whitespace) declare -a values
							values=('blank-at-eol[treat whitespace at the end of the line as an error]' 'space-before-tab[treat space character before tab character in initial indent as an error]' 'indent-with-non-tab[treat lines indented with 8 or more space characters as an error]' 'tab-in-indent[treat lines indented with a tab character as an error]' 'blank-at-eof[treat blank lines at the end of the files as an error]' 'cr-at-eol[treat carriage-return at the end of the line as part of line terminator]') 
							_values -s , $parts[2] $values && ret=0  ;;
						(days) if [[ -n $current ]]
							then
								compadd - $current && ret=0 
							elif [[ -n $parts[5] ]]
							then
								compadd - $parts[5] && ret=0 
							else
								__git_guard_number 'number of days'
							fi ;;
						(days+now) if [[ -n $current ]]
							then
								compadd - $current && ret=0 
							elif [[ -n $parts[5] ]]
							then
								compadd - $parts[5] && ret=0 
							else
								__git_guard_number 'number of days'
							fi ;;
						(diff.renames) __git_config_booleans "$current" "$parts[5]" "$parts[2]" {copies,copy}:'try to detect both renames and copies' && ret=0  ;;
						(encoding) __git_encodings && ret=0  ;;
						(eol) __git_config_values -- "$current" "$parts[5]" lf:'use LF' crlf:'use CR+LF' native:'use line ending of platform' && ret=0  ;;
						(format.numbered) __git_config_booleans "$current" "$parts[5]" "$parts[2]" auto:'use sequence numbers if more than one patch' && ret=0  ;;
						(format.thread) __git_config_booleans "$current" "$parts[5]" "$parts[2]" deep:'make every mail a reply to the previous one' shallow:'make every mail a reply to the first one' && ret=0  ;;
						(gc.packrefs) __git_config_booleans "$current" "$parts[5]" "$parts[2]" notbare:'pack references if the repository has a working directory' && ret=0  ;;
						(gitcvs.dbdriver) __git_config_values -t dbi-drivers -l 'DBI driver' -- "$current" "$part[5]" SQLite:'use the SQLite database driver' Pg:'use the Pg database driver' && ret=0  ;;
						(help.format) __git_config_values -- "$current" "$parts[5]" man:'use man' info:'use info' {web,html}:'use HTML' && ret=0  ;;
						(imap.authMethod) __git_config_values -- "$current" "$parts[5]" CRAM-MD5:'use CRAM-MD5' && ret=0  ;;
						(int) if [[ -n $current ]]
							then
								compadd - $current && ret=0 
							elif [[ -n $parts[5] ]]
							then
								compadd - $parts[5] && ret=0 
							else
								__git_guard_number 'integer'
							fi ;;
						(merge.conflictstyle) __git_config_values -- "$current" "$parts[5]" merge:'use standard merge style' diff3:'use diff3 style' && ret=0  ;;
						(merge.verbosity) __git_config_values -t verbosity-levels -l 'verbosity level' -- "$current" "$parts[5]" 0:'only final error message if conflicts were detected'
							1:'conflicts'
							2:'conflicts and file changes'
							5:'debugging information' && ret=0  ;;
						(notes.rewriteMode) __git_config_values -- "$current" "$parts[5]" overwrite:'overwrite existing notes' concatenate:'add the note to the existing ones' ignore:'ignore the new note' && ret=0  ;;
						(permission) __git_repository_permissions && ret=0  ;;
						(push.default) __git_config_values -- "$current" "$parts[5]" nothing:'do not push anything' matching:'push all matching branches' tracking:'push current branch to its upstream branch' current:'push current branch to branch of same name' && ret=0  ;;
						(receive.denyCurrentBranch) __git_config_values -- "$current" "$parts[5]" {refuse,true,yes,on}:'update ref to current branch of non-bare repository' {warn}:'warn about dangers of pushing, but perform it anyway' {false,no,off}:'do not update ref to current branch of non-bare repository' && ret=0  ;;
						(remote.tagopt) __git_config_values -- "$current" "$parts[5]" --tags:'automatically follow tags' --no-tags:'do not automatically follow tags' && ret=0  ;;
						(sendemail.aliasfiletype) __git_config_values -- "$current" "$parts[5]" elm:'elm(1)' gnus:'gnus(1)' mutt:'mutt(1)' mailrc:'mailrc(5)' pine:'pine(1)' && ret=0  ;;
						(sendemail.confirm) __git_sendemail_confirm_values && ret=0  ;;
						(sendemail.smtpencryption) __git_sendemail_smtpencryption_values && ret=0  ;;
						(sendemail.suppresscc) __git_sendemail_suppresscc_values && ret=0  ;;
						(status.showUntrackedFiles) __git_config_values -- "$current" "$parts[5]" no:'do not show untracked files' normal:'show untracked files and directories' all:'show all individual files in directories' && ret=0  ;;
						(refname|string) if [[ -n $current ]]
							then
								compadd - $current && ret=0 
							elif [[ -n $parts[5] ]]
							then
								compadd - $parts[5] && ret=0 
							else
								_message "${parts[3]:-${parts[2]:-value}}"
							fi ;;
						(submodule.ignore) __git_config_values -- "$current" "$parts[5]" all:'never consider submodules modified' dirty:'ignore all changes to submodule work tree, only take diff between HEAD and recorded commit' untracked:'show modified tracked files' none:'show modified tracked and untracked files' && ret=0  ;;
						(umask) _alternative 'values:value:(user)' 'umasks::__git_guard_number umask' && ret=0  ;;
					esac ;;
				(*) declare -a action
					local expl
					_description values expl "$parts[2]"
					eval "action=($parts[4])"
					"$action[1]" "$expl[@]" "${(@)action[2,-1]}" && ret=0  ;;
			esac ;;
	esac
	return ret
}
_git-count-objects () {
	_arguments '(-v --verbose)'{-v,--verbose}'[also report number of in-pack objects and objects that can be removed]'
}
_git-cvsexportcommit () {
	_arguments '-c[commit automatically if patch applied cleanly]' '-p[be pedantic (paranoid) when applying patches]' '-a[add authorship information]' '-d[set an alternative CVSROOT to use]:cvsroot' '-f[force the merge, even if files are not up to date]' '-P[force the parent commit, even if it is not a direct parent]' '-m[prepend the commit message with the provided prefix]:message prefix' '-u[update affected files from CVS repository before attempting export]' '-k[reverse CVS keyword expansion]' '-w[specify location of CVS checkout to use for export]' '-W[use current working directory for bot Git and CVS checkout]' '-v[verbose output]' '-h[display usage]' ':: :__git_commits' ': :__git_commits'
}
_git-cvsimport () {
	_arguments '-v[verbose output]' '-d[specify the root of the CVS archive]:cvsroot' '-C[specify the git repository to import into]:directory:_directories' '-r[the git remote to import into]:remote' '-o[specify the branch into which you wish to import]: :__git_branch_names' '-i[do not perform a checkout after importing]' '-k[remove keywords from source files in the CVS archive]' '-u[convert underscores in tag and branch names to dots]' '-s[substitute the "/" character in branch names with given substitution]:substitute' '-p[specify additional options for cvsps]:cvsps-options' '-z[specify timestamp fuzz factor to cvsps]:fuzz-factor' '-P[read cvsps output file]:file:_files' '-m[attempt to detect merges based on the commit message]' '*-M[attempt to detect merges based on the commit message with custom pattern]:pattern' '-S[skip paths matching given regex]:regex' '-a[import all commits, including recent ones]' '-L[limit the number of commits imported]:limit' '-A[specify author-conversion file]:author-conversion file:_files' '-R[generate cvs-revisions file mapping CVS revision numbers to commit IDs]' '-h[display usage information]' ':cvsmodule'
}
_git-cvsserver () {
	_arguments -w -S -s '--base-path[path to prepend to requested CVSROOT]: :_directories' '--strict-paths[do not allow recursing into subdirectories]' '--export-all[do not check for gitcvs.enabled]' '(- * -V --version)'{-V,--version}'[display version information]' '(- * -h --help)'{-h,-H,--help}'[display usage information]' '::type:(pserver server)' '*: :_directories'
}
_git-daemon () {
	_arguments -S '--strict-paths[match paths exactly]' '--base-path=-[remap all the path requests as relative to the given path]:path:_directories' '--base-path-relaxed[allow lookup of base path witout prefix]' '--interpolated-path=-[dynamically construct alternate paths]:path:_directories' '--export-all[allow pulling from all repositories without verification]' '(--port --listen --user --group)--inetd[run server as an inetd service]' '(--inetd)--listen=-[listen on a specific IP address or hostname]: :_hosts' '(--inetd)--port=-[specify port to listen to]: :_ports' '--init-timeout=-[specify timeout between connection and request]: :__git_guard_number timeout' '--timeout=-[specify timeout for sub-requests]: :__git_guard_number timeout' '--max-connections=-[specify maximum number of concurrent clients]: :__git_guard_number "connection limit"' '--syslog[log to syslog instead of standard error]' '--user-path=-[allow ~user notation to be used in requests]::path:_directories' '--verbose[log details about incoming connections and requested files]' '--reuseaddr[reuse addresses when already bound]' '(--syslog)--detach[detach from the shell]' '--pid-file=-[save the process id in given file]:pid file:_files' '--user=-[set uid of daemon]: :_users' '--group=-[set gid of daemon]: :_groups' '--enable=-[enable site-wide service]: :__git_daemon_service' '--disable=-[disable site-wide service]: :__git_daemon_service' '--allow-override[allow overriding site-wide service]: :__git_daemon_service' '--forbid-override[forbid overriding site-wide service]: :__git_daemon_service' '*:repository:_directories'
}
_git-describe () {
	_arguments -w -S -s '(*)--dirty=-[describe HEAD, adding mark if dirty]::mark' '--all[use any ref found in "$GIT_DIR/refs/"]' '--tags[use any ref found in "$GIT_DIR/refs/tags"]' '(--tags)--contains[find the tag after the commit instead of before]' '(--long)--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' '(             --exact-match)--candidates=[consider up to given number of candidates]: :__git_guard_number "number of candidates"' '(--candidates              )--exact-match[only output exact matches, same as --candidates=0]' '--debug[display information about the searching strategy]' '(--abbrev)--long[always show full format, even for exact matches]' '--match=[only consider tags matching glob pattern]:pattern' '--always[show uniquely abbreviated commit object as fallback]' '*: :__git_committishs'
}
_git-diff () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	local -a diff_options
	__git_setup_diff_options
	_arguments -w -C -s $* $diff_options '(--cached --staged)'{--cached,--staged}'[show diff between index and named commit]' '(-)--[start file arguments]' '*:: :->from-to-file' && ret=0 
	case $state in
		(from-to-file) case $CURRENT in
				(1) if [[ -n ${opt_args[(I)--]} ]]
					then
						if [[ -n ${opt_args[(I)--cached|--staged]} ]]
						then
							__git_changed-in-index_files && ret=0 
						else
							__git_changed-in-working-tree_files && ret=0 
						fi
					else
						local files_alt='files::__git_changed-in-working-tree_files'
						if [[ -n ${opt_args[(I)--cached|--staged]} ]]
						then
							files_alt='files::__git_changed-in-index_files' 
						fi
						_alternative 'commit-ranges::__git_commit_ranges' 'blobs-and-trees-in-treeish::__git_blobs_and_trees_in_treeish' $files_alt 'blobs::__git_blobs ' && ret=0 
					fi ;;
				(2) if __git_is_committish_range $line[1]
					then
						__git_tree_files ${PREFIX:-.} $(__git_committish_range_last $line[1]) && ret=0 
					elif __git_is_committish $line[1] || __git_is_treeish $line[1]
					then
						if [[ -n ${opt_args[(I)--]} ]]
						then
							__git_changed-in-working-tree_files && ret=0 
						else
							_alternative 'commits::__git_commits' 'blobs-and-trees-in-treeish::__git_blobs_and_trees_in_treeish' 'files::__git_changed-in-working-tree_files' && ret=0 
						fi
					elif __git_is_blob $line[1]
					then
						if [[ -n ${opt_args[(I)--]} ]]
						then
							__git_cached_files && ret=0 
						else
							_alternative 'files::__git_cached_files' 'blobs::__git_blobs' && ret=0 
						fi
					elif [[ -n ${opt_args[(I)--cached|--staged]} ]]
					then
						__git_changed-in-index_files && ret=0 
					else
						__git_changed-in-working-tree_files && ret=0 
					fi ;;
				(*) if __git_is_committish_range $line[1]
					then
						__git_tree_files ${PREFIX:-.} $(__git_committish_range_last $line[1]) && ret=0 
					elif {
							__git_is_committish $line[1] && __git_is_committish $line[2]
						} || __git_is_treeish $line[2]
					then
						__git_tree_files ${PREFIX:-.} $line[2] && ret=0 
					elif __git_is_blob $line[1] && __git_is_blob $line[2]
					then
						_nothing
					else
						__git_changed-in-working-tree_files && ret=0 
					fi ;;
			esac ;;
	esac
	return ret
}
_git-diff-files () {
	declare -a revision_options
	__git_setup_revision_options
	_arguments -w -S -s $revision_options ': :__git_changed-in-working-tree_files' ': :__git_changed-in-working-tree_files' '*: :__git_changed-in-working-tree_files'
}
_git-diff-index () {
	local -a revision_options
	__git_setup_revision_options
	_arguments -S $revision_options '--cached[do not consider the work tree at all]' '-m[flag non-checked-out files as up-to-date]' ': :__git_tree_ishs' '*: :__git_cached_files'
}
_git-diff-tree () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	declare -a revision_options
	__git_setup_revision_options
	_arguments -w -C -S -s $revision_options '-r[recurse into subdirectories]' '(-r   )-t[disply tree objects in diff output]' '--root[display root diff]' '-m[do not ignore merges]' '-s[do not show differences]' '(--pretty --header)-v[display commit message before differences]' '--no-commit-id[do not display commit IDs]' '(-c --cc)-c[show differences from each of parents to merge result]' '(-c --cc)--cc[how differences from each of parents and omit differences from only one parent]' '--always[always show commit itself and commit log message]' ': :__git_tree_ishs' '*:: :->files' && ret=0 
	case $state in
		(files) if (( $#line > 2 ))
			then
				_alternative "original-tree-files:original tree:__git_tree_files ${PREFIX:-.} $line[1]" "new-tree-files:new tree:__git_tree_files ${PREFIX:-.} $line[2]" && ret=0 
			else
				_alternative 'tree-ishs::__git_tree_ishs' "tree-files::__git_tree_files ${PREFIX:-.} $line[1]" && ret=0 
			fi ;;
	esac
	return ret
}
_git-difftool () {
	_git-diff '(-y --no-prompt --prompt)'{-y,--no-prompt}'[do not prompt before invocation of diff tool]' '(-y --no-prompt)--prompt[prompt before invocation of diff tool]' '(-t --tool -x --extcmd)'{-t,--tool=-}'[merge resolution program to use]: :__git_difftools' '(-t --tool -x --extcmd)'{-x,--extcmd=-}'[custom diff command to use]: :_path_commands' '(-g --gui)'{-g,--gui}'[use diff.guitool instead of diff.tool]'
}
_git-fast-export () {
	_arguments -w -S -s '--progress=[insert progress statements]: :__git_guard_number interval' '--signed-tags=[specify how to handle signed tags]:action:((verbatim\:"silently export"
                                                                warn\:"export, but warn"
                                                                strip\:"export unsigned tags instead"
                                                                abort\:"abort on signed tags (default)"))' '--tag-of-filtered-object=[specify how to handle tags whose tagged object is filtered out]:action:((abort\:"abort on such tags"
                                                                                                        drop\:"omit such tags"
                                                                                                        rewrite\:"tag ancestor commit"))' '-M-[detect moving lines in the file as well]: : :__git_guard_number "number of characters"' '-C-[detect copies as well as renames with given scope]: :__git_guard_number size' '--export-marks=[dump internal marks table when complete]: :_files' '--import-marks=[load marks before processing input]: :_files' '--fake-missing-tagger=[fake a tagger when tags lack them]' '--no-data[do not output blocb objects, instead referring to them via their SHA-1 hash]' '--full-tree[output full tree for each commit]' '*: :__git_commit_ranges'
}
_git-fast-import () {
	_arguments -S -A '-*' '--date-format=-[type of dates used in input]:format:((raw\:"native Git format"
                                                           rfc2822\:"standard email format from RFC 2822"
                                                           now\:"use current time and timezone"' '--force[force updating modified existing branches]' '--max-pack-size=-[maximum size of each packfile]: :__git_guard_bytes' '--big-file-threshold=-[maximum size of blob to create deltas for]: :__git_guard_bytes' '--depth=-[maximum delta depth for blob and tree deltification]: :__git_guard_number "maximum delta depth"' '--active-branches=-[maximum number of branches to maintain active at once]: :__git_guard_number "maximum number of branches"' '--export-marks=-[dump internal marks table when complete]: :_files' '--import-marks=-[load marks before processing input]: :_files' '*--relative-marks[paths for export/import are relative to internal directory in current repository]' '*--no-relative-marks[paths for export/import are not relative to internal directory in current repository]' '--export-pack-edges=-[list packfiles and last commit on branches in them in given file]: :_files' '--quiet[disable all non-fatal output]' '--stats[display statistics about object created]'
}
_git-fetch () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	local -a fetch_options
	__git_setup_fetch_options
	_arguments -w -C -S -s $fetch_options '--multiple[allow several repository arguments]' '*:: :->repository-or-group-or-refspec' && ret=0 
	case $state in
		(repository-or-group-or-refspec) if (( CURRENT > 1 )) && [[ -z ${opt_args[(I)--multiple]} ]]
			then
				__git_ref_specs && ret=0 
			else
				_alternative 'remotes::__git_remotes' 'remotes-groups::__git_remotes_groups' 'local-repositories::__git_local_repositories' 'remote-repositories::__git_remote_repositories' && ret=0 
			fi ;;
	esac
	return ret
}
_git-fetch-pack () {
	_arguments -A '-*' '--all[fetch all remote refs]' '(-q --quiet)'{-q,--quiet}'[make output less verbose]' '(-k --keep)'{-k,--keep}'[do not invoke git-unpack-objects on received data]' '--thin[fetch a thin pack]' '--include-tag[download referenced annotated tags]' '(--upload-pack --exec)'{--upload-pack=-,--exec=-}'[specify path to git-upload-pack on remote side]:remote path' '--depth=-[limit fetching to ancestor-chains not longer than given number]: :__git_guard_number "maximum ancestor-chain length"' '--no-progress[do not display progress]' '-v[produce verbose output]' ': :__git_any_repositories' '*: :__git_references'
}
_git-filter-branch () {
	_arguments -S -A '-*' '--env-filter[filter for modifying environment in which commit will be performed]: :_path_commands' '--tree-filter[filter for rewriting tree and its contents]: :_path_commands' '--index-filter[filter for rewriting index]: :_path_commands' '--parent-filter[filter for rewriting parent list of commit]: :_path_commands' '--msg-filter[filter for rewriting commit messages]: :_path_commands' '--commit-filter[filter for rewriting commit]: :_path_commands' '--tag-name-filter[filter for rewriting tag names]: :_path_commands' '--subdirectory-filter[only look at histor that touches given directory]: :_directories' '--prune-empty[ignore empty generated commits]' '--original[namespace where original commits will be stored]:namespace:_directories' '-d[temporary directory used for rewriting]: :_directories' '(-f --force)'{-f,--force}'[force operation]' '*: :__git_commit_ranges'
}
_git-fmt-merge-msg () {
	_arguments -w -S -s '(      --no-log)--log[display one-line descriptions from actual commits being merged]' '(--log         )--no-log[do not display one-line descriptions from actual commits being merged]' '(-m --message)'{-m+,--message=}'[use given message instead of branch names for first line in log message]:message' '(-F --file)'{-F,--file}'[specify list of merged objects from file]: :_files'
}
_git-for-each-ref () {
	_arguments -w -S -s '--count=[maximum number of refs to iterate over]: :__git_guard_number "maximum number of refs"' '--sort=[key to sort refs by]: :__git_ref_sort_keys' '--format=-[output format of ref information]:format' '(-s --shell -p --perl --python --tcl)'{-s,--shell}'[use string literals suitable for sh]' '(-s --shell -p --perl --python --tcl)'{-p,--perl}'[use string literals suitable for Perl]' '(-s --shell -p --perl          --tcl)'--python'[use string literals suitable for Python]' '(-s --shell -p --perl --python      )'--tcl'[use string literals suitable for Tcl]' ':: :_guard "([^-]?#|)" pattern'
}
_git-format-patch () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	local -a diff_options
	__git_setup_diff_options
	_arguments -w -C -S -s $diff_options '--[limit the number of patches to prepare]: :__git_guard_number "number of patches to prepare"' '(-o --output-directory --stdout)'{-o,--output-directory}'[store resulting files in given directory]: :_directories' '(-n --numbered -N --no-numbered -k --keep-subject)'{-n,--numbered}'[name output in \[PATCH n/m\] format]' '(-n --numbered -N --no-numbered -k --keep-subject)'{-N,--no-numbered}'[name output in \[PATCH\] format]' '--start-number=[start numbering patches at given number]: :__git_guard_number "patch number"' '--numbered-files[use only number for file name]' '(-n --numbered -N --no-numbered -k --keep-subject --subject-prefix)'{-k,--keep-subject}'[do not strip/add \[PATCH\] from the first line of the commit message]' '(-s --signoff)'{-s,--signoff}'[add Signed-off-by: line to the commit message]' '(-o --output-directory)--stdout[output the generated mbox on standard output (implies --mbox)]' '(         --no-attach --inline)--attach=-[create attachments instead of inlining patches]::boundary' '(--attach             --inline)--no-attach[disable creation of attachments]' '(--attach --no-attach         )--inline=-[inline patches]::boundary' '(         --no-thread)--thread=-[make the second and subsequent mails refer to the first]::style:((shallow\:"all refer to the first"
                                                                                                        deep\:"each refers to the previous"))' '(--thread            )--no-thread[do not thread messages]' '--in-reply-to=[make the first mail a reply to the given message]:message id' '--ignore-if-in-upstream[do not include a patch that matches a commit in the given range]' '(-k --keep-subject)--subject-prefix=[use the given prefix instead of \[PATCH\]]:prefix' '*--to=[add To: header to email headers]: :_email_addresses' '*--cc=[add Cc: header to email headers]: :_email_addresses' '*--add-header=[add an arbitrary header to email headers]:header' '--cover-letter[generate a cover letter template]' '(            --no-signature)--signature=[add a signature]:signature' '(--signature               )--no-signature[do not add a signature]' '--suffix=[use the given suffix for filenames]:filename suffix' '--no-binary[do not output contents of changes in binary files, only note that they differ]' '--root[treat the revision argument as a range]' ': :->commit-or-commit-range' && ret=0 
	case $state in
		(commit-or-commit-range) if [[ -n ${opt_args[(I)--root]} ]]
			then
				__git_commits && ret=0 
			else
				__git_commit_ranges && ret=0 
			fi ;;
	esac
	return ret
}
_git-fsck () {
	_arguments -w -S -s '--unreachable[show objects that are unreferenced in the object database]' '--root[show root nodes]' '--tags[show tags]' '--cache[consider objects recorded in the index as head nodes for reachability traces]' '--no-reflogs[do not consider commits referenced only by reflog entries to be reachable]' '--full[check all object directories]' '--strict[do strict checking]' '(-v --verbose)'{-v,--verbose}'[output additional information]' '--lost-found[write dangling objects into .git/lost-found]' '*: :__git_objects'
}
_git-gc () {
	_arguments -w -S -s '--aggressive[more aggressively optimize]' '--auto[check whether housekeeping is required]' '(        --no-prune)--prune=[prune loose objects older than given date]: :__git_datetimes' '(--prune           )--no-prune[do not prune any loose objects]' '--quiet[suppress all progress reports]'
}
_git-get-tar-commit-id () {
	_message 'no arguments allowed; accepts tar-file on standard input'
}
_git-grep () {
	local -a pattern_operators
	if (( words[(I)-e] == CURRENT - 2 ))
	then
		pattern_operators=('--and[both patterns must match]' '--or[either pattern must match]' '--not[the following pattern must not match]') 
	fi
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C -A '-*' '(-O --open-files-in-pager --no-index)--cached[search blobs registered in index file instead of working tree]' '(--cached)--no-index[search files in current directory, not just treacked files]' '(-a --text)'{-a,--text}'[process binary files as if they were text]' '(-i --ignore-case)'{-i,--ignore-case}'[ignore case when matching]' '-I[do not match pattern in binary files]' '--max-depth=[descend at most given levels of directories]:__git_guard_number depth' '(-w --word-regexp)'{-w,--word-regexp}'[match only whole words]' '(-v --invert-match)'{-v,--invert-match}'[select non-matching lines]' '(   -H)-h[supress output of filenames]' '(-h   )-H[show filenames]' '--full-name[output paths relative to the project top directory]' '(-E --extended-regexp -G --basic-regexp)'{-E,--extended-regexp}'[use POSIX extended regexes]' '(-E --extended-regexp -G --basic-regexp)'{-G,--basic-regexp}'[use POSIX basic regexes]' '(-F --fixed-strings)'{-F,--fixed-strings}'[do not interpret pattern as a regex]' '-n[prefix the line number to matching lines]' '(-l --files-with-matches -L --files-without-match --name-only)'{-l,--files-with-matches,--name-only}'[show only names of matching files]' '(-l --files-with-matches -L --files-without-match)'{-L,--files-without-match}'[show only names of non-matching files]' '(--cached -O --open-files-in-pager)'{-O,--open-files-in-pager}'=-[open matching files in pager]::_path_commands' '(-z --null)'{-z,--null}'[output \0 after filenames]' '(-c --count)'{-c,--count}'[show number of matching lines in files]' '(        --no-color)--color=-[color matches]:: :__git_color_whens' '(--color           )---no-color[do not color matches]' '-A[show trailing context]: :__git_guard_number lines' '-B[show leading context]: :__git_guard_number lines' '-C[show context]: :__git_guard_number lines' '(-p --show-function)'{-p,--show-function}'[show preceding line containing function name of match]' '(1)*-f[read patterns from given file]:pattern file:_files' '(1)*-e[use the given pattern for matching]:pattern' $pattern_operators '--all-match[all patterns must match]' ':pattern' '*:: :->tree-or-file' && ret=0 
	case $state in
		(tree-or-file) integer first_tree last_tree start end
			(( start = words[(I)(-f|-e)] > 0 ? 1 : 2 ))
			(( end = $#line - 1 ))
			for ((i = start; i <= end; i++ )) do
				[[ line[i] = '--' ]] && break
				__git_is_treeish $line[i] || break
				if (( first_tree == 0 ))
				then
					(( first_tree = last_tree = i ))
				else
					(( last_tree = i ))
				fi
			done
			if (( last_tree == 0 || last_tree == end ))
			then
				if (( first_tree == 0 ))
				then
					_alternative 'treeishs::__git_tree_ishs' 'files::__git_cached_files' && ret=0 
				else
					_alternative 'treeishs::__git_trees' "files::__git_tree_files ${PREFIX:-.} $line[first_tree,last_tree]" && ret=0 
				fi
			else
				if (( first_tree == 0 ))
				then
					__git_cached_files && ret=0 
				else
					__git_tree_files ${PREFIX:-.} $line[first_tree,last_tree] && ret=0 
				fi
			fi ;;
	esac
	return ret
}
_git-gui () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C '--version[display version information]' ': :->command' '*:: :->arg' && ret=0 
	case $state in
		(command) local -a commands
			commands=(blame:'start a blame viewer' browser:'start a tree browser' citool:'arrange to make one commit' version:'display version information') 
			_describe -t commands command commands && ret=0  ;;
		(arg) curcontext=${curcontext%:*}-$line[1]: 
			case $line[1] in
				(blame) _git-blame && ret=0  ;;
				(browser) _arguments -C ':: :__git_revisions' '*:: :->file' && ret=0 
					case $state in
						(file) __git_is_treeish $line[1] && __git_tree_files ${PREFIX:-.} $line[1] && ret=0  ;;
					esac ;;
				(citool) _git-citool && ret=0  ;;
				(version) _nothing ;;
				(*) _nothing ;;
			esac ;;
	esac
	return ret
}
_git-hash-object () {
	_arguments -S '-t[type of object to create]:object type:((blob\:"a blob of data"
                                                commit\:"a tree with parent commits"
                                                tag\:"a symbolic name for another object"
                                                tree\:"a recursive tree of blobs"))' '-w[write object to object database]' '(: --stdin-paths)--stdin[read object from standard input]' '(: --stdin --path)--stdin-paths[read file names from standard input instead of from command line]' '(       --no-filters)--path=[hash object as if it were located at given path]: :_files' '(--path             )--no-filters[hash contents as is, ignoring any input filters]' '(--stdin --stdin-paths):file:_files'
}
_git-help () {
	_arguments -w -S -s '(         -i --info -m --man -w --web)'{-a,--all}'[show all available commands]' '(-a --all           -m --man -w --web)'{-i,--info}'[show all available commands]' '(-a --all -i --info          -w --web)'{-m,--man}'[show all available commands]' '(-a --all -i --info -m --man         )'{-w,--web}'[show all available commands]' ': :_git_commands'
}
_git-http-backend () {
	_nothing
}
_git-http-fetch () {
	_arguments '-c[fetch commit objects]' '-t[fetch trees associated with commit objects]' '-a[fetch all objects]' '-v[report what is downloaded]' '-w[write commit-id into the filename under "$GIT_DIR/refs/<filename>"]:filename' '--recover[recover from a failed fetch]' '(1)--stdin[read commit ids and refs from standard input]' ': :__git_commits' ': :_urls'
}
_git-http-push () {
	_arguments '--all[verify that all objects in local ref history exist remotely]' '--force[allow refs that are not ancestors to be updated]' '--dry-run[do everything except actually sending the updates]' '--verbose[report the list of objects being walked locally and sent to remote]' '(   -D)-d[remove refs from remote repository]' '(-d   )-D[forcefully remove refs from remote repository]' ': :_urls' '*: :__git_remote_references'
}
_git-imap-send () {
	_message 'no arguments allowed; accepts mailbox file on standard input'
}
_git-index-pack () {
	local -a stdin_opts
	if (( words[(I)--stdin] ))
	then
		stdin_opts=('--fix-thin[record deltified objects, based on objects not included]' '--keep=-[create .keep file]::reason') 
	fi
	_arguments '-v[display progress on stderr]' '-o[write generated pack index into specified file]: :_files' '--stdin[read pack from stdin and instead write to specified file]' $stdin_opts '--strict[die if the pack contains broken objects or links]' ':pack file:_files -g "*.pack(-.)"'
}
_git-init () {
	_arguments -w -S -s '(-q --quiet)'{-q,--quiet}'[do not print any results to stdout]' '--bare[create a bare repository]' '--template=[directory to use as a template for the object database]: :_directories' '--shared=[share repository amongst several users]:: :__git_repository_permissions' ':: :_directories'
}
_git-instaweb () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '(-l --local)'{-l,--local}'[bind the web server to 127.0.0.1]' '(-d --httpd)'{-d,--httpd=}'[HTTP-daemon command-line that will be executed]:command line' '(-m --module-path)'{-m,--module-path=}'[module path for the Apache HTTP-daemon]:module path:_directories' '(-p --port)'{-p,--port=}'[port to bind web server to]: :__git_guard_number port' '(-b --browser)'{-b,--browser=}'[web-browser command-line that will be executed]:command line' '(:)--start[start the HTTP-daemon and exit]' '(:)--stop[stop the HTTP-daemon and exit]' '(:)--restart[restart the HTTP-daemon and exit]' ': :->command' && ret=0 
	case $state in
		(command) declare -a commands
			commands=(start:'start the HTTP-daemon and exit' stop:'stop the HTTP-daemon and exit' restart:'restart the HTTP-daemon and exit') 
			_describe -t commands command commands && ret=0  ;;
	esac
	return ret
}
_git-log () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	local -a log_options revision_options diff_options
	__git_setup_log_options
	__git_setup_revision_options
	__git_setup_diff_options
	_arguments -w -C -s $log_options $revision_options $diff_options '(-)--[start file arguments]' '*:: :->commit-range-or-file' && ret=0 
	case $state in
		(commit-range-or-file) case $CURRENT in
				(1) if [[ -n ${opt_args[(I)--]} ]]
					then
						__git_cached_files && ret=0 
					else
						_alternative 'commit-ranges::__git_commit_ranges' 'cached-files::__git_cached_files' && ret=0 
					fi ;;
				(*) if __git_is_committish_range $line[1]
					then
						__git_tree_files ${PREFIX:-.} $(__git_committish_range_last $line[1]) && ret=0 
					elif __git_is_committish $line[1]
					then
						__git_tree_files ${PREFIX:-.} $line[1] && ret=0 
					else
						__git_cached_files && ret=0 
					fi ;;
			esac ;;
	esac
	return ret
}
_git-ls-files () {
	local no_empty_directory_opt=
	if (( words[(I)--directory] ))
	then
		no_empty_directory_opt='--no-empty-directory[do not list empty directories]' 
	fi
	_arguments -w -S -s '(-c --cached)'{-c,--cached}'[show cached files in output]' '(-d --deleted)'{-d,--deleted}'[show deleted files in output]' '(-m --modified)'{-m,--modified}'[show modified files in output]' '(-o --others)'{-o,--others}'[show other files in output]' '(-i --ignored)'{-i,--ignored}'[show ignored files in output]' '(-s --stage --with-tree)'{-s,--stage}'[show stage files in output]' '--directory[if a whole directory is classified as "other", show just its name]' $no_empty_directory_opt '(-s --stage -u --unmerged --with-tree)'{-u,--unmerged}'[show unmerged files in output]' '(-k --killed)'{-k,--killed}'[show killed files in output]' '-z[use NUL termination on output]' '*'{-x,--exclude=-}'[skip files matching given pattern]:file pattern' '*'{-X,--exclude-from=-}'[skip files matching patterns in given file]: :_files' '*--exclude-per-directory=-[skip directories matching patterns in given file]: :_files' '--exclude-standard[skip files in standard Git exclusion lists]' '--error-unmatch[if any file does not appear in index, treat this as an error]' '(-s --stage -u --unmerged)--with-tree=[treat paths removed since given tree-ish as still present]: :__git_tree_ishs' '-v[identify each files status (hmrck?)]' '--full-name[force paths to be output relative to the project top directory]' '--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' '*:: :_files'
}
_git-ls-remote () {
	_arguments -A '-*' '(-h --heads)'{-h,--heads}'[show only refs under refs/heads]' '(-t --tags)'{-t,--tags}'[show only refs under refs/tags]' '(-u --upload-pack)'{-u,--upload-pack=-}'[specify path to git-upload-pack on remote side]:remote path' ': :__git_any_repositories' '*: :__git_references'
}
_git-ls-tree () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '(-t)-d[do not show children of given tree (implies -t)]' '-r[recurse into subdirectories]' '-t[show tree entries even when going to recurse them]' '(-l --long)'{-l,--long}'[show object size of blob entries]' '-z[use NUL termination on output]' '(--name-only --name-status)'{--name-only,--name-status}'[list only filenames, one per line]' '--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' '--full-name[output full path-names]' '(--full-name)--full-tree[do not limit listing to current working-directory]' ': :__git_tree_ishs' '*:: :->file' && ret=0 
	case $state in
		(file) __git_ignore_line __git_tree_files ${PREFIX:-.} $line[1] && ret=0  ;;
	esac
	return ret
}
_git-mailinfo () {
	_arguments -A '-*' '-k[do not strip/add \[PATCH\] from first line of commit message]' '(-u --encoding)-u[encode commit information in UTF-8]' '(-u --encoding)--encoding=-[encode commit information in given encoding]: :__git_encodings' '-n[disable all charset re-coding of metadata]' '(           --no-scissors)--scissors[remove everything in body before a scissors line]' '(--scissors              )--no-scissors[do not remove everything in body before a scissors line]' '--no-inbody-headers[undocumented]' ':message file:_files' ':patch file:_files'
}
_git-mailsplit () {
	_arguments -S -A '-*' '-o-[directory in which to place individual messages]:directory:_directories' '-b[if file does not begin with "From " line, assume it is a single mail message]' '-d-[specify number of leading zeros]: :__git_guard_number precision' '-f-[skip the first N numbers]: :__git_guard_number' '--keep-cr[do not remove CR from lines ending with CR+LF]' '*::mbox file:_files'
}
_git-merge () {
	local -a merge_options
	__git_setup_merge_options
	_arguments -w -S -s $merge_options '-m[set the commit message to be used for the merge commit]:merge message' '(                    --no-rerere-autoupdate)--rerere-autoupdate[allow the rerere mechanism to update the index]' '(--rerere-autoupdate                       )--no-rerere-autoupdate[do not allow the rerere mechanism to update the index]' '*: :__git_commits'
}
_git-merge-base () {
	_arguments -w -S -s '(-a --all)'{-a,--all}'[display all common ancestors]' '--octopus[compute best common ancestors of all supplied commits]' '(-)--independent[display minimal subset of supplied commits with same ancestors]' ': :__git_commits' '*: :__git_commits'
}
_git-merge-file () {
	integer n_labels=${#${(M)words[1,CURRENT-1]:#-L}}
	local label_opt=
	if (( n_labels < 3 )) || [[ $words[CURRENT-1] = -L ]]
	then
		local -a ordinals
		ordinals=(first second third) 
		label_opt="*-L[label to use for the $ordinals[n_labels+1] file]:label" 
	fi
	_arguments $label_opt '(-p --stdout)'{-p,--stdout}'[send merged file to standard output instead of overwriting first file]' '(-q --quiet)'{-q,--quiet}'[do not warn about conflicts]' '(       --theirs --union)--ours[resolve conflicts favoring our side of the lines]' '(--ours          --union)--theirs[resolve conflicts favoring their side of the lines]' '(--ours --theirs        )--union[resolve conflicts favoring both sides of the lines]' '--marker-size[specify length of conflict markers]: :__git_guard_number "marker length"' '--diff3[undocumented]' ':current file:_files' ':base file:_files' ':other file:_files'
}
_git-merge-index () {
	if (( CURRENT > 2 )) && [[ $words[CURRENT-1] != -[oq] ]]
	then
		_arguments -S '(:)-a[run merge against all files in index that need merging]' '*: :__git_cached_files'
	else
		declare -a arguments
		(( CURRENT == 2 )) && arguments+='-o[skip failed merges]' 
		(( CURRENT == 2 || CURRENT == 3 )) && arguments+='(-o)-q[do not complain about failed merges]' 
		(( 2 <= CURRENT && CURRENT <= 4 )) && arguments+='*:merge program:_files -g "*(*)"' 
		_arguments -S $arguments
	fi
}
_git-merge-one-file () {
	_message 'you probably should not be issuing this command'
}
_git-merge-tree () {
	_arguments ':base-tree:__git_tree_ishs' ':branch 1:__git_tree_ishs' ':branch 2:__git_tree_ishs'
}
_git-mergetool () {
	_arguments -S -A '-*' '(-t --tool)'{-t,--tool=}'[merge resolution program to use]: :__git_mergetools' '(-y --no-prompt --prompt)'{-y,--no-prompt}'[do not prompt before invocation of merge resolution program]' '(-y --no-prompt)--prompt[prompt before invocation of merge resolution program]' '*:conflicted file:_files'
}
_git-mktag () {
	_message 'no arguments allowed; only accepts tags on standard input'
}
_git-mktree () {
	_arguments -w -S -s '-z[read NUL-terminated ls-tree -z output]' '--missing[allow missing objects]' '--batch[allow creation of more than one tree]'
}
_git-mv () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '(-f --force)'{-f,--force}'[rename/move even if targets exist]' '-k[skip rename/move that would lead to errors]' '(-n --dry-run)'{-n,--dry-run}'[only show what would happen]' ':source:__git_cached_files' '*:: :->source-or-destination' && ret=0 
	case $state in
		(source-or-destination) _alternative 'cached-files:source:__git_cached_files' 'directories:destination directory:_directories' && ret=0  ;;
	esac
	return ret
}
_git-name-rev () {
	_arguments -S '--tags[only use tags to name commits]' '--refs=[only use refs matching given pattern]: :_guard "?#" "shell pattern"' '(--stdin :)--all[list all commits reachable from all refs]' '(--all :)--stdin[read from stdin and append revision-name]' '--name-only[display only name of commits]' '--no-undefined[die with non-zero return when a reference is undefined]' '--always[show uniquely abbreviated commit object as fallback]' '(--stdin --all)*: :__git_commits'
}
_git-notes () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C '--ref=[manipulate the notes tree in given ref]: :__git_notes_refs' ': :->command' '*:: :->option-or-argument' && ret=0 
	case $state in
		(command) local -a commands
			commands=(list:'list notes object for given object' add:'add notes for a given object' copy:'copy notes from one object to another' append:'append notes to a given object' edit:'edit notes for a given object' show:'show notes for a given object' remove:'remove notes for a given object' prune:'remove all notes for non-existing/unreachable objects') 
			_describe -t commands command commands && ret=0  ;;
		(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
			case $line[1] in
				(list|show|edit|remove) _arguments ': :__git_commits' && ret=0  ;;
				(add) _arguments -w -S -s '*'{-m,--message=}'[use given note message]:message' '*'{-F,--file=}'[take note message from given file]:note message file:_files' '(-C --reuse-message)'{-C,--reuse-message=}'[take note message from given blob object]: :__git_blobs' '(-c --reedit-message)'{-c,--reedit-message=}'[take note message from given blob object and edit it]: :__git_blobs' '(-f --force)'{-f,--force}'[overwrite existing note]' ': :__git_commits' && ret=0  ;;
				(copy) _arguments -w -S -s '(-f --force)'{-f,--force}'[replace existing note]' '(:)--stdin[read objects from stdin]' '(:--stdin)--for-rewrite=[load rewriting config for given command]:command:(amend rebase)' ': :__git_commits' ': :__git_commits' && ret=0  ;;
				(append) _arguments -w -S -s '*'{-m,--message=}'[use given note message]:message' '*'{-F,--file=}'[take note message from given file]:note message file:_files' '(-C --reuse-message)'{-C,--reuse-message=}'[take note message from given blob object]: :__git_blobs' '(-c --reedit-message)'{-c,--reedit-message=}'[take note message from given blob object and edit it]: :__git_blobs' ': :__git_commits' && ret=0  ;;
				(*) _nothing ;;
			esac ;;
	esac
	return ret
}
_git-pack-objects () {
	local thin_opt=
	if (( words[(I)--stdout] ))
	then
		thin_opt='--thin[create a thin pack]' 
	fi
	_arguments -A '-*' '(: --max-pack-size)--stdout[write pack contents to standard output]' '--revs[read revision arguments from standard input]' '(--revs)--unpacked[limit objects to pack to those not already packed]' '(--revs)--all[include all refs as well as revisions already specified]' '--include-tag[include unasked-for annotated tags if object they reference is included]' '--window=-[number of objects to use per delta compression]: :__git_guard_number "window size"' '--depth=-[maximum delta depth]: :__git_guard_number "maximum delta depth"' '--window-memory=-[window size in memory]:window size:__git_guard_bytes' '(--stdout)--max-pack-size=[maximum size of each output packfile]:maximum pack size:__git_guard_bytes' '--honor-pack-keep[ignore objects in local pack with .keep file]' '(              --local)--incremental[ignore objects that have already been packed]' '(--incremental        )--local[similar to --incremental, but only ignore unpacked non-local objects]' '--non-empty[only create a package if it contains at least one object]' '(           --all-progress)--progress[display progress on standard error]' '(--progress                --all-progress-implied)--all-progress[display progress output on standard error, even during write-out phase]' '(--all-progress)--all-progress-implied[like --all-progress, but only if --progress was also passed]' '-q[do not report progress]' '--no-reuse-delta[do not reuse existing deltas, but compute them from scratch]' '--no-reuse-object[do not reuse existing object data]' '--compression=-[specify compression level]: :__git_compression_levels' $thin_opt '--delta-base-offset[use delta-base-offset packing]' '--threads=-[specify number of threads for searching for best delta matches]: :__git_guard_number "number of threads"' '--keep-true-parents[pack parents hidden by grafts]' '(                   --unpack-unreachable)--keep-unreachable[undocumented]' '(--keep-unreachable                     )--unpack-unreachable[undocumented]' ':base-name:_files'
}
_git-pack-redundant () {
	_arguments -S -A '-*' '(:)--all[process all packs]' '--alt-odb[do not require objects to be present in local packs]' '--verbose[output some statistics to standard error]' '(--all)*::packs:_files -g "*.pack(-.)"'
}
_git-pack-refs () {
	_arguments '(      --no-all)--all[pack all refs]' '(--all         )--no-all[do not pack all refs]' '(        --no-prune)--prune[remove loose refs after packing them]' '(--prune           )--no-prune[do not remove loose refs after packing them]'
}
_git-patch-id () {
	_message 'no arguments allowed; accepts patch on standard input'
}
_git-prune () {
	_arguments -S '(-n --dry-run)'{-n,--dry-run}'[do not remove anything; just report what would be removed]' '(-v --verbose)'{-v,--verbose}'[report all removed objects]' '--expire[only expire loose objects older than given date]: :__git_datetimes' '*:: :__git_heads'
}
_git-prune-packed () {
	_arguments -w -S -s '(-n --dry-run)'{-n,--dry-run}'[only list objects that would be removed]' '(-q --quiet)'{-q,--quiet}'[do not display progress on standard error]'
}
_git-pull () {
	local -a merge_options fetch_options
	__git_setup_merge_options
	__git_setup_fetch_options
	_arguments $merge_options '(         --no-rebase)--rebase[perform a rebase after fetching]' '(--rebase            )--no-rebase[do not perform a rebase after fetching]' $fetch_options ': :__git_any_repositories' '*: :__git_ref_specs'
}
_git-push () {
	_arguments -w -S -s '--all[push all refs under refs/heads/]' '--mirror[push all refs under refs/heads/ and refs/tags/ and delete non-existing refs]' '(-n --dry-run)'{-n,--dry-run}'[do everything except actually send the updates]' '--porcelain[produce machine-readable output]' '--delete[delete all listed refs from the remote repository]' '--tags[all tags under refs/tags are pushed]' '(--receive-pack --exec)'{--receive-pack=-,--exec=-}'[path to git-receive-pack on remote]:remote git-receive-pack:_files' '(-f --force)'{-f,--force}'[allow refs that are not ancestors to be updated]' '(:)--repo=[default repository to use]:repository:__git_any_repositories' '(-u --set-upstream)'{-u,--set-upstream}'[add upstream reference for each branch that is up to date or pushed]' '(       --no-thin)--thin[try to minimize number of objects to be sent]' '(--thin          )--no-thin[do not try to minimize number of objects to be sent]' '(-q --quiet -v --verbose --progress)'{-q,--quiet}'[suppress all output]' '(-q --quiet -v --verbose)'{-v,--verbose}'[output additional information]' '(-q --quiet)--progress[output progress information]' ':: :__git_any_repositories' '*: :__git_ref_specs'
}
_git-quiltimport () {
	_arguments -S '(-n --dry-run)'{-n,--dry-run}'[check patches and warn if they cannot be imported]' '--author[default author name and email address to use for patches]: :_email_addresses' '--patches[set directory containing patches]:patch directory:_directories'
}
_git-read-tree () {
	local trivial_opt= aggressive_opt=
	if (( words[(I)-m] ))
	then
		trivial_opt='--trivial[restrict three-way merge to only happen if no file-level merging is required]' 
		aggressive_opt='--aggressive[try harder to resolve merge conflicts]' 
	fi
	local -a ui_opts
	if (( words[(I)(-m|--reset|--prefix)] ))
	then
		ui_opts=('(   -i)-u[update the work tree after successful merge]' '(-u   )-i[update only the index; ignore changes in work tree]') 
	fi
	local exclude_per_directory_opt
	if (( words[(I)-u] ))
	then
		exclude_per_directory_opt='--exclude-per-directory=-[specify .gitignore file]:.gitignore file:_files' 
	fi
	_arguments -w -S -s '(   --reset --prefix)-m[perform a merge, not just a read]' '(-m         --prefix)--reset[perform a merge, not just a read, ignoring unmerged entries]' '(-m --reset          2 3)--prefix=-[read the contents of specified tree-ish under specified directory]:prefix:_directories -r ""' $ui_opts '-v[display progress on standard error]' $trivial_opt $aggressive_opt $exclude_per_directory_opt '--index-output=[write index in the named file instead of $GIT_INDEX_FILE]: :_files' '--no-sparse-checkout[display sparse checkout support]' '1:first tree-ish to be read/merged:__git_tree_ishs' '2::second tree-ish to be read/merged:__git_tree_ishs' '3::third tree-ish to be read/merged:__git_tree_ishs'
}
_git-rebase () {
	local -a autosquash_opts
	if (( words[(I)--interactive] ))
	then
		autosquash_opts=('(             --no-autosquash)--autosquash[check for auto-squash boundaries]' '(--autosquash                )--no-autosquash[do not check for auto-squash boundaries]') 
	fi
	_arguments -A '-*' '(- :)--continue[continue after resolving merge conflict]' '(- :)--abort[abort current rebase]' '(- :)--skip[skip the current patch]' '(-m --merge)'{-m,--merge}'[use merging strategies to rebase]' '*'{-s,--strategy=}'[use given merge strategy]:merge strategy:__git_merge_strategies' '*'{-X,--strategy-option=}'[pass merge-strategy-specific option to merge strategy]' '(-q --quiet -v --verbose --stat -n --no-stat)'{-q,--quiet}'[suppress all output]' '(-q --quiet -v --verbose --stat -n --no-stat)'{-v,--verbose}'[output additional information]' '--no-verify[bypass the pre-rebase hook]' '-C-[ensure that given lines of surrounding context match]: :__git_guard_number "lines of context"' '(-f --force-rebase)'{-f,--force-rebase}'[force rebase even if current branch descends from commit rebasing onto]' '(-i --interactive)--ignore-whitespace[ignore whitespace in context]' '(-i --interactive)--whitespace=-[detect a new or modified line that has whitespace errors]: :__git_apply_whitespace_strategies' '(-i --interactive)--committer-date-is-author-date[use author date as committer date]' '(-i --interactive --ignore-whitespace --whitespace --committer-date-is-author-date)'{-i,--interactive}'[make a list of commits to be rebased and open in $EDITOR]' '(-p --preserve-merges --interactive)'{-p,--preserve-merges}'[try to recreate merges instead of ignoring them]' '(1)--root[rebase all reachable commits]' $autosquash_opts '--no-ff[cherry-pick all rebased commits with --interactive, otherwise synonymous to --force-rebase]' '--onto[start new branch with HEAD equal to given revision]:newbase:__git_revisions' ':upstream branch:__git_revisions' '::working branch:__git_branch_names'
}
_git-receive-pack () {
	_arguments -A '-*' '--advertise-refs[undocumented]' '--stateless-rpc[undocumented]' ':directory to sync into:_directories'
}
_git-reflog () {
	declare -a revision_options
	__git_setup_revision_options
	if [[ $words[2] = --* ]]
	then
		_arguments -S $revision_options ':: :__git_references'
	else
		local curcontext=$curcontext state line ret=1
		declare -A opt_args
		_arguments -C -S '(- : *)-h[display usage]' $revision_options ': :->command' '*:: :->option-or-argument' && ret=0 
		case $state in
			(command) declare -a commands
				commands=('expire:prune old reflog entries' 'delete:delete entries from reflog' 'show:show log of ref') 
				_describe -t commands command commands && ret=0  ;;
			(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
				case $line[1] in
					(expire) _arguments -S '(-n --dry-run)'{-n,--dry-run}'[undocumented]' '--stale-fix[TODO\: provide a decent description for this option]' '--expire=-[prune entries older than given time]: :__git_datetimes' '--expire-unreachable=-[prune entries older than given time and unreachable]: :__git_datetimes' '--all[prune all refs]' '--updateref[update ref with SHA-1 of top reflog entry after expiring or deleting]' '--rewrite[adjust reflog entries to ensure old SHA-1 points to new SHA-1 of previous entry after expring or deleting]' '--verbose[output additional information]' && ret=0  ;;
					(delete) _arguments -C -S '(-n --dry-run)'{-n,--dry-run}'[undocumented]' '--updateref[update ref with SHA-1 of top reflog entry after expiring or deleting]' '--rewrite[adjust reflog entries to ensure old SHA-1 points to new SHA-1 of previous entry after expring or deleting]' '*:: :->reflog-entry' && ret=0 
						case $state in
							(reflog-entry) __git_ignore_line __git_reflog_entries && ret=0  ;;
						esac ;;
					(show|--*) _arguments -S $revision_options ':: :__git_references' && ret=0  ;;
				esac ;;
		esac
		return ret
	fi
}
_git-relink () {
	_arguments '--safe[stop if two objects with the same hash exist but have different sizes]' '--help[display help]' ': :_directories' ': :_directories' '*: :_directories'
}
_git-remote () {
	# undefined
	builtin autoload -XUz
}
_git-repack () {
	_arguments -w -S -s '(-A)-a[pack all objects into a single pack]' '(-a)-A[pack all objects into a single pack, but unreachable objects become loose]' '-d[remove redundant packs after packing]' '-l[pass --local option to git pack-objects]' '-f[pass --no-reuse-delta option to git pack-objects]' '-F[pass --no-reuse-object option to git pack-objects]' '(-q --quiet)'{-q,--quiet}'[pass -q option to git pack-objects]' '-n[do not update server information]' '--window=-[number of objects to consider when doing delta compression]: :__git_guard_number "number of objects"' '--depth=-[maximum delta depth]: :__git_guard_number "maximum delta depth"' '--window-memory=-[scale window size dynamically to not use more than N bytes of memory]: :__git_guard_bytes' '--max-pack-size=-[maximum size of each output packfile]:maximum pack size:__git_guard_bytes'
}
_git-replace () {
	_arguments -w -S -s '(- *)-f[overwrite existing replace ref]' '(- 2)-d[delete existing replace refs]' '(- : *)-l[list replace refs]:pattern' ': :__git_objects' ':replacement:__git_objects' '*: :__git_objects'
}
_git-request-pull () {
	_arguments -S '-p[display patch text]' ':start commit:__git_commits' ': :_urls' '::end commit:__git_commits'
}
_git-rerere () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '--rerere-autoupdate[register clean resolutions in index]' ': :->command' && ret=0 
	case $state in
		(command) _values command 'clear[reset metadata used by rerere]' 'forget[resets metadata used by rerere for specific conflict]: :__git_cached_files' 'diff[output diffs for the current state of the resolution]' 'status[like diff, but only output filesames]' 'gc[prune old records of conflicted merges]' && ret=0  ;;
	esac
	return ret
}
_git-reset () {
	local curcontext=$curcontext state line ret=1
	typeset -A opt_args
	_arguments -w -C -s '(       --mixed --hard --merge --keep -p --patch -- *)--soft[do not touch the index file nor the working tree]' '(--soft         --hard --merge --keep -p --patch -- *)--mixed[reset the index but not the working tree (default)]' '(--soft --mixed        --merge --keep -p --patch -- *)--hard[match the working tree and index to the given tree]' '(--soft --mixed --hard         --keep -p --patch -- *)--merge[reset out of a conflicted merge]' '(--soft --mixed --hard --merge        -p --patch -- *)--keep[like --hard, but keep local working tree changes]' '(-p --patch)'{-p,--patch}'[select diff hunks to remove from the index]' '(-q --quiet)'{-q,--quiet}'[suppress all output]' '(- 1)--[start file arguments]' '(--soft --mixed --hard --merge --keep):: :__git_commits' '(--soft --mixed --hard --merge --keep)*:: :->file' && ret=0 
	case $state in
		(file) local commit=HEAD
			if [[ -n $line[1] ]] && __git_is_committish $line[1]
			then
				commit=$line[1] 
			fi
			__git_tree_files ${PREFIX:-.} $commit && ret=0  ;;
	esac
	return ret
}
_git-rev-list () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	declare -a revision_options
	__git_setup_revision_options
	_arguments -C -S $revision_options '(--pretty)--header[display contents of commit in raw-format]' '--timestamp[print raw commit timestamp]' '(         --bisect-vars --bisect-all)--bisect[show only middlemost commit object]' '(--bisect)--bisect-vars[same as --bisect, displaying shell-evalable code]' '(--bisect)--bisect-all[display all commit objects beteen included and excluded commits]' '*:: :->commit-or-path' && ret=0 
	case $state in
		(commit-or-path) if [[ -n ${opt_args[(I)--]} ]]
			then
				__git_cached_files && ret=0 
			else
				_alternative 'commit-ranges::__git_commit_ranges' 'cached-files::__git_cached_files' && ret=0 
			fi ;;
	esac
	return ret
}
_git-rev-parse () {
	local parseopt_opt= sq_quote_opt= local_env_vars_opt= h_opt=
	declare -a quiet_opts
	if (( CURRENT == 2 ))
	then
		parseopt_opt='--parseopt[use git rev-parse in option parsing mode]' 
		sq_quote_opt='--sq-quote[use git rev-parse in shell quoting mode]' 
		local_env_vars_opt='--local-env-vars[list git environment variables local to repository]' 
		h_opt='-h[display usage]' 
	fi
	if (( words[(I)--verify] ))
	then
		quiet_opts=({-q,--quiet}'[do not output error messages]') 
	fi
	local ret=0
	if (( words[(I)--parseopt] ))
	then
		if (( words[(I)--] ))
		then
			_message 'argument'
		else
			_arguments -w -S -s '(- *)'{-h,--help}'[display usage]' '--keep-dashdash[do not skip first -- option]' '--stop-at-non-option[stop parsing options at first non-option argument]' '*:option specification' && ret=0 
		fi
	elif (( words[(I)--sq-quote] ))
	then
		_message 'argument'
	elif (( words[(I)--local-env-vars|-h] ))
	then
		_message 'no more arguments'
	else
		_arguments $parseopt_opt $sq_quote_opt $local_env_vars_opt $h_opt '(            --no-revs --verify --short)--revs-only[do not output flags and parameters not meant for git rev-list]' '(--revs-only           --verify --short)--no-revs[do not output flags and parameters meant for git rev-list]' '(        --no-flags --verify --short)--flags[do not output non-flag parameters]' '(--flags            --verify --short)--no-flags[do not output flag parameters]' '--default[use given argument if there is no parameter given]:argument' '(--revs-only --no-revs --flags --no-flags --short)--verify[verify parameter to be usable]' '(-q --quiet)'{-q,--quiet}'[suppress all output]' '--sq[output single shell-quoted line]' '--not[toggle ^ prefix of object names]' '(           --symbolic-full-name)--symbolic[output in a format as true to input as possible]' '(--symbolic                     )--symbolic-full-name[same as --symbolic, but omit non-ref inputs]' '--abbrev-ref=-[a non-ambiguous short name of object]::mode:(strict loose)' '--all[show all refs found in refs/]' '--branches=-[show branch refs found in refs/heads/]::shell glob pattern' '--tags=-[show tag refs found in refs/tags/]::shell glob pattern' '--remotes=-[show tag refs found in refs/remotes/]::shell glob pattern' '--glob=-[show all matching refs]::shell glob pattern' '--show-toplevel[show absolute path of top-level directory]' '--show-prefix[show path of current directory relative to top-level directory]' '--show-cdup[show path of top-level directory relative to current directory]' '--git-dir[show $GIT_DIR if defined else show path to .git directory]' '--is-inside-git-dir[show whether or not current working directory is below repository directory]' '--is-inside-work-tree[show whether or not current working directory is inside work tree]' '--is-bare-repository[show whether or not repository is bare]' '(--revs-only --no-revs --flags --no-flags --verify)--short=-[show only shorter unique name]:: :__git_guard_number length' '(--since --after)'{--since=-,--after=-}'[show --max-age= parameter corresponding given date string]:datestring' '(--until --before)'{--until=-,--before=-}'[show --min-age= parameter corresponding given date string]:datestring' '*: :__git_objects' && ret=0 
	fi
	return ret
}
_git-revert () {
	_arguments -w -S -s '(-e --edit --no-edit)'{-e,--edit}'[edit the commit before committing the revert]' '(-m --mainline)'{-m+,--mainline=}'[pick which parent is mainline]:parent number' '(-e --edit)--no-edit[do not edit the commit message]' '(-n --no-commit)'{-n,--no-commit}'[do not commit the reversion]' '(-s --signoff)'{-s,--signoff}'[add Signed-off-by line at the end of the commit message]' ': :__git_commits'
}
_git-rm () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s '(-f --force)'{-f,--force}'[override the up-to-date check]' '(-n --dry-run)'{-n,--dry-run}'[do not actually remove the files, just show if they exist in the index]' '-r[allow recursive removal when a leading directory-name is given]' '--cached[only remove files from the index]' '--ignore-unmatch[exit with 0 status even if no files matched]' '(-q --quiet)'{-q,--quiet}'[suppress all output]' '*:: :->file' && ret=0 
	case $state in
		(file) if [[ -n ${opt_args[(I)--cached]} ]]
			then
				__git_changed-in-index_files && ret=0 
			else
				__git_cached_files && ret=0 
			fi ;;
	esac
	return ret
}
_git-send-email () {
	_arguments -S '--annotate[review and edit each patch before sending it]' '--bcc=[Bcc: value for each email]: :_email_addresses' '--cc=[starting Cc: value for each email]: :_email_addresses' '--compose[edit introductory message for patch series]' '--from=[specify sender]:email address:_email_addresses' '--in-reply-to=[specify contents of first In-Reply-To header]:message-id' '--subject=[specify the initial subject of the email thread]:subject' '--to=[specify the primary recipient of the emails]: :_email_addresses' '--8bit-encoding=[encoding to use for non-ASCII messages]: :__git_encodings' '--envelope-sender[specify the envelope sender used to send the emails]: :_email_addresses' '--smtp-encryption=[specify encryption method to use]: :__git_sendemail_smtpencryption_values' '--smtp-domain=[specify FQDN used in HELO/EHLO]: :_domains' '--smtp-pass=[specify password to use for SMTP-AUTH]::password' '--smtp-server=[specify SMTP server to connect to]:smtp server:_hosts' '--smtp-server-port=[specify port to connect to SMTP server on]:smtp port:_ports' '--smtp-user=[specify user to use for SMTP-AUTH]:smtp user:_users' '--cc-cmd=[specify command to generate Cc\: header with]:Cc\: command:_path_commands' '(                 --no-chain-reply-to)--chain-reply-to[send each email as a reply to previous one]' '(--chain-reply-to                    )--no-chain-reply-to[send all emails after first as replies to first one]' '--identity=[specify configuration identity]: :__git_sendemail_identities' '(                   --no-signed-off-by-cc)--signed-off-by-cc[add emails found in Signed-off-by: lines to the Cc: list]' '(--signed-off-by-cc                      )--no-signed-off-by-cc[do not add emails found in Signed-off-by: lines to the Cc: list]' '--suppress-cc=[specify rules for suppressing Cc:]: :__git_sendemail_suppresscc_values' '(                --no-suppress-from)--suppress-from[do not add the From: address to the Cc: list]' '(--suppress-from                   )--no-suppress-from[add the From: address to the Cc: list]' '(         --no-thread)--thread[set In-Reply-To: and References: headers]' '(--thread            )--no-thread[do not set In-Reply-To: and References: headers]' '--confirm[specify type of confirmation required before sending]: :__git_sendemail_confirm' '--dry-run[do everything except actually sending the emails]' '(               --no-format-patch)--format-patch[interpret ambiguous arguments as format-patch arguments]' '(--format-patch                  )--no-format-patch[interpret ambiguous arguments file-name arguments]' '--quiet[be less verbose]' '(           --no-validate)--validate[perform sanity checks on patches]' '(--validate              )--validate[do not perform sanity checks on patches]' '--force[send emails even if safetiy checks would prevent it]' '*: :_files'
}
_git-send-pack () {
	_arguments -A '-*' '(--receive-pack --exec)'{--receive-pack=-,--exec=-}'[specify path to git-receive-pack on remote side]:remote path' '--all[update all refs that exist locally]' '--dry-run[do everything except actually sending the updates]' '--force[update remote orphaned refs]' '-v[produce verbose output]' '--thin[send a thin pack]' '--mirror[undocumented]' '--stateless-rpc[undocumented]' '--helper-status[undocumented]' ': :__git_any_repositories' '*: :__git_remote_references'
}
_git-shell () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C '-c[command to execute]: :->command' ': :->argument' && ret=0 
	case $state in
		(command) declare -a commands
			commands=(git-receive-pack git-upload-pack git-upload-archive cvs) 
			_describe -t commands command commands && ret=0  ;;
		(argument) case $line[1] in
				(git-receive-pack) local expl
					_description directories expl 'directory to sync into'
					_directories $expl && ret=0  ;;
				(git-upload-pack|git-upload-archive) local expl
					_description directories expl 'directory to sync from'
					_directories $expl && ret=0  ;;
				(cvs) compadd - server && ret=0  ;;
			esac ;;
	esac
	return ret
}
_git-shortlog () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	local -a revision_options
	__git_setup_revision_options
	_arguments -w -C -S -s '(: -)'{-h,--help}'[print a short usage message and exit]' '(-n --numbered)'{-n,--numbered}'[sort according to number of commits]' '(-s --summary)'{-s,--summary}'[suppress commit description]' '(-e --email)'{-e,--email}'[show email addres of each author]' '-w-[linewrap the output]:: :->wrap' $revision_options '*: :__git_commits' && ret=0 
	case $state in
		(wrap) if [[ -prefix [[:digit:]]#,[[:digit:]]#,[[:digit:]]# ]]
			then
				compset -P '[[:digit:]]#,[[:digit:]]#,'
				__git_guard_number 'indent of second and subsquent wrapped lines'
			elif [[ -prefix [[:digit:]]#,[[:digit:]]# ]]
			then
				compset -P '[[:digit:]]#,'
				compset -S ',[[:digit:]]#'
				__git_guard_number 'indent of first wrapped line'
			else
				compset -S ',[[:digit:]]#,[[:digit:]]#'
				__git_guard_number 'line width'
			fi ;;
	esac
	return ret
}
_git-show () {
	local curcontext=$curcontext state line ret=1
	typeset -A opt_args
	local -a log_options revision_options
	__git_setup_log_options
	__git_setup_revision_options
	_arguments -w -C -s $log_options $revision_options '*:: :->object' && ret=0 
	case $state in
		(object) _alternative 'commits::__git_commits' 'tags::__git_tags' 'trees::__git_trees' 'blobs::__git_blobs' && ret=0  ;;
	esac
	return ret
}
_git-show-branch () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -w -C -S -s -A '-*' '(--more        --merge-base --independent)--list[do not show any ancestry (--more=-1)]' - branches '(-r --remotes -a --all)'{-r,--remotes}'[show remote-tracking branches]' '(-r --remotes -a --all)'{-a,--all}'[show both remote-tracking branches and local branches]' '--current[include current branch to the list of revs]' '(             --date-order)--topo-order[show commits in topological order]' '(--topo-order             )--date-order[show commits in commit-date order]' '--sparse[output merges that are reachable from multiple tips being shown]' '(       --list --merge-base --independent)--more=[go given number of commit beyond common ancestor (no ancestry if negative)]:: :_guard "(-|)[[\:digit\:]]#" limit' '(--more --list              --independent)--merge-base[act like git merge-base -a, but with two heads]' '(--more --list --merge-base              )--independent[show only the reference that can not be reached from any of the other]' '(          --sha1-name)--no-name[do not show naming strings for each commit]' '(--no-name            )--sha1-name[name commits with unique prefix of object names]' '--topics[show only commits that are NOT on the first branch given]' '(        --no-color)--color[color status sign of commits]:: :__git_color_whens' '(--color           )--no-color[do not color statis sign of commits]' '*: :__git_revisions' - reflogs '(-g --reflog)'{-g,--reflog=}'[show reflog entries for given ref]:: :->limit-and-base' ': :__git_references' && ret=0 
	case $state in
		(limit-and-base) if compset -P '[[:digit:]]##,'
			then
				_alternative 'counts::__git_guard_number count' 'dates::__git_datetimes' && ret=0 
			else
				__git_guard_number limit
			fi ;;
	esac
	return ret
}
_git-show-index () {
	_message 'no arguments allowed; accepts index file on standard input'
}
_git-show-ref () {
	_arguments -S - list '(-h --head)'{-h,--head}'[show HEAD reference]' '--tags[show only refs/tags]' '--heads[show only refs/heads]' '(-d --dereference)'{-d,--dereference}'[dereference tags into object IDs as well]' '(-s --hash)'{-s+,--hash=-}'[only show the SHA-1 hash, not the reference name]:: :__git_guard_number length' '--verify[enable stricter reference checking]' '--abbrev=[set minimum SHA1 display-length]: :__git_guard_number length' '(-q --quiet)'{-q,--quiet}'[do not print any results]' '*: :_guard "([^-]?#|)" pattern' - exclude '--exclude-existing=-[filter out existing refs from stdin]:: :_guard "([^-]?#|)" pattern'
}
_git-stash () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C ': :->command' '*:: :->option-or-argument' && ret=0 
	case $state in
		(command) local -a commands
			commands=(save:'save your local modifications to a new stash' list:'list the stashes that you currently have' show:'show the changes recorded in the stash as a diff' pop:'remove and apply a single stashed state from the stash list' apply:'apply the changes recorded in the stash' branch:'branch off at the commit at which the stash was originally created' clear:'remove all the stashed states' drop:'remove a single stashed state from the stash list' create:'create a stash without storing it in the ref namespace') 
			_describe -t commands command commands && ret=0  ;;
		(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
			case $line[1] in
				(save) _arguments -S '(--keep-index)--patch[interactively select hunks from diff between HEAD and working tree to stash]' '(             --no-keep-index)--keep-index[all changes already added to the index are left intact]' '(--keep-index                )--no-keep-index[all changes already added to the index are undone]' '(-q --quiet)'{-q,--quiet}'[suppress all output]' '::message' && ret=0  ;;
				(list) local -a log_options revision_options
					__git_setup_log_options
					__git_setup_revision_options
					_arguments -s -w $log_options $revision_options && ret=0  ;;
				(show) local diff_options
					__git_setup_diff_options
					_arguments -S -s -w $diff_options ':: :__git_stashes' && ret=0  ;;
				(pop|apply) _arguments '--index[try to reinstate the changes added to the index as well]' '(-q --quiet)'{-q,--quiet}'[suppress all output]' ':: :__git_stashes' && ret=0  ;;
				(branch) _arguments ': :__git_guard_branch-name' ':: :__git_stashes' && ret=0  ;;
				(clear) _nothing ;;
				(drop) _arguments '(-q --quiet)'{-q,--quiet}'[suppress all output]' ':: :__git_stashes' && ret=0  ;;
				(create) _nothing ;;
				(*) _nothing ;;
			esac ;;
	esac
	return ret
}
_git-status () {
	local -a branch_opts
	if (( $words[(I)-s|--short] ))
	then
		branch_opts=('(-b --branch)'{-b,--branch}'[show branch and tracking info]') 
	fi
	_arguments -w -S -s '(-s --short)'{-s,--short}'[output in short format]' $branch_opts '(-s --short)--porcelain[produce machine-readable output]' '(-u --untracked-files)'{-u-,--untracked-files=-}'[show untracked files]::mode:((no\:"show no untracked files" \
                                                                                     normal\:"show untracked files and directories" \
                                                                                     all\:"also show untracked files in untracked directories (default)"))' '--ignore-submodules[ignore changes to submodules]:: :__git_ignore_submodules_whens' '(--porcelain)-z[use NUL termination on output]' '*: :__git_ignore_line_inside_arguments _files'
}
_git-stripspace () {
	_arguments '(-s --strip-comments)'{-s,--strip-comments}'[also strip lines starting with #]'
}
_git-submodule () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C -A '-*' '(-q --quiet)'{-q,--quiet}'[suppress all output]' ': :->command' '*:: :->option-or-argument' && ret=0 
	case $state in
		(command) declare -a commands
			commands=(add:'add given repository as a submodule' status:'show the status of a submodule' init:'initialize a submodule' update:'update a submodule' summary:'show commit summary between given commit and working tree/index' foreach:'evaluate shell command in each checked-out submodule' sync:'synchronize submodule settings') 
			_describe -t commands command commands && ret=0  ;;
		(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
			case $line[1] in
				(add) _arguments -S '(-q --quiet)'{-q,--quiet}'[suppress all output]' '(-b --branch)'{-b,--branch}'[branch of repository to add as submodule]' '(-f --force)'{-f,--force}'[allow adding an otherwise ignored submodule path]' '--reference=[remote repository to clone]: :__git_any_repositories' ': :__git_any_repositories' ':: :_directories' && ret=0  ;;
				(status) _arguments -S '(-q --quiet)'{-q,--quiet}'[suppress all output]' '--cached[use commit stored in the index]' '--recursive[traverse submodules recursively]' '*: :__git_ignore_line_inside_arguments __git_submodules' && ret=0  ;;
				(init) _arguments -S '(-q --quiet)'{-q,--quiet}'[suppress all output]' '*: :__git_ignore_line_inside_arguments __git_submodules' && ret=0  ;;
				(update) _arguments -S '(-q --quiet)'{-q,--quiet}'[suppress all output]' '(-N --no-fetch)'{-N,--no-fetch}'[do not fetch new objects from repository]' '--merge[merge commit recorded in superproject into current branch of submodule]' '--rebase[rebase current branch onto commit recorded in superproject]' '--reference=[remote repository to clone]: :__git_any_repositories' '--recursive[traverse submodules recursively]' '--init[initialize uninitialized submodules]' '*: :__git_ignore_line_inside_arguments __git_submodules' && ret=0  ;;
				(summary) _arguments -C -A '-*' '(-q --quiet)'{-q,--quiet}'[suppress all output]' '--cached[use commit stored in the index]' '--files[compare commit in index with submodule HEAD commit]' '(-n --summary-limit)'{-n,--summary-limit}'[limit summary size]: :__git_guard_number "limit"' '(-)--[start submodule arguments]' '*:: :->commit-or-submodule' && ret=0 
					case $state in
						(commit-or-submodule) if (( CURRENT == 1 )) && [[ -z ${opt_args[(I)--]} ]]
							then
								_alternative 'commits::__git_commits' 'submodules::__git_submodules' && ret=0 
							else
								__git_ignore_line __git_submodules && ret=0 
							fi ;;
					esac ;;
				(foreach) _arguments -S '(-q --quiet)'{-q,--quiet}'[suppress all output]' '--recursive[traverse submodules recursively]' '(-):command: _command_names -e' '*::arguments: _normal' && ret=0  ;;
				(sync) _arguments -S '(-q --quiet)'{-q,--quiet}'[suppress all output]' '*: :__git_ignore_line_inside_arguments __git_submodules' && ret=0  ;;
				(*) _nothing ;;
			esac ;;
	esac
	return ret
}
_git-svn () {
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C '(- :)'{-V,--version}'[display version information]' '(- :)'{-h,-H,--help}'[display usage information]' ': :->command' '*:: :->option-or-argument' && ret=0 
	case $state in
		(command) declare -a commands
			commands=(init:'initialize an empty git repository with additional svn data' fetch:'fetch revisions from the SVN remote' clone:'same as init, followed by fetch' rebase:'fetch revs from SVN parent of HEAD and rebase current work on it' dcommit:'commit diffs from given head onto SVN repository' branch:'create a branch in the SVN repository' tag:'create a tag in the SVN repository' log:'output SVN log-messages' blame:'show what revision and author last modified each line of a file' find-rev:'output git commit corresponding to the given SVN revision'\''s hash' set-tree:'commit given commit or tree to SVN repository' create-ignore:'recursively finds the svn:ignore property and creates .gitignore files' show-ignore:'output corresponding toplevel .gitignore file of svn:ignore' mkdirs:'recreate empty directories that Git cannot track' commit-diff:'commit diff of two tree-ishs' info:'show information about a file or directory' proplist:'list the SVN properties stored for a file or directory' propget:'get a given SVN property for a file' show-externals:'show the subversion externals' gc:'compress git-svn-related information' reset:'undo effect of fetch back to specific revision') 
			_describe -t commands command commands && ret=0  ;;
		(option-or-argument) curcontext=${curcontext%:*}-$line[1]: 
			declare -a remote_opts fc_opts init_opts cmt_opts opts
			remote_opts=('--username=[username to use for SVN transport]: :_users' '--ignore-paths[regular expression of paths to not check out]:pattern' '--no-auth-cache[undocumented]' '--config-dir=[undocumented]:configuration directory:_directories') 
			fc_opts=('--localtime[store Git commit times in local timezone]' '--use-log-author[use author from the first From: or Signed-Off-By: line, when fetching into git]' '--add-author-from[when committing to svn, append a From: line based on the git commit'\''s author string]' '(                --no-follow-parent)--follow-parent[follow parent commit]' '(--follow-parent                   )--no-follow-parent[do not follow parent commit]' '(-A --authors-file)'{-A,--authors-file}'[specify author-conversion file]:author-conversion file:_files' '--authors-prog=[program used to generate authors]: :_path_commands' '(-q --quiet)'{-q,--quiet}'[make git-svn less verbose]' '--repack=[repack files (for given number of revisions)]:: :__git_guard_number "revision limit"' '(--repack-flags --repack-args --repack-opts)'{--repack-flags=,--repack-args=,--repack-opts=}'[flags to pass to git-repack]:git-repack flags' '--noMetadata[undocumented]' '--useSvmProps[undocumented]' '--useSvnsyncProps[undocumented]' '--log-window-size=[undocumented]' '--no-checkout[undocumented]' $remote_opts) 
			init_opts=('(-T --trunk)'{-T-,--trunk=}'[set trunk sub-directory]:trunk sub-directory:->subdirectory' '(-t --tags)*'{-t-,--tags=}'[add tags sub-directory]:tags sub-directory:->subdirectory' '(-b --branches)*'{-b-,--branches=}'[add branches sub-directory]:branches sub-directory:->subdirectory' '(-s --stdlayout)'{-s,--stdlayout}'[shorthand for setting trunk, tags, branches as relative paths, the SVN default]' '--no-metadata[set svn-remote.*.noMetadata]' '--use-svm-props[set svn-remote.*.useSvmProps]' '--use-svnsync-props[set svn-remote.*.useSvnsyncProps]' '--rewrite-root=[set svn-remote.*.rewriteRoot]:new root:_urls' '--rewrite-uuid=[set svn-remote.*.rewriteUUID]:uuid' '--prefix=[prefix to use for names of remotes]:path prefix:_directories -r ""' '(               --no-minimize-url)--minimize-url[minimize URLs]' '(--minimize-url                  )--no-minimize-url[do not minimize URLs]' '--shared=[share repository amongst several users]:: :__git_repository_permissions' '--template=[directory to use as a template for the object database]: :_directories' $remote_opts) 
			cmt_opts=('--rmdir[remove empty directories from SVN tree after commit]' '(-e --edit)'{-e,--edit}'[edit commit message before committing]' '-l-[limit number of rename/copy targets to run]: :__git_guard_number' '--find-copies-harder[try harder to find copies]' '(-C --copy-similarity)'{-C-,--copy-similarity=}'[undocumented]: :_guard "[[\:digit:\]]#" number') 
			if [[ $line[1] = (fetch|clone) ]]
			then
				arguments+=('(-r --revision)'{-r,--revision}'[only fetch given revision or revision range]: :__git_svn_revisions' ':: :__git_svn-remotes') 
			fi
			if [[ $line[1] = (fetch|rebase|dcommit) ]]
			then
				opts+=('(--fetch-all --all)'{--fetch-all,--all}'[undocumented]') 
			fi
			if [[ $line[1] = (rebase|dcommit) ]]
			then
				opts+=('(-m --merge)'{-m,--merge}'[use merging strategies, if necessary]' '*'{-s,--strategy=-}'[use given merge strategy]:merge strategy:__git_merge_strategies') 
			fi
			if [[ $line[1] = (rebase|dcommit|branch) ]]
			then
				opts+=('(-n --dry-run)'{-n,--dry-run}'[only display what would be done]') 
			fi
			if [[ $line[1] = (rebase|dcommit|log) ]]
			then
				opts+=('(-v --verbose)'{-v,--verbose}'[display extra information]') 
			fi
			case $line[1] in
				(init) opts+=($init_opts)  ;;
				(fetch) opts+=('--parent[fetch only from SVN parent of current HEAD]' $fc_opts)  ;;
				(clone) opts+=($init_opts $fc_opts ':url:_urls' '::directory:_directories')  ;;
				(rebase) opts+=('--local[do not fetch remotely, rebase against the last fetched commit from SVN]' $fc_opts)  ;;
				(dcommit) arguments+=('--no-rebase[do not rebase or reset after committing]' '--commit-url[commit to a different SVN url]:SVN URL:_url' $fc_opts $cmt_opts)  ;;
				(branch|tag) opts+=('(-m --message)'{-m,--message}'[specify the commit message]:message' '(-d --destination)'{-d,--destination}'[location of branch or tag to create in SVN repository]: :_directories' '--username[specify SVN username to perform commit as]: :_users' '--commit-url[specify URL to connect to destination SVN repository]: :_urls') 
					if [[ $line[1] != tag ]]
					then
						opts+=('(-t --tag)'{-t,--tag}'[create a tag]') 
					fi ;;
				(log) declare -a revision_options
					__git_setup_revision_options
					opts+=($revision_options '(-r --revision)'{-r-,--revision=}'[revisions to output log information for]: :__git_svn_revision_numbers' '--limit=[like --max-count, but not counting merged/excluded commits]: :__git_guard_number limit' '--incremental[give output suitable for concatenation]' '--show-commit[output git commit SHA-1, as well]' '--color[undocumented]' '--pager[undocumented]:pager:_path_commands' '--non-recursive[undocumented]')  ;;
				(blame) opts+=('--git-format[produce output in git-blame format, with SVN revision numbers instead of git commit hashes]')  ;;
				(set-tree) opts+=('--stdin[read list of commits to commit from stdin]')  ;;
				(create-ignore|show-ignore|mkdirs|proplist|propget|show-externals) opts+=('(-r --revision)'{-r,--revision}'[specify SVN revision]: :__git_svn_revisions')  ;;
				(commit-diff) opts+=('(-m --message)'{-m-,--message=}'[undocumented]:message' '(-F --file)'{-F-,--file=}'[undocumented]: :_files' '(-r --revision)'{-r-,--revision=}'[undocumented]: :__git_svn_revisions')  ;;
				(info) opts+=('--url[output only value of URL field]')  ;;
				(reset) opts+=('(-r --revision)'{-r,--revision}'[specify most recent SVN revision to keep]: :__git_svn_revisions' '(-p --parent)'{-p,--parent}'[discard specified revision as well, keeping nearest parent instead]')  ;;
			esac
			_arguments -w -C -S -s '(-h -H --help)'{-h,-H,--help}'[display usage information]' '(-V --version)'{-V,--version}'[display version information]' '--minimize-connections[undocumented]' '(-R --svn-remote --remote)'{-R,--svn-remote,--remote}'[svn remote to use]:svn remote:__git_svn-remotes' '(-i --id)'{-i,--id}'[set GIT_SVN_ID]:GIT_SVN_ID' $opts && ret=0 
			case $state in
				(subdirectory) _alternative 'sub-directories:sub-directory:_directories' 'urls: :_urls' && ret=0  ;;
			esac ;;
	esac
	return ret
}
_git-symbolic-ref () {
	_arguments -w -S -s '(-q --quiet)'{-q,--quiet}'[do not issue error if specified name is not a symbolic ref]' '-m[update reflog for specified name with specied reason]:reason for update' ':symbolic reference:__git_heads' ':: :__git_references'
}
_git-tag () {
	local -a message_opts
	if (( words[(I)-[asu]] ))
	then
		message_opts=('(   -F)-m+[specify tag message]:message' '(-m   )-F+[read tag message from given file]:message file:_files') 
	fi
	_arguments -A '-*' - creation '(   -s -u)-a[create an unsigned, annotated tag]' '(-a    -u)-s[create an signed and annotated tag]' '(-a -s   )-u[create a tag, annotated and signed with the given key]: :__git_gpg_secret_keys' '-f[replace existing tag]' $message_opts ': :__git_tags' ':: :__git_commits' - deletion '-d[delete tags]' '*:: :__git_ignore_line_inside_arguments __git_tags' - listing '-n+[limit line output of annotation]: :__git_guard_number "limit"' '-l[list tags matching pattern]' '--contains=[only list tags which contain the specified commit]: :__git_commits' '::pattern' - verification '-v[verifies gpg signutare of tags]' '*:: :__git_ignore_line_inside_arguments __git_tags'
}
_git-unpack-file () {
	_arguments -A '-*' '(:)-h[display usage information]' '(-): :__git_blobs'
}
_git-unpack-objects () {
	_arguments '-n[only list the objects that would be unpacked]' '-q[run quietly]' '-r[try recovering objects from corrupt packs]' '--strict[do not write objects with broken content or links]'
}
_git-update-index () {
	local z_opt
	if (( words[(I)--stdin|--index-info] ))
	then
		z_opt='-z[paths are separated with NUL character when reading from stdin]' 
	fi
	_arguments -S $refreshables '(-)'{-h,--help}'[display usage information]' '--add[add files not already in index]' '(         --force-remove)--remove[remove files that are in the index but are missing from the work tree]' '(--remove               )--force-remove[remove files from both work tree and index]' '(-q --unmerged --ignore-missing --really-refresh)--refresh[refresh index]' '-q[run quietly]' '--ignore-submodules[do not try to update submodules]' '--unmerged[if unmerged changes exists, ignore them instead of exiting]' '--ignore-missing[ignore missing files when refreshing the index]' '*--cacheinfo[insert information directly into the cache]: :_guard "[0-7]#" "octal file mode": :_guard "[[\:xdigit\:]]#" "object id": :_files' '(: -)--index-info[read index information from stdin]' '--chmod=-[set execute permissions on updated files]:permission:((-x\:executable +x\:"not executable"))' '(                   --no-assume-unchanged)--assume-unchanged[set "assume unchanged" bit for given paths]' '(--assume-unchanged                      )--no-assume-unchanged[unset "assume unchanged" bit for given paths]' '(-q --unmerged --ignore-missing --refresh)--really-refresh[refresh index, unconditionally checking stat information]' '(                --no-skip-worktree)--skip-worktree[set "skip-worktree" bit for given paths]' '(--skip-worktree                   )--no-skip-worktree[unset "skip-worktree" bit for given paths]' '(-)'{-g,--again}'[run git-update-index on differing index entries]' '(-)--unresolve[restore "unmerged" or "needs updating" state of files]' '--info-only[only insert files object-IDs into index]' '(--remove)--force-remove[remove file from index even when working directory has no such file]' '--replace[replace files already in index, if necessary]' '(: -)--stdin[read list of paths from standard input]' '--verbose[report what is being added and removed from the index]' $z_opt '*:: :_files'
}
_git-update-ref () {
	_arguments -w -S -s '-m[update reflog for specified name with specied reason]:reason for update' '(:)-d[delete given reference after verifying its value]:symbolic reference:__git_revisions:old reference:__git_revisions' '--no-deref[overwrite ref itself, not what it points to]' ':symbolic reference:__git_revisions' ':new reference:__git_revisions' '::old reference:__git_revisions'
}
_git-update-server-info () {
	_arguments -w -S -s '(-f --force)'{-f,--force}'[update the info files from scratch]'
}
_git-upload-archive () {
	_arguments ':directory to get tar archive from:_directories'
}
_git-upload-pack () {
	_arguments -S -A '-*' '--strict[do not try <directory>/.git/ if <directory> is not a git directory' '--timeout=-[interrupt transfer after given number of seconds of inactivity]: :__git_guard_number "inactivity timeout"' '--advertise-refs[undocumented]' '--stateless-rpc[undocumented]' ': :_directories'
}
_git-var () {
	_arguments '(:)-l[show logical variables]' '(-):variable:((GIT_AUTHOR_IDENT\:"name and email of author" \
                    GIT_COMMITTER_IDENT\:"name and email of committer" \
                    GIT_EDITOR\:"text editor used by git commands" \
                    GIT_PAGER\:"text viewer used by git commands"))'
}
_git-verify-pack () {
	_arguments -w -S -s '(-v --verbose)'{-v,--verbose}'[show objects contained in pack]' '(-s --stat-only)'{-s,--stat-only}'[do not verify pack contents; only display histogram of delta chain length]' '*:index file:_files -g "*.idx"'
}
_git-verify-tag () {
	_arguments -w -S -s '(-v --verbose)'{-v,--verbose}'[output additional information]' '*: :__git_tags'
}
_git-whatchanged () {
	local -a revision_options
	__git_setup_revision_options
	_arguments -S $revision_options '1:: :__git_commits' '*: :__git_cached_files'
}
_git-write-tree () {
	_arguments -w -S -s '--missing-ok[ignore objects in index that are missing in object database]' '--prefix=[write tree representing given sub-directory]:sub-directory:_directories -r ""'
}
_git_commands () {
	local -a main_porcelain_commands
	main_porcelain_commands=(add:'add file contents to index' am:'apply patches from a mailbox' archive:'create archive of files from named tree' bisect:'find, by binary search, change that introduced a bug' branch:'list, create, or delete branches' bundle:'move objects and refs by archive' checkout:'checkout branch or paths to working tree' cherry-pick:'apply changes introduced by some existing commits' citool:'graphical alternative to git commit' clean:'remove untracked files from working tree' clone:'clone repository into new directory' commit:'record changes to repository' describe:'show most recent tag that is reachable from a commit' diff:'show changes between commits, commit and working tree, etc.' fetch:'download objects and refs from another repository' format-patch:'prepare patches for e-mail submission' gc:'cleanup unnecessary files and optimize local repository' grep:'print lines matching a pattern' gui:'run portable graphical interface to git' init:'create empty git repository or re-initialize an existing one' log:'show commit logs' merge:'join two or more development histories together' mv:'move or rename file, directory, or symlink' notes:'add or inspect object notes' pull:'fetch from and merge with another repository or local branch' push:'update remote refs along with associated objects' rebase:'fasforward-port local commits to the updated upstream head' reset:'reset current HEAD to specified state' revert:'revert existing commits' rm:'remove files from the working tree and from the index' shortlog:'summarize git log output' show:'show various types of objects' stash:'stash away changes to dirty working directory' status:'show working-tree status' submodule:'initialize, update, or inspect submodules' tag:'create, list, delete or verify tag object signed with GPG') 
	local -a ancillary_manipulator_commands
	ancillary_manipulator_commands=(config:'get and set repository or global options' fast-export:'data exporter' fast-import:'import information into git directly' filter-branch:'rewrite branchers' mergetool:'run merge conflict resolution tools to resolve merge conflicts' pack-refs:'pack heads and tags for efficient repository access' prune:'prune all unreachable objects from the object database' reflog:'manage reflog information' relink:'hardlink common objects in local repositories' remote:'manage set of tracked repositories' repack:'pack unpacked objects in a repository' replace:'create, list, delete refs to replace objects') 
	local -a ancillary_interrogator_commands
	ancillary_interrogator_commands=(blame:'show what revision and author last modified each line of a file' cherry:'find commits not merged upstream' count-objects:'count unpacked objects and display their disk consumption' difftool:'show changes using common diff tools' fsck:'verify connectivity and validity of objects in database' get-tar-commit-id:'extract commit ID from an archive created using git archive' help:'display help information about git' instaweb:'instantly browse your working repository in gitweb' merge-tree:'show three-way merge without touching index' rerere:'reuse recorded resolution of conflicted merges' rev-parse:'pick out and massage parameters for other git commands' show-branch:'show branches and their commits' verify-tag:'check GPG signature of tags' whatchanged:'show commit-logs and differences they introduce') 
	local -a interaction_commands
	interaction_commands=(archimport:'import an Arch repository into git' cvsexportcommit:'export a single commit to a CVS checkout' cvsimport:'import a CVS "repository" into a git repository' cvsserver:'run a CVS server emulator for git' imap-send:'send a collection of patches to an IMAP folder' quiltimport:'apply a quilt patchset' request-pull:'generate summary of pending changes' send-email:'send collection of patches as emails' svn:'bidirectional operation between a Subversion repository and git') 
	local -a plumbing_manipulator_commands
	plumbing_manipulator_commands=(apply:'apply patch to files and/or to index' checkout-index:'copy files from index to working directory' commit-tree:'create new commit object' hash-object:'compute object ID and optionally create a blob from a file' index-pack:'build pack index file for an existing packed archive' merge-file:'run a three-way file merge' merge-index:'run merge for files needing merging' mktag:'create tag object' mktree:'build tree-object from git ls-tree formatted text' pack-objects:'create packed archive of objects' prune-packed:'remove extra objects that are already in pack files' read-tree:'read tree information into directory index' symbolic-ref:'read and modify symbolic references' unpack-objects:'unpack objects from packed archive' update-index:'register file contents in the working directory to the index' update-ref:'update object name stored in a reference safely' write-tree:'create tree from the current index') 
	local -a plumbing_interrogator_commands
	plumbing_interrogator_commands=(cat-file:'provide content or type information for repository objects' diff-files:'compare files in working tree and index' diff-index:'compare content and mode of blobs between index and repository' diff-tree:'compare content and mode of blobs found via two tree objects' for-each-ref:'output information on each ref' ls-files:'information about files in index/working directory' ls-remote:'show references in a remote repository' ls-tree:'list contents of a tree object' merge-base:'find as good a common ancestor as possible for a merge' name-rev:'find symbolic names for given revisions' pack-redundant:'find redundant pack files' rev-list:'list commit object in reverse chronological order' show-index:'show packed archive index' show-ref:'list references in a local repository' unpack-file:'create temporary file with blob'\''s contents' var:'show git logical variable' verify-pack:'validate packed git archive files') 
	local -a plumbing_sync_commands
	plumbing_sync_commands=(daemon:'run a really simple server for git repositories' fetch-pack:'receive missing objects from another repository' http-backend:'run a server side implementation of Git over HTTP' send-pack:'push objects over git protocol to another repository' update-server-info:'update auxiliary information file to help dumb servers') 
	local -a plumbing_sync_helper_commands
	plumbing_sync_helper_commands=(http-fetch:'download from remote git repository via HTTP' http-push:'push objects over HTTP/DAV to another repository' parse-remote:'routines to help parsing remote repository access parameters' receive-pack:'receive what is pushed into repository' shell:'restricted login shell for GIT-only SSH access' upload-archive:'send archive back to git-archive' upload-pack:'send objects packed back to git fetch-pack') 
	local -a plumbing_internal_helper_commands
	plumbing_internal_helper_commands=(check-attr:'display gitattributes information' check-ref-format:'ensure that a reference name is well formed' fmt-merge-msg:'produce merge commit message' mailinfo:'extract patch and authorship from a single email message' mailsplit:'split mbox file into a list of files' merge-one-file:'standard helper-program to use with git merge-index' patch-id:'compute unique ID for a patch' stripspace:'filter out empty lines') 
	local -a user_commands
	zstyle -a :completion:$curcontext: user-commands user_commands
	local -a third_party_commands
	local command
	for command in $_git_third_party_commands
	do
		(( $+commands[git-${command%%:*}] )) && third_party_commands+=$command 
	done
	local -a aliases unique_aliases
	__git_extract_aliases
	local alias
	for alias in $aliases
	do
		local name=${alias%%:*}
		(( main_porcelain_commands[(I)$name:*] ||
       user_commands[(I)$name:*] ||
       third_party_commands[(I)$name:*] ||
       ancillary_manipulator_commands[(I)$name:*] ||
       ancillary_interrogator_commands[(I)$name:*] ||
       interaction_commands[(I)$name:*] ||
       plumbing_manipulator_commands[(I)$name:*] ||
       plumbing_interrogator_commands[(I)$name:*] ||
       plumbing_sync_commands[(I)$name:*] ||
       plumbing_sync_helper_commands[(I)$name:*] ||
       plumbing_internal_helper_commands[(I)$name:*] )) || unique_aliases+=$alias 
	done
	integer ret=1
	_describe -t aliases alias unique_aliases && ret=0 
	_describe -t main-porcelain-commands 'main porcelain command' main_porcelain_commands && ret=0 
	_describe -t user-commands 'user command' user_commands && ret=0 
	_describe -t third-party-commands 'third-party command' third_party_commands && ret=0 
	_describe -t ancillary-manipulator-commands 'ancillary manipulator command' ancillary_manipulator_commands && ret=0 
	_describe -t ancillary-interrogator-commands 'ancillary interrogator command' ancillary_interrogator_commands && ret=0 
	_describe -t interaction-commands 'interaction command' interaction_commands && ret=0 
	_describe -t plumbing-manipulator-commands 'plumbing manipulator command' plumbing_manipulator_commands && ret=0 
	_describe -t plumbing-interrogator-commands 'plumbing interrogator command' plumbing_interrogator_commands && ret=0 
	_describe -t plumbing-sync-commands 'plumbing sync command' plumbing_sync_commands && ret=0 
	_describe -t plumbing-sync-helper-commands 'plumbing sync helper command' plumbing_sync_helper_commands && ret=0 
	_describe -t plumbing-internal-helper-commands 'plumbing internal helper command' plumbing_internal_helper_commands && ret=0 
	return ret
}
_git_log_prettily () {
	if ! [ -z $1 ]
	then
		git log --pretty=$1
	fi
}
_gitk () {
	_git-log
}
_global () {
	# undefined
	builtin autoload -XUz
}
_global_tags () {
	# undefined
	builtin autoload -XUz
}
_globflags () {
	# undefined
	builtin autoload -XUz
}
_globqual_delims () {
	# undefined
	builtin autoload -XUz
}
_globquals () {
	# undefined
	builtin autoload -XUz
}
_gnome-gv () {
	# undefined
	builtin autoload -XUz
}
_gnu_generic () {
	# undefined
	builtin autoload -XUz
}
_gnupod () {
	# undefined
	builtin autoload -XUz
}
_gnutls () {
	# undefined
	builtin autoload -XUz
}
_go () {
	# undefined
	builtin autoload -XUz
}
_gpg () {
	# undefined
	builtin autoload -XUz
}
_gphoto2 () {
	# undefined
	builtin autoload -XUz
}
_gprof () {
	# undefined
	builtin autoload -XUz
}
_gqview () {
	# undefined
	builtin autoload -XUz
}
_gradle () {
	# undefined
	builtin autoload -XUz
}
_graphicsmagick () {
	# undefined
	builtin autoload -XUz
}
_grep () {
	# undefined
	builtin autoload -XUz
}
_grep-excuses () {
	# undefined
	builtin autoload -XUz
}
_groff () {
	# undefined
	builtin autoload -XUz
}
_groups () {
	# undefined
	builtin autoload -XUz
}
_growisofs () {
	# undefined
	builtin autoload -XUz
}
_gs () {
	# undefined
	builtin autoload -XUz
}
_guard () {
	local garbage
	zparseopts -K -D -a garbage M: J: V: 1 2 n F: X:
	[[ "$PREFIX$SUFFIX" != $~1 ]] && return 1
	shift
	_message -e "$*"
	[[ -n "$PREFIX$SUFFIX" ]]
}
_guilt () {
	# undefined
	builtin autoload -XUz
}
_gv () {
	# undefined
	builtin autoload -XUz
}
_gzip () {
	# undefined
	builtin autoload -XUz
}
_hash () {
	# undefined
	builtin autoload -XUz
}
_have_glob_qual () {
	local complete
	[[ $2 = complete ]] && complete=")" 
	[[ -z $compstate[quote] && ( ( $_comp_caller_options[bareglobqual] = on && $1 = (#b)(((*[^\\\$]|)(\\\\)#)\()([^\)\|\~]#)$complete && ${#match[1]} -gt 1 ) || ( $_comp_caller_options[extendedglob] = on && $1 = (#b)(((*[^\\\$]|)(\\\\)#)"(#q")([^\)]#)$complete ) ) ]]
}
_hdiutil () {
	# undefined
	builtin autoload -XUz
}
_hg () {
	# undefined
	builtin autoload -XUz
}
_history () {
	# undefined
	builtin autoload -XUz
}
_history_complete_word () {
	# undefined
	builtin autoload -XUz
}
_history_modifiers () {
	# undefined
	builtin autoload -XUz
}
_hosts () {
	# undefined
	builtin autoload -XUz
}
_hwinfo () {
	# undefined
	builtin autoload -XUz
}
_iconv () {
	# undefined
	builtin autoload -XUz
}
_id () {
	# undefined
	builtin autoload -XUz
}
_ifconfig () {
	# undefined
	builtin autoload -XUz
}
_iftop () {
	# undefined
	builtin autoload -XUz
}
_ignored () {
	[[ _matcher_num -gt 1 || $compstate[ignored] -eq 0 ]] && return 1
	local comp
	integer ind
	if ! zstyle -a ":completion:${curcontext}:" completer comp
	then
		comp=("${(@)_completers[1,_completer_num-1]}") 
		ind=${comp[(I)_ignored(|:*)]} 
		(( ind )) && comp=("${(@)comp[ind,-1]}") 
	fi
	local _comp_no_ignore=yes tmp expl _completer _completer_num _matcher _c_matcher _matchers _matcher_num
	_completer_num=1 
	for tmp in "$comp[@]"
	do
		if [[ "$tmp" = *:-* ]]
		then
			_completer="${${tmp%:*}[2,-1]//_/-}${tmp#*:}" 
			tmp="${tmp%:*}" 
		elif [[ $tmp = *:* ]]
		then
			_completer="${tmp#*:}" 
			tmp="${tmp%:*}" 
		else
			_completer="${tmp[2,-1]//_/-}" 
		fi
		curcontext="${curcontext/:[^:]#:/:${_completer}:}" 
		zstyle -a ":completion:${curcontext}:" matcher-list _matchers || _matchers=('') 
		_matcher_num=1 
		_matcher='' 
		for _c_matcher in "$_matchers[@]"
		do
			if [[ "$_c_matcher" = +* ]]
			then
				_matcher="$_matcher $_c_matcher[2,-1]" 
			else
				_matcher="$_c_matcher" 
			fi
			if [[ "$tmp" != _ignored ]] && "$tmp"
			then
				if zstyle -s ":completion:${curcontext}:" single-ignored tmp && [[ $compstate[old_list] != shown && $compstate[nmatches] -eq 1 ]]
				then
					case "$tmp" in
						(show) compstate[insert]='' compstate[list]='list force' tmp=''  ;;
						(menu) compstate[insert]=menu 
							_description original expl original
							compadd "$expl[@]" -S '' - "$PREFIX$SUFFIX" ;;
					esac
				fi
				return 0
			fi
			(( _matcher_num++ ))
		done
		(( _completer_num++ ))
	done
	return 1
}
_imagemagick () {
	# undefined
	builtin autoload -XUz
}
_in_vared () {
	# undefined
	builtin autoload -XUz
}
_inetadm () {
	# undefined
	builtin autoload -XUz
}
_init_d () {
	# undefined
	builtin autoload -XUz
}
_initctl () {
	# undefined
	builtin autoload -XUz
}
_invoke-rc.d () {
	# undefined
	builtin autoload -XUz
}
_ionice () {
	# undefined
	builtin autoload -XUz
}
_ip () {
	# undefined
	builtin autoload -XUz
}
_ipadm () {
	# undefined
	builtin autoload -XUz
}
_ipset () {
	# undefined
	builtin autoload -XUz
}
_iptables () {
	# undefined
	builtin autoload -XUz
}
_irssi () {
	# undefined
	builtin autoload -XUz
}
_ispell () {
	# undefined
	builtin autoload -XUz
}
_iwconfig () {
	# undefined
	builtin autoload -XUz
}
_java () {
	# undefined
	builtin autoload -XUz
}
_java_class () {
	# undefined
	builtin autoload -XUz
}
_jobs () {
	# undefined
	builtin autoload -XUz
}
_jobs_bg () {
	# undefined
	builtin autoload -XUz
}
_jobs_builtin () {
	# undefined
	builtin autoload -XUz
}
_jobs_fg () {
	# undefined
	builtin autoload -XUz
}
_joe () {
	# undefined
	builtin autoload -XUz
}
_join () {
	# undefined
	builtin autoload -XUz
}
_kfmclient () {
	# undefined
	builtin autoload -XUz
}
_kill () {
	# undefined
	builtin autoload -XUz
}
_killall () {
	# undefined
	builtin autoload -XUz
}
_kld () {
	# undefined
	builtin autoload -XUz
}
_knock () {
	# undefined
	builtin autoload -XUz
}
_kvno () {
	# undefined
	builtin autoload -XUz
}
_last () {
	# undefined
	builtin autoload -XUz
}
_ldd () {
	# undefined
	builtin autoload -XUz
}
_less () {
	# undefined
	builtin autoload -XUz
}
_lha () {
	# undefined
	builtin autoload -XUz
}
_lighttpd () {
	# undefined
	builtin autoload -XUz
}
_limit () {
	# undefined
	builtin autoload -XUz
}
_limits () {
	# undefined
	builtin autoload -XUz
}
_linda () {
	# undefined
	builtin autoload -XUz
}
_links () {
	# undefined
	builtin autoload -XUz
}
_lintian () {
	# undefined
	builtin autoload -XUz
}
_list () {
	# undefined
	builtin autoload -XUz
}
_list_files () {
	local stat f elt what dir
	local -a stylevals
	integer ok
	listfiles=() 
	listopts=() 
	zstyle -a ":completion:${curcontext}:" file-list stylevals || return 1
	case $WIDGETSTYLE in
		(*complete*) what=insert  ;;
		(*) what=list  ;;
	esac
	for elt in $stylevals
	do
		case $elt in
			(*($what|all|true|1|yes)*=<->) (( ${(P)#1} <= ${elt##*=} )) && (( ok = 1 ))
				break ;;
			(*($what|all|true|1|yes)[^=]#) (( ok = 1 ))
				break ;;
		esac
	done
	(( ok )) || return 1
	zmodload -F zsh/stat b:zstat 2> /dev/null || return 1
	dir=${2:+$2/} 
	dir=${(Q)dir} 
	for f in ${(PQ)1}
	do
		if [[ ! -e "$dir$f" ]]
		then
			listfiles+=("$dir$f") 
			continue
		fi
		zstat -s -H stat -F "%b %e %H:%M" - "$dir$f" > /dev/null 2>&1
		listfiles+=("$stat[mode] ${(l:3:)stat[nlink]} ${(r:8:)stat[uid]}  ${(r:8:)stat[gid]} ${(l:8:)stat[size]} $stat[mtime] $f") 
	done
	(( ${#listfiles} )) && listopts=(-d listfiles -l -o) 
	return 0
}
_ln () {
	# undefined
	builtin autoload -XUz
}
_loadkeys () {
	# undefined
	builtin autoload -XUz
}
_locales () {
	# undefined
	builtin autoload -XUz
}
_locate () {
	# undefined
	builtin autoload -XUz
}
_logical_volumes () {
	# undefined
	builtin autoload -XUz
}
_look () {
	# undefined
	builtin autoload -XUz
}
_losetup () {
	# undefined
	builtin autoload -XUz
}
_lp () {
	# undefined
	builtin autoload -XUz
}
_ls () {
	local arguments is_gnu
	_pick_variant -r is_gnu gnu=gnu unix --help
	if [[ "$OSTYPE" = (netbsd*|freebsd*|openbsd*|darwin*) && "$is_gnu" != gnu ]]
	then
		arguments=('(-A)-a[list entries starting with .]' '(-a)-A[list all except . and ..]' '-d[list directory entries instead of contents]' '-L[list referenced file for sym link]' '-R[list subdirectories recursively]' '(-k)-h[print sizes in human readable form]' '(-h)-k[print sizes of 1k]' '-i[print file inode numbers]' '(-l -g -1 -C -m -x)-l[long listing]' '(-l -1 -C -m -x)-g[long listing but without owner information]' '(-l -g -C -m -x)-1[single column output]' '(-l -g -1 -m -x)-C[list entries in columns sorted vertically]' '(-l -g -1 -C -x)-m[comma separated]' '(-l -g -1 -C -m)-x[sort horizontally]' '-o[display file flags]' '-s[display size of each file in blocks]' '(-u)-c[status change time]' '(-c)-u[access time]' '-f[unsorted, all, short list]' '-r[reverse sort order]' '(-t)-S[sort by size]' '(-S)-t[sort by modification time]' '(-p)-F[append file type indicators]' '(-F)-p[append file type indicators for directory]' '-f[output is not sorted]' '-n[numeric uid, gid]' '-T[show complete time information]' '(-B -b -w -q)-B[print octal escapes for control characters]' '(-B -b -w -q)-b[as -B, but use C escape codes whenever possible]' '(-B -b -w -q)-q[hide control chars]' '(-B -b -w -q)-w[print raw characters]' '*:files:_files') 
		if [[ "$OSTYPE" = (freebsd*|darwin*) ]]
		then
			arguments+=('-G[enable colorized output]' '-H[follow symlinks on the command line]' '-P[do not follow symlinks]') 
		fi
	else
		arguments=('(--all -a -A --almost-all)'{--all,-a}'[list entries starting with .]' '(--almost-all -A -a --all)'{--almost-all,-A}'[list all except . and ..]' '--author[print the author of each file]' '(--ignore-backups -B)'{--ignore-backups,-B}"[don't list entries ending with ~]" '(--directory -d)'{--directory,-d}'[list directory entries instead of contents]' '(--dired -D)'{--dired,-D}"[generate output designed for Emacs' dired mode]" '(--ignore,-I)'{--ignore,-I}"[don't list entire matching pattern]:pattern:" '(--dereference -L --dereference-command-line --dereference-command-line-symlink-to-dir)'{--dereference,-L}'[list referenced file for sym link]' '(--dereference -L --dereference-command-line --dereference-command-line-symlink-to-dir)'{--dereference-command-line,--dereference-command-line-symlink-to-dir} '(--recursive -R)'{--recursive,-R}'[list subdirectories recursively]' '(--no-group -G)'{--no-group,-G}'[inhibit display of group information]' '(--human-readable -h -H --si)'{--human-readable,-h}'[print sizes in human readable form]' '(--si -H -h --human-readable)'{--si,-H}'[sizes in human readable form; powers of 1000]' '(--inode -i)'{--inode,-i}'[print file inode numbers]' '(--format -l -g -o -1 -C -m -x)-l[long listing]' '(--format -l -1 -C -m -x)-g[long listing but without owner information]' '(--format -l --no-group -G -1 -C -m -x)-o[no group, long]' '(--format -l -g -o -C -m -x)-1[single column output]' '(--format -l -g -o -1 -m -x)-C[list entries in columns sorted vertically]' '(--format -l -g -o -1 -C -x)-m[comma separated]' '(--format -l -g -o -1 -C -m)-x[sort horizontally]' '(-l -g -o -1 -C -m -x)--format=:format:(verbose long commas horizontal across vertical single-column)' '(--size -s -f)'{--size,-s}'[display size of each file in blocks]' '(--time -u)-c[status change time]' '(--time -c)-u[access time]' '(-c -u)--time=[specify time to show]:time:(ctime status use atime access)' '--time-style=[show times using specified style]:time style:(full-iso long-iso iso locale)' '(-a --all -U -l --format -s --size -t --sort --full-time)-f[unsorted, all, short list]' '(--reverse)'{--reverse,-r}'[reverse sort order]' '(--sort -t -U -v -X)-S[sort by size]' '(--sort -S -U -v -X)-t[sort by modification time]' '(--sort -S -t -v -X)-U[unsorted]' '(--sort -S -t -U -X)-v[sort by version (filename treated numerically)]' '(--sort -S -t -U -v)-X[sort by extension]' '(-S -t -U -v -X)--sort=:sort:(size time none version extension)' '--color=-[control use of color]:color:(never always auto)' '(--classify -F --indicator-style -p --file-type)'{--classify,-F}'[append file type indicators]' '(--file-type -p --indicator-style -F --classify)'{--file-type,-p}'[append file type indicators except *]' '(-F --classify -p --file-type)--indicator-style=:indicator style:(none file-type classify)' '(-f)--full-time[list both full date and full time]' '(--kilobytes -k --block-size)'{--kilobytes,-k}'[use block size of 1k]' '(-k --kilobytes)--block-size=[specify block size]:block size (bytes):(1024)' '(--numeric-uid-gid -n)'{--numeric-uid-gid,-n}'[numeric uid, gid]' '(--tabsize -T)'{--tabsize=,-T+}'[specify tab size]:tab size' '(--width -w)'{--width=,-w+}'[specify screen width]:screen width' '(--quoting-style -b --escape -N --literal -Q --quote-name)'{--escape,-b}'[print octal escapes for control characters]' '(--quoting-style -b --escape -N --literal -Q --quote-name)'{--literal,-N}'[print raw characters]' '(--quoting-style -b --escape -N --literal -Q --quote-name)'{--quote-name,-Q}'[quote names]' '(-b --escape -N --literal -Q --quote-name)--quoting-style=:quoting style:(literal shell shell-always c escape clocale locale)' '(--hide-control-chars -q --show-control-chars)'{--hide-control-chars,-q}'[hide control chars]' '(-q --hide-control-chars)--show-control-chars' '(- :)--help[display help information]' '(- :)--version[display version information]' '*:files:_files') 
		if [[ $is_gnu != gnu ]]
		then
			arguments=(${${${arguments:#(|*\))--*}//--[^ )]#/}/\( #\)/}) 
		fi
	fi
	_arguments -s $arguments
}
_lscfg () {
	# undefined
	builtin autoload -XUz
}
_lsdev () {
	# undefined
	builtin autoload -XUz
}
_lslv () {
	# undefined
	builtin autoload -XUz
}
_lsof () {
	# undefined
	builtin autoload -XUz
}
_lspv () {
	# undefined
	builtin autoload -XUz
}
_lsusb () {
	# undefined
	builtin autoload -XUz
}
_lsvg () {
	# undefined
	builtin autoload -XUz
}
_lynx () {
	# undefined
	builtin autoload -XUz
}
_lzop () {
	# undefined
	builtin autoload -XUz
}
_mac_applications () {
	# undefined
	builtin autoload -XUz
}
_mac_files_for_application () {
	# undefined
	builtin autoload -XUz
}
_madison () {
	# undefined
	builtin autoload -XUz
}
_mail () {
	# undefined
	builtin autoload -XUz
}
_mailboxes () {
	# undefined
	builtin autoload -XUz
}
_main_complete () {
	local IFS=$' \t\n\0'
	eval "$_comp_setup"
	local func funcs ret=1 tmp _compskip format nm call match min max i num _completers _completer _completer_num curtag _comp_force_list _matchers _matcher _c_matcher _matcher_num _comp_tags _comp_mesg mesg str context state state_descr line opt_args val_args curcontext="$curcontext" _last_nmatches=-1 _last_menu_style _def_menu_style _menu_style sel _tags_level=0 _saved_exact="${compstate[exact]}" _saved_lastprompt="${compstate[last_prompt]}" _saved_list="${compstate[list]}" _saved_insert="${compstate[insert]}" _saved_colors="$ZLS_COLORS" _saved_colors_set=${+ZLS_COLORS}
	local -a precommands
	typeset -U _lastdescr _comp_ignore _comp_colors
	[[ -z "$curcontext" ]] && curcontext=::: 
	zstyle -s ":completion:${curcontext}:" insert-tab tmp || tmp=yes 
	if [[ ( "$tmp" = *pending(|[[:blank:]]*) && PENDING -gt 0 ) || ( "$tmp" = *pending=(#b)([0-9]##)(|[[:blank:]]*) && PENDING -ge $match[1] ) ]]
	then
		compstate[insert]=tab 
		return 0
	fi
	if [[ "$compstate[insert]" = tab* ]]
	then
		if [[ "$tmp" = (|*[[:blank:]])(yes|true|on|1)(|[[:blank:]]*) ]]
		then
			if [[ "$curcontext" != :* || -z "$compstate[vared]" ]] || zstyle -t ":completion:vared${curcontext}:" insert-tab
			then
				return 0
			fi
		fi
		compstate[insert]="${compstate[insert]//tab /}" 
	fi
	if [[ -z "$compstate[quote]" ]]
	then
		if [[ -o equals ]] && compset -P 1 '='
		then
			compstate[context]=equal 
		elif [[ "$PREFIX" != */* && "$PREFIX[1]" = '~' ]]
		then
			compset -p 1
			compstate[context]=tilde 
		fi
	fi
	_setup default
	_def_menu_style=("$_last_menu_style[@]") 
	_last_menu_style=() 
	if zstyle -s ":completion:${curcontext}:default" list-prompt tmp
	then
		LISTPROMPT="$tmp" 
		zmodload -i zsh/complist
	fi
	if zstyle -s ":completion:${curcontext}:default" select-prompt tmp
	then
		MENUPROMPT="$tmp" 
		zmodload -i zsh/complist
	fi
	if zstyle -s ":completion:${curcontext}:default" select-scroll tmp
	then
		MENUSCROLL="$tmp" 
		zmodload -i zsh/complist
	fi
	if (( $# ))
	then
		if [[ "$1" = - ]]
		then
			if [[ $# -lt 3 ]]
			then
				_completers=() 
			else
				_completers=("$2") 
				call=yes 
			fi
		else
			_completers=("$@") 
		fi
	else
		zstyle -a ":completion:${curcontext}:" completer _completers || _completers=(_complete _ignored) 
	fi
	_completer_num=1 
	funcs=("$compprefuncs[@]") 
	compprefuncs=() 
	for func in "$funcs[@]"
	do
		"$func"
	done
	for tmp in "$_completers[@]"
	do
		if [[ -n "$call" ]]
		then
			_completer="${tmp}" 
		elif [[ "$tmp" = *:-* ]]
		then
			_completer="${${tmp%:*}[2,-1]//_/-}${tmp#*:}" 
			tmp="${tmp%:*}" 
		elif [[ $tmp = *:* ]]
		then
			_completer="${tmp#*:}" 
			tmp="${tmp%:*}" 
		else
			_completer="${tmp[2,-1]//_/-}" 
		fi
		curcontext="${curcontext/:[^:]#:/:${_completer}:}" 
		zstyle -t ":completion:${curcontext}:" show-completer && zle -R "Trying completion for :completion:${curcontext}"
		zstyle -a ":completion:${curcontext}:" matcher-list _matchers || _matchers=('') 
		_matcher_num=1 
		_matcher='' 
		for _c_matcher in "$_matchers[@]"
		do
			if [[ "$_c_matcher" = +* ]]
			then
				_matcher="$_matcher $_c_matcher[2,-1]" 
			else
				_matcher="$_c_matcher" 
			fi
			_comp_mesg= 
			if [[ -n "$call" ]]
			then
				if "${(@)argv[3,-1]}"
				then
					ret=0 
					break 2
				fi
			elif "$tmp"
			then
				ret=0 
				break 2
			fi
			(( _matcher_num++ ))
		done
		[[ -n "$_comp_mesg" ]] && break
		(( _completer_num++ ))
	done
	curcontext="${curcontext/:[^:]#:/::}" 
	if [[ $compstate[old_list] = keep ]]
	then
		nm=$_lastcomp[nmatches] 
	else
		nm=$compstate[nmatches] 
	fi
	if [[ $compstate[old_list] = keep || nm -gt 1 ]]
	then
		[[ _last_nmatches -ge 0 && _last_nmatches -ne nm ]] && _menu_style=("$_last_menu_style[@]" "$_menu_style[@]") 
		tmp=$(( compstate[list_lines] + BUFFERLINES + 1 )) 
		_menu_style=("$_menu_style[@]" "$_def_menu_style[@]") 
		if [[ "$compstate[list]" = *list && tmp -gt LINES && ( -n "$_menu_style[(r)select=long-list]" || -n "$_menu_style[(r)(yes|true|on|1)=long-list]" ) ]]
		then
			compstate[insert]=menu 
		elif [[ "$compstate[insert]" = "$_saved_insert" ]]
		then
			if [[ -n "$compstate[insert]" && -n "$_menu_style[(r)(yes|true|1|on)=long]" && tmp -gt LINES ]]
			then
				compstate[insert]=menu 
			else
				sel=("${(@M)_menu_style:#(yes|true|1|on)*}") 
				if (( $#sel ))
				then
					min=9999999 
					for i in "$sel[@]"
					do
						if [[ "$i" = *\=[0-9]* ]]
						then
							num="${i#*\=}" 
							[[ num -lt 0 ]] && num=0 
						elif [[ "$i" != *\=* ]]
						then
							num=0 
						else
							num=9999999 
						fi
						[[ num -lt min ]] && min="$num" 
						(( min )) || break
					done
				fi
				sel=("${(@M)_menu_style:#(no|false|0|off)*}") 
				if (( $#sel ))
				then
					max=9999999 
					for i in "$sel[@]"
					do
						if [[ "$i" = *\=[0-9]* ]]
						then
							num="${i#*\=}" 
							[[ num -lt 0 ]] && num=0 
						elif [[ "$i" != *\=* ]]
						then
							num=0 
						else
							num=9999999 
						fi
						[[ num -lt max ]] && max="$num" 
						(( max )) || break
					done
				fi
				if [[ ( -n "$min" && nm -ge min && ( -z "$max" || nm -lt max ) ) || ( -n "$_menu_style[(r)auto*]" && "$compstate[insert]" = automenu ) ]]
				then
					compstate[insert]=menu 
				elif [[ -n "$max" && nm -ge max ]]
				then
					compstate[insert]=unambiguous 
				elif [[ -n "$_menu_style[(r)auto*]" && "$compstate[insert]" != automenu ]]
				then
					compstate[insert]=automenu-unambiguous 
				fi
			fi
		fi
		if [[ "$compstate[insert]" = *menu* ]]
		then
			[[ "$MENUSELECT" = 00 ]] && MENUSELECT=0 
			if [[ -n "$_menu_style[(r)no-select*]" ]]
			then
				unset MENUSELECT
			elif [[ -n "$_menu_style[(r)select=long*]" ]]
			then
				if [[ tmp -gt LINES ]]
				then
					zmodload -i zsh/complist
					MENUSELECT=00 
				fi
			fi
			if [[ "$MENUSELECT" != 00 ]]
			then
				sel=("${(@M)_menu_style:#select*}") 
				if (( $#sel ))
				then
					min=9999999 
					for i in "$sel[@]"
					do
						if [[ "$i" = *\=[0-9]* ]]
						then
							num="${i#*\=}" 
							[[ num -lt 0 ]] && num=0 
						elif [[ "$i" != *\=* ]]
						then
							num=0 
						else
							num=9999999 
						fi
						[[ num -lt min ]] && min="$num" 
						(( min )) || break
					done
					zmodload -i zsh/complist
					MENUSELECT="$min" 
				else
					unset MENUSELECT
				fi
			fi
			if [[ -n "$MENUSELECT" ]]
			then
				if [[ -n "$_menu_style[(r)interactive*]" ]]
				then
					MENUMODE=interactive 
				elif [[ -n "$_menu_style[(r)search*]" ]]
				then
					if [[ -n "$_menu_style[(r)*backward*]" ]]
					then
						MENUMODE=search-backward 
					else
						MENUMODE=search-forward 
					fi
				else
					unset MENUMODE
				fi
			fi
		fi
	elif [[ nm -lt 1 && -n "$_comp_mesg" ]]
	then
		compstate[insert]='' 
		compstate[list]='list force' 
	elif [[ nm -eq 0 && -z "$_comp_mesg" && $#_lastdescr -ne 0 && $compstate[old_list] != keep ]] && zstyle -s ":completion:${curcontext}:warnings" format format
	then
		compstate[list]='list force' 
		compstate[insert]='' 
		tmp=("\`${(@)^_lastdescr:#}'") 
		case $#tmp in
			(1) str="$tmp[1]"  ;;
			(2) str="$tmp[1] or $tmp[2]"  ;;
			(*) str="${(j:, :)tmp[1,-2]}, or $tmp[-1]"  ;;
		esac
		_setup warnings
		zformat -f mesg "$format" "d:$str" "D:${(F)${(@)_lastdescr:#}}"
		compadd -x "$mesg"
	fi
	[[ "$_comp_force_list" = always || ( "$_comp_force_list" = ?* && nm -ge _comp_force_list ) ]] && compstate[list]="${compstate[list]//messages} force" 
	if [[ "$compstate[old_list]" = keep ]]
	then
		if [[ $_saved_colors_set = 1 ]]
		then
			ZLS_COLORS="$_saved_colors" 
		else
			unset ZLS_COLORS
		fi
	elif (( $#_comp_colors ))
	then
		ZLS_COLORS="${(j.:.)_comp_colors}" 
	else
		unset ZLS_COLORS
	fi
	funcs=("$comppostfuncs[@]") 
	comppostfuncs=() 
	for func in "$funcs[@]"
	do
		"$func"
	done
	_lastcomp=("${(@kv)compstate}") 
	_lastcomp[nmatches]=$nm 
	_lastcomp[completer]="$_completer" 
	_lastcomp[prefix]="$PREFIX" 
	_lastcomp[suffix]="$SUFFIX" 
	_lastcomp[iprefix]="$IPREFIX" 
	_lastcomp[isuffix]="$ISUFFIX" 
	_lastcomp[qiprefix]="$QIPREFIX" 
	_lastcomp[qisuffix]="$QISUFFIX" 
	_lastcomp[tags]="$_comp_tags" 
	return ret
}
_make () {
	# undefined
	builtin autoload -XUz
}
_make-kpkg () {
	# undefined
	builtin autoload -XUz
}
_man () {
	# undefined
	builtin autoload -XUz
}
_match () {
	# undefined
	builtin autoload -XUz
}
_math () {
	# undefined
	builtin autoload -XUz
}
_matlab () {
	# undefined
	builtin autoload -XUz
}
_md5sum () {
	# undefined
	builtin autoload -XUz
}
_mdadm () {
	# undefined
	builtin autoload -XUz
}
_members () {
	# undefined
	builtin autoload -XUz
}
_mencal () {
	# undefined
	builtin autoload -XUz
}
_menu () {
	# undefined
	builtin autoload -XUz
}
_mere () {
	# undefined
	builtin autoload -XUz
}
_mergechanges () {
	# undefined
	builtin autoload -XUz
}
_message () {
	local format raw gopt
	if [[ "$1" = -e ]]
	then
		local expl ret=1 tag
		_comp_mesg=yes 
		if (( $# > 2 ))
		then
			tag="$2" 
			shift
		else
			tag="$curtag" 
		fi
		_tags "$tag" && while _next_label "$tag" expl "$2"
		do
			compadd ${expl:/-X/-x}
			ret=0 
		done
		(( $compstate[nmatches] )) || compstate[insert]= 
		return ret
	fi
	gopt=() 
	zparseopts -D -a gopt 1 2 V J
	_tags messages || return 1
	if [[ "$1" = -r ]]
	then
		raw=yes 
		shift
		format="$1" 
	else
		zstyle -s ":completion:${curcontext}:messages" format format || zstyle -s ":completion:${curcontext}:descriptions" format format
	fi
	if [[ -n "$format$raw" ]]
	then
		[[ -z "$raw" ]] && zformat -f format "$format" "d:$1" "${(@)argv[2,-1]}"
		builtin compadd "$gopt[@]" -x "$format"
		_comp_mesg=yes 
	fi
}
_metaflac () {
	# undefined
	builtin autoload -XUz
}
_mh () {
	# undefined
	builtin autoload -XUz
}
_mii-tool () {
	# undefined
	builtin autoload -XUz
}
_mime_types () {
	# undefined
	builtin autoload -XUz
}
_mkdir () {
	# undefined
	builtin autoload -XUz
}
_mkshortcut () {
	# undefined
	builtin autoload -XUz
}
_mkzsh () {
	# undefined
	builtin autoload -XUz
}
_module () {
	# undefined
	builtin autoload -XUz
}
_module-assistant () {
	# undefined
	builtin autoload -XUz
}
_modutils () {
	# undefined
	builtin autoload -XUz
}
_mondo () {
	# undefined
	builtin autoload -XUz
}
_monotone () {
	# undefined
	builtin autoload -XUz
}
_mosh () {
	# undefined
	builtin autoload -XUz
}
_most_recent_file () {
	# undefined
	builtin autoload -XUz
}
_mount () {
	# undefined
	builtin autoload -XUz
}
_mozilla () {
	# undefined
	builtin autoload -XUz
}
_mpc () {
	# undefined
	builtin autoload -XUz
}
_mplayer () {
	# undefined
	builtin autoload -XUz
}
_mt () {
	# undefined
	builtin autoload -XUz
}
_mtools () {
	# undefined
	builtin autoload -XUz
}
_mtr () {
	# undefined
	builtin autoload -XUz
}
_multi_parts () {
	local sep pref npref i tmp2 group expl menu pre suf opre osuf orig cpre
	local opts sopts matcher imm
	typeset -U tmp1 matches
	zparseopts -D -a sopts 'J+:=group' 'V+:=group' 'X+:=expl' 'P:=opts' 'F:=opts' S: r: R: q 1 2 n f 'M+:=matcher' 'i=imm'
	sopts=("$sopts[@]" "$opts[@]") 
	if (( $#matcher ))
	then
		matcher="${matcher[2]}" 
	else
		matcher= 
	fi
	sep="$1" 
	if [[ "${2[1]}" = '(' ]]
	then
		tmp1=(${=2[2,-2]}) 
	else
		tmp1=("${(@P)2}") 
	fi
	pre="$PREFIX" 
	suf="$SUFFIX" 
	opre="$PREFIX" 
	osuf="$SUFFIX" 
	orig="$PREFIX$SUFFIX" 
	[[ $compstate[insert] = (*menu|[0-9]*) || -n "$_comp_correct" || ( $#compstate[pattern_match] -ne 0 && "$orig" != "${orig:q}" ) ]] && menu=yes 
	pref='' 
	compadd -O matches -M "r:|${sep}=* r:|=* $matcher" -a tmp1
	(( $#matches )) || matches=("$tmp1[@]") 
	while true
	do
		if [[ "$pre" = *${sep}* ]]
		then
			PREFIX="${pre%%${sep}*}" 
			SUFFIX="" 
		else
			PREFIX="${pre}" 
			SUFFIX="${suf%%${sep}*}" 
		fi
		if [[ -n "$PREFIX$SUFFIX" || "$pre" = ${sep}* ]]
		then
			tmp1=("${(@M)matches:#${PREFIX}${SUFFIX}${sep}*}") 
		else
			tmp1=() 
		fi
		if (( $#tmp1 ))
		then
			npref="${PREFIX}${SUFFIX}${sep}" 
		else
			builtin compadd -O tmp1 -M "r:|${sep}=* r:|=* $matcher" - "${(@)${(@)matches%%${sep}*}:#}"
			[[ $#tmp1 -eq 0 && -n "$_comp_correct" ]] && compadd -O tmp1 -M "r:|${sep}=* r:|=* $matcher" - "${(@)${(@)matches%%${sep}*}:#}"
			if [[ $#tmp1 -eq 1 ]]
			then
				if [[ "$pre$suf" = *${sep}* ]]
				then
					npref="${tmp1[1]}${sep}" 
				else
					matches=("${(@M)matches:#${tmp1[1]}*}") 
					PREFIX="${cpre}${pre}" 
					SUFFIX="$suf" 
					if [[ $#imm -ne 0 && $#matches -eq 1 ]] || zstyle -t ":completion:${curcontext}:" expand suffix
					then
						compadd "$group[@]" "$expl[@]" "$sopts[@]" -M "r:|${sep}=* r:|=* $matcher" - $pref$matches
					else
						if (( $matches[(I)${tmp1[1]}${sep}*] ))
						then
							compadd "$group[@]" "$expl[@]" -p "$pref" -r "$sep" -S "$sep" "$opts[@]" -M "r:|${sep}=* r:|=* $matcher" - "$tmp1[1]"
						else
							compadd "$group[@]" "$expl[@]" -p "$pref" "$sopts[@]" -M "r:|${sep}=* r:|=* $matcher" - "$tmp1[1]"
						fi
					fi
					return
				fi
			elif (( $#tmp1 ))
			then
				local ret=1 tt
				local -a mm
				PREFIX="$pre" 
				SUFFIX="$suf" 
				compadd -O matches -M "r:|${sep}=* r:|=* $matcher" -a matches
				if [[ "$pre" = *${sep}* ]]
				then
					PREFIX="${cpre}${pre%%${sep}*}" 
					SUFFIX="${sep}${pre#*${sep}}${suf}" 
				else
					PREFIX="${cpre}${pre}" 
					SUFFIX="$suf" 
				fi
				for tt in $tmp1
				do
					mm+=("${(@M)matches:#$tt*}") 
				done
				matches=($mm) 
				if ! zstyle -t ":completion:${curcontext}:" expand suffix || [[ -n "$menu" || -z "$compstate[insert]" ]]
				then
					tmp2="$pre$suf" 
					if [[ "$tmp2" = *${sep}* ]]
					then
						tmp2=(-s "${sep}${tmp2#*${sep}}") 
					else
						tmp2=() 
					fi
					compadd "$group[@]" "$expl[@]" -r "$sep" -S "$sep" "$opts[@]" -p "$pref" "$tmp2[@]" -M "r:|${sep}=* r:|=* $matcher" - "${(@)${(@)${(@M)matches:#*${sep}}%%${sep}*}:#}" && ret=0 
					(( $matches[(I)${sep}*] )) && compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" -M "r:|${sep}=* r:|=* $matcher" - "$sep" && ret=0 
					compadd "$group[@]" "$expl[@]" -r "$sep" -S "$sep" "$opts[@]" -p "$pref" "$tmp2[@]" -M "r:|${sep}=* r:|=* $matcher" - "${(@)${(@)${(@M)matches:#*?${sep}?*}%%${sep}*}:#}" && ret=0 
					compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" "$tmp2[@]" -M "r:|${sep}=* r:|=* $matcher" - "${(@)matches:#*${sep}*}" && ret=0 
				else
					compadd "$group[@]" "$expl[@]" "$opts[@]" -p "$pref" -s "${i#*${sep}}" -M "r:|${sep}=* r:|=* $matcher" - "${(@)${(@)${(@M)matches:#*${sep}*}%%${sep}*}:#}" && ret=0 
					compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "$pref" -M "r:|${sep}=* r:|=* $matcher" - "${(@)matches:#*${sep}*}" && ret=0 
				fi
				return ret
			else
				{
					! zstyle -t ":completion:${curcontext}:" expand prefix || [[ "$orig" = "$pref$pre$suf" ]]
				} && return 1
				PREFIX="${cpre}${pre}" 
				SUFFIX="$suf" 
				if [[ -n "$suf" ]]
				then
					compadd "$group[@]" "$expl[@]" -s "$suf" "$sopts[@]" -M "r:|${sep}=* r:|=* $matcher" - "$pref$pre"
				else
					compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -M "r:|${sep}=* r:|=* $matcher" - "$pref$pre"
				fi
				return
			fi
		fi
		matches=("${(@)${(@)${(@M)matches:#${npref}*}#*${sep}}:#}") 
		pref="$pref$npref" 
		if [[ "$pre" = *${sep}* ]]
		then
			cpre="${cpre}${pre%%${sep}*}${sep}" 
			pre="${pre#*${sep}}" 
		elif [[ "$suf" = *${sep}* ]]
		then
			cpre="${cpre}${pre}${suf%%${sep}*}${sep}" 
			pre="${suf#*${sep}}" 
			suf="" 
		else
			PREFIX="${opre}${osuf}" 
			SUFFIX="" 
			if [[ -n "$pref" && "$orig" != "$pref" ]]
			then
				if [[ "$pref" = *${sep}*${sep} ]]
				then
					compadd "$group[@]" "$expl[@]" "$opts[@]" -p "${pref%${sep}*${sep}}${sep}" -S "$sep" -M "r:|${sep}=* r:|=* $matcher" - "${${pref%${sep}}##*${sep}}"
				elif [[ "$pref" = *${sep}* ]]
				then
					compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -p "${pref%${sep}*}${sep}" -M "r:|${sep}=* r:|=* $matcher" - "${pref##*${sep}}"
				else
					compadd "$group[@]" "$expl[@]" -S '' "$opts[@]" -M "r:|${sep}=* r:|=* $matcher" - "$pref"
				fi
			fi
			return
		fi
	done
}
_mutt () {
	# undefined
	builtin autoload -XUz
}
_my_accounts () {
	# undefined
	builtin autoload -XUz
}
_mysql_utils () {
	# undefined
	builtin autoload -XUz
}
_mysqldiff () {
	# undefined
	builtin autoload -XUz
}
_nautilus () {
	# undefined
	builtin autoload -XUz
}
_ncftp () {
	# undefined
	builtin autoload -XUz
}
_nedit () {
	# undefined
	builtin autoload -XUz
}
_net_interfaces () {
	# undefined
	builtin autoload -XUz
}
_netcat () {
	# undefined
	builtin autoload -XUz
}
_netscape () {
	# undefined
	builtin autoload -XUz
}
_netstat () {
	# undefined
	builtin autoload -XUz
}
_newsgroups () {
	# undefined
	builtin autoload -XUz
}
_next_label () {
	local __gopt __descr __spec
	__gopt=() 
	zparseopts -D -a __gopt 1 2 V J x
	if comptags -A "$1" curtag __spec
	then
		(( $#funcstack > _tags_level )) && _comp_tags="${_comp_tags% * }" 
		_tags_level=$#funcstack 
		_comp_tags="$_comp_tags $__spec " 
		if [[ "$curtag" = *[^\\]:* ]]
		then
			zformat -f __descr "${curtag#*:}" "d:$3"
			_description "$__gopt[@]" "${curtag%:*}" "$2" "$__descr"
			curtag="${curtag%:*}" 
			set -A $2 "${(P@)2}" "${(@)argv[4,-1]}"
		else
			_description "$__gopt[@]" "$curtag" "$2" "$3"
			set -A $2 "${(@)argv[4,-1]}" "${(P@)2}"
		fi
		return 0
	fi
	return 1
}
_next_tags () {
	# undefined
	builtin autoload -XUz
}
_nice () {
	# undefined
	builtin autoload -XUz
}
_nkf () {
	# undefined
	builtin autoload -XUz
}
_nm () {
	# undefined
	builtin autoload -XUz
}
_nmap () {
	# undefined
	builtin autoload -XUz
}
_nmcli () {
	# undefined
	builtin autoload -XUz
}
_normal () {
	local _comp_command1 _comp_command2 _comp_command skip
	if [[ "$1" = -s ]]
	then
		skip=(-s) 
	else
		skip=() 
		_compskip='' 
	fi
	if [[ -o BANG_HIST && ( ( $words[CURRENT] = \!*: && -z $compstate[quote] ) || ( $words[CURRENT] = \"\!*: && $compstate[all_quotes] = \" ) ) ]]
	then
		PREFIX=${PREFIX//\\!/!} 
		compset -P '*:'
		_history_modifiers h
		return
	fi
	if [[ CURRENT -eq 1 ]]
	then
		curcontext="${curcontext%:*:*}:-command-:" 
		comp="$_comps[-command-]" 
		[[ -n "$comp" ]] && eval "$comp" && ret=0 
		return ret
	fi
	_set_command
	_dispatch "$skip[@]" "$_comp_command" "$_comp_command1" "$_comp_command2" -default-
}
_nothing () {
	# undefined
	builtin autoload -XUz
}
_notmuch () {
	# undefined
	builtin autoload -XUz
}
_npm () {
	# undefined
	builtin autoload -XUz
}
_nslookup () {
	# undefined
	builtin autoload -XUz
}
_object_classes () {
	# undefined
	builtin autoload -XUz
}
_okular () {
	# undefined
	builtin autoload -XUz
}
_oldlist () {
	# undefined
	builtin autoload -XUz
}
_open () {
	# undefined
	builtin autoload -XUz
}
_options () {
	# undefined
	builtin autoload -XUz
}
_options_set () {
	# undefined
	builtin autoload -XUz
}
_options_unset () {
	# undefined
	builtin autoload -XUz
}
_osc () {
	# undefined
	builtin autoload -XUz
}
_other_accounts () {
	# undefined
	builtin autoload -XUz
}
_pack () {
	# undefined
	builtin autoload -XUz
}
_parameter () {
	# undefined
	builtin autoload -XUz
}
_parameters () {
	# undefined
	builtin autoload -XUz
}
_patch () {
	# undefined
	builtin autoload -XUz
}
_path_commands () {
	# undefined
	builtin autoload -XUz
}
_path_files () {
	local -a match mbegin mend
	if _have_glob_qual $PREFIX
	then
		compset -p ${#match[1]}
		if [[ $_comp_caller_options[extendedglob] = on ]] && compset -P '\#'
		then
			_globflags
		else
			_globquals
		fi
		return
	fi
	local linepath realpath donepath prepath testpath exppath skips skipped
	local tmp1 tmp2 tmp3 tmp4 i orig eorig pre suf tpre tsuf opre osuf cpre
	local pats haspats ignore pfx pfxsfx sopt gopt opt sdirs ignpar cfopt listsfx
	local nm=$compstate[nmatches] menu matcher mopts sort mid accex fake
	local listfiles listopts tmpdisp origtmp1 Uopt
	local accept_exact_dirs path_completion
	integer npathcheck
	local -a Mopts
	typeset -U prepaths exppaths
	exppaths=() 
	zparseopts -a mopts 'P:=pfx' 'S:=pfxsfx' 'q=pfxsfx' 'r:=pfxsfx' 'R:=pfxsfx' 'W:=prepaths' 'F:=ignore' 'M+:=matcher' J+: V+: X+: 1 2 n 'f=tmp1' '/=tmp1' 'g+:-=tmp1'
	sopt="-${(@j::M)${(@)tmp1#-}#?}" 
	(( $tmp1[(I)-[/g]*] )) && haspats=yes 
	(( $tmp1[(I)-g*] )) && gopt=yes 
	if (( $tmp1[(I)-/] ))
	then
		pats="${(@)${(@M)tmp1:#-g*}#-g}" 
		pats=('*(-/)' ${${(z):-x $pats}[2,-1]}) 
	else
		pats="${(@)${(@M)tmp1:#-g*}#-g}" 
		pats=(${${(z):-x $pats}[2,-1]}) 
	fi
	pats=("${(@)pats:# #}") 
	if (( $#pfx ))
	then
		compset -P "$pfx[2]" || pfxsfx=("$pfx[@]" "$pfxsfx[@]") 
	fi
	if (( $#prepaths ))
	then
		tmp1="${prepaths[2]}" 
		if [[ "$tmp1[1]" = '(' ]]
		then
			prepaths=(${^=tmp1[2,-2]%/}/) 
		elif [[ "$tmp1[1]" = '/' ]]
		then
			prepaths=("${tmp1%/}/") 
		else
			prepaths=(${(P)^tmp1%/}/) 
			(( ! $#prepaths )) && prepaths=(${tmp1%/}/) 
		fi
		(( ! $#prepaths )) && prepaths=('') 
	else
		prepaths=('') 
	fi
	if (( $#ignore ))
	then
		if [[ "${ignore[2]}" = \(* ]]
		then
			ignore=(${=ignore[2][2,-2]}) 
		else
			ignore=(${(P)ignore[2]}) 
		fi
	fi
	if [[ "$sopt" = -(f|) ]]
	then
		if [[ -z "$gopt" ]]
		then
			sopt='-f' 
			pats=('*') 
		else
			unset sopt
		fi
	fi
	if (( ! $mopts[(I)-[JVX]] ))
	then
		local expl
		if [[ -z "$gopt" && "$sopt" = -/ ]]
		then
			_description directories expl directory
		else
			_description files expl file
		fi
		tmp1=$expl[(I)-M*] 
		if (( tmp1 ))
		then
			if (( $#matcher ))
			then
				matcher[2]="$matcher[2] $expl[1+tmp1]" 
			else
				matcher=(-M "$expl[1+tmp1]") 
			fi
		fi
		mopts=("$mopts[@]" "$expl[@]") 
	fi
	[[ -z "$_comp_no_ignore" && $#ignore -eq 0 && ( -z $gopt || "$pats" = \ #\*\ # ) && -n $FIGNORE ]] && ignore=("?*${^fignore[@]}") 
	if (( $#ignore ))
	then
		_comp_ignore=("$_comp_ignore[@]" "$ignore[@]") 
		(( $mopts[(I)-F] )) || mopts=("$mopts[@]" -F _comp_ignore) 
	fi
	if [[ $#matcher -eq 0 && -o nocaseglob ]]
	then
		matcher=(-M 'm:{a-zA-Z}={A-Za-z}') 
	fi
	if (( $#matcher ))
	then
		mopts=("$mopts[@]" "$matcher[@]") 
	fi
	if zstyle -s ":completion:${curcontext}:" file-sort tmp1
	then
		case "$tmp1" in
			(*size*) sort=oL  ;;
			(*links*) sort=ol  ;;
			(*(time|date|modi)*) sort=om  ;;
			(*access*) sort=oa  ;;
			(*(inode|change)*) sort=oc  ;;
			(*) sort=on  ;;
		esac
		[[ "$tmp1" = *rev* ]] && sort[1]=O 
		[[ "$tmp1" = *follow* ]] && sort="-${sort}-" 
		if [[ "$sort" = on ]]
		then
			sort= 
		else
			mopts=("${(@)mopts/#-J/-V}") 
			tmp2=() 
			for tmp1 in "$pats[@]"
			do
				if _have_glob_qual "$tmp1" complete
				then
					tmp2+=("${match[1]}#q${sort})(${match[5]})") 
				else
					tmp2+=("${tmp1}(${sort})") 
				fi
			done
			pats=("$tmp2[@]") 
		fi
	fi
	if zstyle -t ":completion:${curcontext}:paths" squeeze-slashes
	then
		skips='((.|..|)/)##' 
	else
		skips='((.|..)/)##' 
	fi
	zstyle -s ":completion:${curcontext}:paths" special-dirs sdirs
	zstyle -t ":completion:${curcontext}:paths" list-suffixes && listsfx=yes 
	[[ "$pats" = ((|*[[:blank:]])\*(|[[:blank:]]*|\([^[:blank:]]##\))|*\([^[:blank:]]#/[^[:blank:]]#\)*) ]] && sopt=$sopt/ 
	zstyle -a ":completion:${curcontext}:paths" accept-exact accex
	zstyle -a ":completion:${curcontext}:" fake-files fake
	zstyle -s ":completion:${curcontext}:" ignore-parents ignpar
	zstyle -t ":completion:${curcontext}:paths" accept-exact-dirs && accept_exact_dirs=1 
	zstyle -T ":completion:${curcontext}:paths" path-completion && path_completion=1 
	if [[ -n "$compstate[pattern_match]" ]]
	then
		if {
				[[ -z "$SUFFIX" ]] && _have_glob_qual "$PREFIX" complete
			} || _have_glob_qual "$SUFFIX" complete
		then
			tmp3=${match[5]} 
			if [[ -n "$SUFFIX" ]]
			then
				SUFFIX=${match[2]} 
			else
				PREFIX=${match[2]} 
			fi
			tmp2=() 
			for tmp1 in "$pats[@]"
			do
				if _have_glob_qual "$tmp1" complete
				then
					tmp2+=("${match[1]}${tmp3}${match[5]})") 
				else
					tmp2+=("${tmp1}(${tmp3})") 
				fi
			done
			pats=("$tmp2[@]") 
		fi
	fi
	pre="$PREFIX" 
	suf="$SUFFIX" 
	opre="$PREFIX" 
	osuf="$SUFFIX" 
	orig="${PREFIX}${SUFFIX}" 
	eorig="$orig" 
	[[ $compstate[insert] = (*menu|[0-9]*) || -n "$_comp_correct" || ( -n "$compstate[pattern_match]" && "${orig#\~}" != (|*[^\\])[][*?#~^\|\<\>]* ) ]] && menu=yes 
	if [[ -n "$_comp_correct" ]]
	then
		cfopt=- 
		Uopt=-U 
	else
		Mopts=(-M "r:|/=* r:|=*") 
	fi
	if [[ "$pre" = [^][*?#^\|\<\>\\]#(\`[^\`]#\`|\$)*/* && "$compstate[quote]" != \' ]]
	then
		linepath="${(M)pre##*\$[^/]##/}" 
		() {
			setopt localoptions nounset
			eval 'realpath=${(e)~linepath}' 2> /dev/null
		}
		[[ -z "$realpath" || "$realpath" = "$linepath" ]] && return 1
		pre="${pre#${linepath}}" 
		i='[^/]' 
		i="${#linepath//$i}" 
		orig="${orig[1,(in:i:)/][1,-2]}" 
		donepath= 
		prepaths=('') 
	elif [[ "$pre[1]" = \~ && -z "$compstate[quote]" ]]
	then
		linepath="${pre[2,-1]%%/*}" 
		if [[ -z "$linepath" ]]
		then
			realpath="${HOME%/}/" 
		elif [[ "$linepath" = ([-+]|)[0-9]## ]]
		then
			if [[ "$linepath" != [-+]* ]]
			then
				tmp1="$linepath" 
			else
				if [[ "$linepath" = -* ]]
				then
					tmp1=$(( $#dirstack $linepath )) 
				else
					tmp1=$linepath[2,-1] 
				fi
				[[ -o pushdminus ]] && tmp1=$(( $#dirstack - $tmp1 )) 
			fi
			if (( ! tmp1 ))
			then
				realpath=$PWD/ 
			elif [[ tmp1 -le $#dirstack ]]
			then
				realpath=$dirstack[tmp1]/ 
			else
				_message 'not enough directory stack entries'
				return 1
			fi
		elif [[ "$linepath" = [-+] ]]
		then
			realpath=${~:-\~$linepath}/ 
		else
			eval "realpath=~${linepath}/" 2> /dev/null
			if [[ -z "$realpath" ]]
			then
				_message "unknown user \`$linepath'"
				return 1
			fi
		fi
		linepath="~${linepath}/" 
		[[ "$realpath" = "$linepath" ]] && return 1
		pre="${pre#*/}" 
		orig="${orig#*/}" 
		donepath= 
		prepaths=('') 
	else
		linepath= 
		realpath= 
		if zstyle -s ":completion:${curcontext}:" preserve-prefix tmp1 && [[ -n "$tmp1" && "$pre" = (#b)(${~tmp1})* ]]
		then
			pre="$pre[${#match[1]}+1,-1]" 
			orig="$orig[${#match[1]}+1,-1]" 
			donepath="$match[1]" 
			prepaths=('') 
		elif [[ "$pre[1]" = / ]]
		then
			pre="$pre[2,-1]" 
			orig="$orig[2,-1]" 
			donepath='/' 
			prepaths=('') 
		else
			[[ "$pre" = (.|..)/* ]] && prepaths=('') 
			donepath= 
		fi
	fi
	for prepath in "$prepaths[@]"
	do
		skipped= 
		cpre= 
		if [[ ( -n $accept_exact_dirs || -z $path_completion ) && ${pre} = (#b)(*)/([^/]#) ]]
		then
			tmp1=${match[1]} 
			tpre=${match[2]} 
			tmp2=${(Q)tmp1} 
			tmp1=${tmp1//(#b)\\(?)/$match[1]} 
			tpre=${tpre//(#b)\\([^\\\]\[\^\~\(\)\#\*\?])/$match[1]} 
			tmp3=${donepath//(#b)\\(?)/$match[1]} 
			while true
			do
				if [[ -z $path_completion || -d $prepath$realpath$tmp3$tmp2 ]]
				then
					tmp3=$tmp3$tmp1/ 
					donepath=${tmp3//(#b)([\\\]\[\^\~\(\)\#\*\?])/\\$match[1]} 
					pre=$tpre 
					break
				elif [[ $tmp1 = (#b)(*)/([^/]#) ]]
				then
					tmp1=$match[1] 
					tpre=$match[2]/$tpre 
				else
					break
				fi
			done
		fi
		tpre="$pre" 
		tsuf="$suf" 
		testpath="${donepath//(#b)\\([\\\]\[\^\~\(\)\#\*\?])/$match[1]}" 
		tmp2="${(M)tpre##${~skips}}" 
		tpre="${tpre#$tmp2}" 
		tmp1=("$prepath$realpath$donepath$tmp2") 
		(( npathcheck = 0 ))
		while true
		do
			origtmp1=("${tmp1[@]}") 
			if [[ "$tpre" = */* ]]
			then
				PREFIX="${tpre%%/*}" 
				SUFFIX= 
			else
				PREFIX="${tpre}" 
				SUFFIX="${tsuf%%/*}" 
			fi
			tmp2=("$tmp1[@]") 
			if [[ "$tpre$tsuf" = (#b)*/(*) ]]
			then
				if [[ -n "$fake${match[1]}" ]]
				then
					compfiles -P$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" "$sdirs" fake
				else
					compfiles -P$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" '' fake
				fi
			elif [[ "$sopt" = *[/f]* ]]
			then
				compfiles -p$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" "$sdirs" fake "$pats[@]"
			else
				compfiles -p$cfopt tmp1 accex "$skipped" "$_matcher $matcher[2]" '' fake "$pats[@]"
			fi
			tmp1=($~tmp1)  2> /dev/null
			if [[ -n "$PREFIX$SUFFIX" ]]
			then
				if (( ! $#tmp1 && npathcheck == 0 ))
				then
					(( npathcheck = 1 ))
					for tmp3 in "$tmp2[@]"
					do
						if [[ -n $tmp3 && $tmp3 != */ ]]
						then
							tmp3+=/ 
						fi
						if [[ -e "$tmp3${(Q)PREFIX}${(Q)SUFFIX}" ]]
						then
							(( npathcheck = 2 ))
						fi
					done
					if (( npathcheck == 2 ))
					then
						tmp1=("$origtmp1[@]") 
						continue
					fi
				fi
				if (( ! $#tmp1 ))
				then
					tmp2=(${^${tmp2:#/}}/$PREFIX$SUFFIX) 
				elif [[ "$tmp1[1]" = */* ]]
				then
					if [[ -n "$_comp_correct" ]]
					then
						tmp2=("$tmp1[@]") 
						builtin compadd -D tmp1 "$matcher[@]" - "${(@)tmp1:t}"
						if [[ $#tmp1 -eq 0 ]]
						then
							tmp1=("$tmp2[@]") 
							compadd -D tmp1 "$matcher[@]" - "${(@)tmp2:t}"
						fi
					else
						tmp2=("$tmp1[@]") 
						compadd -D tmp1 "$matcher[@]" - "${(@)tmp1:t}"
					fi
				else
					tmp2=('') 
					compadd -D tmp1 "$matcher[@]" -a tmp1
				fi
				if (( ! $#tmp1 ))
				then
					if [[ "$tmp2[1]" = */* ]]
					then
						tmp2=("${(@)tmp2#${prepath}${realpath}}") 
						if [[ "$tmp2[1]" = */* ]]
						then
							tmp2=("${(@)tmp2:h}") 
							compquote tmp2
							if [[ "$tmp2" = */ ]]
							then
								exppaths=("$exppaths[@]" ${^tmp2}${tpre}${tsuf}) 
							else
								exppaths=("$exppaths[@]" ${^tmp2}/${tpre}${tsuf}) 
							fi
						elif [[ ${tpre}${tsuf} = */* ]]
						then
							exppaths=("$exppaths[@]" ${tpre}${tsuf}) 
						fi
					fi
					continue 2
				fi
			elif (( ! $#tmp1 ))
			then
				if [[ -z "$tpre$tsuf" && -n "$pre$suf" ]]
				then
					pfxsfx=(-S '' "$pfxsfx[@]") 
				elif [[ -n "$haspats" && -z "$tpre$tsuf$suf" && "$pre" = */ ]]
				then
					PREFIX="${opre}" 
					SUFFIX="${osuf}" 
					compadd -nQS '' - "$linepath$donepath$orig"
					tmp4=- 
				fi
				continue 2
			fi
			if [[ -n "$ignpar" && -z "$_comp_no_ignore" && "$tpre$tsuf" != */* && $#tmp1 -ne 0 && ( "$ignpar" != *dir* || "$pats" = '*(-/)' ) && ( "$ignpar" != *..* || "$tmp1[1]" = *../* ) ]]
			then
				compfiles -i tmp1 _comp_ignore "$ignpar" "$prepath$realpath$donepath"
				(( $#_comp_ignore && $mopts[(I)-F] )) || mopts=("$mopts[@]" -F _comp_ignore) 
			fi
			if [[ "$tpre" = */* ]]
			then
				tpre="${tpre#*/}" 
			elif [[ "$tsuf" = */* ]]
			then
				tpre="${tsuf#*/}" 
				tsuf= 
			else
				break
			fi
			tmp1=(${tmp1//(#b)([][()|*?^#~<>\\=])/\\${match[1]}}) 
			tmp2="${(M)tpre##${~skips}}" 
			if [[ -n "$tmp2" ]]
			then
				skipped="/$tmp2" 
				tpre="${tpre#$tmp2}" 
			else
				skipped=/ 
			fi
			(( npathcheck = 0 ))
		done
		tmp3="$pre$suf" 
		tpre="$pre" 
		tsuf="$suf" 
		[[ -n "${prepath}${realpath}${testpath}" ]] && tmp1=("${(@)tmp1#${prepath}${realpath}${testpath}}") 
		while true
		do
			compfiles -r tmp1 "${(Q)tmp3}"
			tmp4=$? 
			if [[ "$tpre" = */* ]]
			then
				tmp2="${cpre}${tpre%%/*}" 
				PREFIX="${linepath}${donepath}${tmp2}" 
				SUFFIX="/${tpre#*/}${tsuf#*/}" 
			else
				tmp2="${cpre}${tpre}" 
				PREFIX="${linepath}${donepath}${tmp2}" 
				SUFFIX="${tsuf}" 
			fi
			if (( tmp4 ))
			then
				tmp2="$testpath" 
				if [[ -n "$linepath" ]]
				then
					compquote -p tmp2 tmp1
				elif [[ -n "$tmp2" ]]
				then
					compquote -p tmp1
					compquote tmp2
				else
					compquote tmp1 tmp2
				fi
				if [[ -z "$_comp_correct" && "$compstate[pattern_match]" = \* && -n "$listsfx" && "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					PREFIX="$opre" 
					SUFFIX="$osuf" 
				fi
				if [[ -z "$compstate[insert]" ]] || {
						! zstyle -t ":completion:${curcontext}:paths" expand suffix && [[ -z "$listsfx" && ( -n "$_comp_correct" || -z "$compstate[pattern_match]" || "$SUFFIX" != */* || "${SUFFIX#*/}" = (|*[^\\])[][*?#~^\|\<\>]* ) ]]
					}
				then
					(( tmp4 )) && zstyle -t ":completion:${curcontext}:paths" ambiguous && compstate[to_end]= 
					if [[ "$tmp3" = */* ]]
					then
						if [[ -z "$listsfx" || "$tmp3" != */?* ]]
						then
							tmp1=("${(@)tmp1%%/*}") 
							_list_files tmp1 "$prepath$realpath$testpath"
							compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "/${tmp3#*/}${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
						else
							tmp1=("${(@)^tmp1%%/*}/${tmp3#*/}") 
							_list_files tmp1 "$prepath$realpath$testpath"
							compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
						fi
					else
						_list_files tmp1 "$prepath$realpath$testpath"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
					fi
				else
					if [[ "$tmp3" = */* ]]
					then
						tmp4=($Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts) 
						if [[ -z "$listsfx" ]]
						then
							for i in "$tmp1[@]"
							do
								tmpdisp=("$i") 
								_list_files tmpdisp "$prepath$realpath$testpath"
								compadd "$tmp4[@]" -s "${Uopt:+$ISUFFIX}" $listopts - "$tmpdisp"
							done
						else
							[[ -n "$compstate[pattern_match]" ]] && SUFFIX="${SUFFIX:s./.*/}*" 
							for i in "$tmp1[@]"
							do
								_list_files i "$prepath$realpath$testpath"
								compadd "$tmp4[@]" $listopts - "$i"
							done
						fi
					else
						_list_files tmp1 "$prepath$realpath$testpath"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp2" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" $Mopts $listopts -a tmp1
					fi
				fi
				tmp4=- 
				break
			fi
			if [[ "$tmp3" != */* ]]
			then
				tmp4= 
				break
			fi
			testpath="${testpath}${tmp1[1]%%/*}/" 
			tmp3="${tmp3#*/}" 
			if [[ "$tpre" = */* ]]
			then
				if [[ -z "$_comp_correct" && -n "$compstate[pattern_match]" && "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					cpre="${cpre}${tmp1[1]%%/*}/" 
				else
					cpre="${cpre}${tpre%%/*}/" 
				fi
				tpre="${tpre#*/}" 
			elif [[ "$tsuf" = */* ]]
			then
				[[ "$tsuf" != /* ]] && mid="$testpath" 
				if [[ -z "$_comp_correct" && -n "$compstate[pattern_match]" && "$tmp2" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					cpre="${cpre}${tmp1[1]%%/*}/" 
				else
					cpre="${cpre}${tpre}/" 
				fi
				tpre="${tsuf#*/}" 
				tsuf= 
			else
				tpre= 
				tsuf= 
			fi
			tmp1=("${(@)tmp1#*/}") 
		done
		if [[ -z "$tmp4" ]]
		then
			if [[ "$mid" = */ ]]
			then
				PREFIX="${opre}" 
				SUFFIX="${osuf}" 
				tmp4="${testpath#${mid}}" 
				if [[ $mid = */*/* ]]
				then
					tmp3="${mid%/*/}" 
					tmp2="${${mid%/}##*/}" 
					if [[ -n "$linepath" ]]
					then
						compquote -p tmp3
					else
						compquote tmp3
					fi
					compquote tmp4 tmp2 tmp1
					for i in "$tmp1[@]"
					do
						_list_files tmp2 "$prepath$realpath${mid%/*/}"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath$tmp3/" -s "/$tmp4$i${Uopt:+$ISUFFIX}" -W "$prepath$realpath${mid%/*/}/" "$pfxsfx[@]" $Mopts $listopts - "$tmp2"
					done
				else
					tmp2="${${mid%/}##*/}" 
					compquote tmp4 tmp2 tmp1
					for i in "$tmp1[@]"
					do
						_list_files tmp2 "$prepath$realpath${mid%/*/}"
						compadd $Uopt -Qf "$mopts[@]" -p "${Uopt:+$IPREFIX}$linepath" -s "/$tmp4$i${Uopt:+$ISUFFIX}" -W "$prepath$realpath" "$pfxsfx[@]" $Mopts $listopts - "$tmp2"
					done
				fi
			else
				if [[ "$osuf" = */* ]]
				then
					PREFIX="${opre}${osuf}" 
					SUFFIX= 
				else
					PREFIX="${opre}" 
					SUFFIX="${osuf}" 
				fi
				tmp4="$testpath" 
				if [[ -n "$linepath" ]]
				then
					compquote -p tmp4 tmp1
				elif [[ -n "$tmp4" ]]
				then
					compquote -p tmp1
					compquote tmp4
				else
					compquote tmp4 tmp1
				fi
				if [[ -z "$_comp_correct" && -n "$compstate[pattern_match]" && "${PREFIX#\~}$SUFFIX" = (|*[^\\])[][*?#~^\|\<\>]* ]]
				then
					tmp1=("$linepath$tmp4${(@)^tmp1}") 
					_list_files tmp1 "$prepath$realpath"
					compadd -Qf -W "$prepath$realpath" "$pfxsfx[@]" "$mopts[@]" -M "r:|/=* r:|=*" $listopts -a tmp1
				else
					_list_files tmp1 "$prepath$realpath$testpath"
					compadd $Uopt -Qf -p "${Uopt:+$IPREFIX}$linepath$tmp4" -s "${Uopt:+$ISUFFIX}" -W "$prepath$realpath$testpath" "$pfxsfx[@]" "$mopts[@]" $Mopts $listopts -a tmp1
				fi
			fi
		fi
	done
	if [[ _matcher_num -eq ${#_matchers} ]] && zstyle -t ":completion:${curcontext}:paths" expand prefix && [[ nm -eq compstate[nmatches] && $#exppaths -ne 0 && "$linepath$exppaths" != "$eorig" ]]
	then
		PREFIX="${opre}" 
		SUFFIX="${osuf}" 
		compadd -Q "$mopts[@]" -S '' -M "r:|/=* r:|=*" -p "$linepath" -a exppaths
	fi
	[[ nm -ne compstate[nmatches] ]]
}
_pax () {
	# undefined
	builtin autoload -XUz
}
_pbm () {
	# undefined
	builtin autoload -XUz
}
_pbuilder () {
	# undefined
	builtin autoload -XUz
}
_pdf () {
	# undefined
	builtin autoload -XUz
}
_pdftk () {
	# undefined
	builtin autoload -XUz
}
_perforce () {
	# undefined
	builtin autoload -XUz
}
_perl () {
	# undefined
	builtin autoload -XUz
}
_perl_basepods () {
	# undefined
	builtin autoload -XUz
}
_perl_modules () {
	# undefined
	builtin autoload -XUz
}
_perldoc () {
	# undefined
	builtin autoload -XUz
}
_pfctl () {
	# undefined
	builtin autoload -XUz
}
_pfexec () {
	# undefined
	builtin autoload -XUz
}
_pgrep () {
	# undefined
	builtin autoload -XUz
}
_php () {
	# undefined
	builtin autoload -XUz
}
_physical_volumes () {
	# undefined
	builtin autoload -XUz
}
_pick_variant () {
	local output cmd pat
	local -a var
	local -A opts
	(( $+_cmd_variant )) || typeset -gA _cmd_variant
	zparseopts -D -A opts b: c: r:
	: ${opts[-c]:=$words[1]}
	while [[ $1 = *=* ]]
	do
		var+=("${1%%\=*}" "${1#*=}") 
		shift
	done
	if (( $+_cmd_variant[$opts[-c]] ))
	then
		(( $+opts[-r] )) && eval "${opts[-r]}=${_cmd_variant[$opts[-c]]}"
		[[ $_cmd_variant[$opts[-c]] = "$1" ]] && return 1
		return 0
	fi
	if [[ $+opts[-b] -eq 1 && -n $builtins[$opts[-c]] ]]
	then
		_cmd_variant[$opts[-c]]=$opts[-b] 
		(( $+opts[-r] )) && eval "${opts[-r]}=${_cmd_variant[$opts[-c]]}"
		return 0
	fi
	output="$(_call_program variant $opts[-c] "${@[2,-1]}" </dev/null 2>&1)" 
	for cmd pat in "$var[@]"
	do
		if [[ $output = *$~pat* ]]
		then
			(( $+opts[-r] )) && eval "${opts[-r]}=$cmd"
			_cmd_variant[$opts[-c]]="$cmd" 
			return 0
		fi
	done
	(( $+opts[-r] )) && eval "${opts[-r]}=$1"
	_cmd_variant[$opts[-c]]="$1" 
	return 1
}
_pids () {
	# undefined
	builtin autoload -XUz
}
_pine () {
	# undefined
	builtin autoload -XUz
}
_ping () {
	# undefined
	builtin autoload -XUz
}
_piuparts () {
	# undefined
	builtin autoload -XUz
}
_pkg-config () {
	# undefined
	builtin autoload -XUz
}
_pkg5 () {
	# undefined
	builtin autoload -XUz
}
_pkg_instance () {
	# undefined
	builtin autoload -XUz
}
_pkgadd () {
	# undefined
	builtin autoload -XUz
}
_pkginfo () {
	# undefined
	builtin autoload -XUz
}
_pkgrm () {
	# undefined
	builtin autoload -XUz
}
_pkgtool () {
	# undefined
	builtin autoload -XUz
}
_pon () {
	# undefined
	builtin autoload -XUz
}
_portaudit () {
	# undefined
	builtin autoload -XUz
}
_portlint () {
	# undefined
	builtin autoload -XUz
}
_portmaster () {
	# undefined
	builtin autoload -XUz
}
_ports () {
	# undefined
	builtin autoload -XUz
}
_portsnap () {
	# undefined
	builtin autoload -XUz
}
_postfix () {
	# undefined
	builtin autoload -XUz
}
_powerd () {
	# undefined
	builtin autoload -XUz
}
_prcs () {
	# undefined
	builtin autoload -XUz
}
_precommand () {
	# undefined
	builtin autoload -XUz
}
_prefix () {
	# undefined
	builtin autoload -XUz
}
_print () {
	# undefined
	builtin autoload -XUz
}
_printenv () {
	# undefined
	builtin autoload -XUz
}
_printers () {
	# undefined
	builtin autoload -XUz
}
_procstat () {
	# undefined
	builtin autoload -XUz
}
_prompt () {
	# undefined
	builtin autoload -XUz
}
_prstat () {
	# undefined
	builtin autoload -XUz
}
_ps () {
	# undefined
	builtin autoload -XUz
}
_ps1234 () {
	# undefined
	builtin autoload -XUz
}
_pscp () {
	# undefined
	builtin autoload -XUz
}
_pspdf () {
	# undefined
	builtin autoload -XUz
}
_psutils () {
	# undefined
	builtin autoload -XUz
}
_ptree () {
	# undefined
	builtin autoload -XUz
}
_pump () {
	# undefined
	builtin autoload -XUz
}
_putclip () {
	# undefined
	builtin autoload -XUz
}
_pydoc () {
	# undefined
	builtin autoload -XUz
}
_python () {
	# undefined
	builtin autoload -XUz
}
_qemu () {
	# undefined
	builtin autoload -XUz
}
_qiv () {
	# undefined
	builtin autoload -XUz
}
_qtplay () {
	# undefined
	builtin autoload -XUz
}
_quilt () {
	# undefined
	builtin autoload -XUz
}
_raggle () {
	# undefined
	builtin autoload -XUz
}
_rake () {
	# undefined
	builtin autoload -XUz
}
_ranlib () {
	# undefined
	builtin autoload -XUz
}
_rar () {
	# undefined
	builtin autoload -XUz
}
_rcs () {
	# undefined
	builtin autoload -XUz
}
_read () {
	# undefined
	builtin autoload -XUz
}
_read_comp () {
	# undefined
	builtin autoload -XUz
}
_readshortcut () {
	# undefined
	builtin autoload -XUz
}
_rebootin () {
	# undefined
	builtin autoload -XUz
}
_redirect () {
	# undefined
	builtin autoload -XUz
}
_regex_arguments () {
	# undefined
	builtin autoload -XUz
}
_regex_words () {
	# undefined
	builtin autoload -XUz
}
_remote_files () {
	# undefined
	builtin autoload -XUz
}
_renice () {
	# undefined
	builtin autoload -XUz
}
_reprepro () {
	# undefined
	builtin autoload -XUz
}
_requested () {
	local __gopt
	__gopt=() 
	zparseopts -D -a __gopt 1 2 V J x
	if comptags -R "$1"
	then
		if [[ $# -gt 3 ]]
		then
			_all_labels - "$__gopt[@]" "$@" || return 1
		elif [[ $# -gt 1 ]]
		then
			_description "$__gopt[@]" "$@"
		fi
		return 0
	else
		return 1
	fi
}
_retrieve_cache () {
	# undefined
	builtin autoload -XUz
}
_retrieve_mac_apps () {
	# undefined
	builtin autoload -XUz
}
_ri () {
	# undefined
	builtin autoload -XUz
}
_rlogin () {
	# undefined
	builtin autoload -XUz
}
_rm () {
	declare -a opts args
	args=('(-f --force)'{-f,--force}'[ignore nonexistent files, never prompt]' '(-I --interactive)-i[prompt before every removal]' '(-r -R --recursive)'{-r,-R,--recursive}'[remove directories and their contents recursively]' '*::files:->file') 
	if _pick_variant gnu=gnu unix --help
	then
		opts+=(-S) 
		args+=('(-i --interactive)-I[prompt when removing many files]' '(-i -I)--interactive=-[prompt under given condition (defaulting to always)]::when:((once\:"prompt when removing many files"
                                                                                         always\:"prompt before every removal"))' '--one-file-system[stay within filesystems of files given as arguments]' '(                   --preserve-root)--no-preserve-root[do not treat / specially]' '(--no-preserve-root                )--preserve-root[do not remove / (default)]' '(-v --verbose)'{-v,--verbose}'[explain what is being done]' '(- *)--help[display help message and exit]' '(- *)--version[output version information and exit]') 
	else
		args=(${args:#*--(force|recursive)\[*}) 
	fi
	local curcontext=$curcontext state line ret=1
	declare -A opt_args
	_arguments -C $opts $args && ret=0 
	case $state in
		(file) declare -a ignored
			ignored=() 
			((CURRENT > 1)) && ignored+=(${line[1,CURRENT-1]//(#m)[\[\]()\\*?#<>~\^]/\\$MATCH}) 
			((CURRENT < $#line)) && ignored+=(${line[CURRENT+1,-1]//(#m)[\[\]()\\*?#<>~\^]/\\$MATCH}) 
			_files -F ignored && ret=0  ;;
	esac
	return $ret
}
_rpm () {
	# undefined
	builtin autoload -XUz
}
_rpmbuild () {
	# undefined
	builtin autoload -XUz
}
_rrdtool () {
	# undefined
	builtin autoload -XUz
}
_rsync () {
	# undefined
	builtin autoload -XUz
}
_rubber () {
	# undefined
	builtin autoload -XUz
}
_ruby () {
	# undefined
	builtin autoload -XUz
}
_sablotron () {
	# undefined
	builtin autoload -XUz
}
_samba () {
	# undefined
	builtin autoload -XUz
}
_savecore () {
	# undefined
	builtin autoload -XUz
}
_sccs () {
	# undefined
	builtin autoload -XUz
}
_sched () {
	# undefined
	builtin autoload -XUz
}
_schedtool () {
	# undefined
	builtin autoload -XUz
}
_schroot () {
	# undefined
	builtin autoload -XUz
}
_screen () {
	# undefined
	builtin autoload -XUz
}
_sed () {
	# undefined
	builtin autoload -XUz
}
_sep_parts () {
	# undefined
	builtin autoload -XUz
}
_service () {
	# undefined
	builtin autoload -XUz
}
_services () {
	# undefined
	builtin autoload -XUz
}
_set () {
	# undefined
	builtin autoload -XUz
}
_set_command () {
	local command
	command="$words[1]" 
	[[ -z "$command" ]] && return
	if (( $+builtins[$command] + $+functions[$command] ))
	then
		_comp_command1="$command" 
		_comp_command="$_comp_command1" 
	elif [[ "$command[1]" = '=' ]]
	then
		eval _comp_command2\=$command
		_comp_command1="$command[2,-1]" 
		_comp_command="$_comp_command2" 
	elif [[ "$command" = ..#/* ]]
	then
		_comp_command1="${PWD}/$command" 
		_comp_command2="${command:t}" 
		_comp_command="$_comp_command2" 
	elif [[ "$command" = */* ]]
	then
		_comp_command1="$command" 
		_comp_command2="${command:t}" 
		_comp_command="$_comp_command2" 
	else
		_comp_command1="$command" 
		_comp_command2="$commands[$command]" 
		_comp_command="$_comp_command1" 
	fi
}
_setfacl () {
	# undefined
	builtin autoload -XUz
}
_setopt () {
	# undefined
	builtin autoload -XUz
}
_setup () {
	local val nm="$compstate[nmatches]"
	[[ $# -eq 1 ]] && 2="$1" 
	if zstyle -a ":completion:${curcontext}:$1" list-colors val
	then
		zmodload -i zsh/complist
		if [[ "$1" = default ]]
		then
			_comp_colors=("$val[@]") 
		else
			_comp_colors=("$_comp_colors[@]" "(${2})${(@)^val:#(|\(*\)*)}" "${(M@)val:#\(*\)*}") 
		fi
	elif [[ "$1" = default ]]
	then
		unset ZLS_COLORS ZLS_COLOURS
	fi
	if zstyle -t ":completion:${curcontext}:$1" list-packed
	then
		compstate[list]="${compstate[list]} packed" 
	elif [[ $? -eq 1 ]]
	then
		compstate[list]="${compstate[list]:gs/packed//}" 
	else
		compstate[list]="$_saved_list" 
	fi
	if zstyle -t ":completion:${curcontext}:$1" list-rows-first
	then
		compstate[list]="${compstate[list]} rows" 
	elif [[ $? -eq 1 ]]
	then
		compstate[list]="${compstate[list]:gs/rows//}" 
	else
		compstate[list]="$_saved_list" 
	fi
	if zstyle -t ":completion:${curcontext}:$1" last-prompt
	then
		compstate[last_prompt]=yes 
	elif [[ $? -eq 1 ]]
	then
		compstate[last_prompt]='' 
	else
		compstate[last_prompt]="$_saved_lastprompt" 
	fi
	if zstyle -t ":completion:${curcontext}:$1" accept-exact
	then
		compstate[exact]=accept 
	elif [[ $? -eq 1 ]]
	then
		compstate[exact]='' 
	else
		compstate[exact]="$_saved_exact" 
	fi
	[[ _last_nmatches -ge 0 && _last_nmatches -ne nm ]] && _menu_style=("$_last_menu_style[@]" "$_menu_style[@]") 
	if zstyle -a ":completion:${curcontext}:$1" menu val
	then
		_last_nmatches=$nm 
		_last_menu_style=("$val[@]") 
	else
		_last_nmatches=-1 
	fi
	[[ "$_comp_force_list" != always ]] && zstyle -s ":completion:${curcontext}:$1" force-list val && [[ "$val" = always || ( "$val" = [0-9]## && ( -z "$_comp_force_list" || _comp_force_list -gt val ) ) ]] && _comp_force_list="$val" 
}
_sh () {
	# undefined
	builtin autoload -XUz
}
_showmount () {
	# undefined
	builtin autoload -XUz
}
_signals () {
	# undefined
	builtin autoload -XUz
}
_sisu () {
	# undefined
	builtin autoload -XUz
}
_slrn () {
	# undefined
	builtin autoload -XUz
}
_smit () {
	# undefined
	builtin autoload -XUz
}
_snoop () {
	# undefined
	builtin autoload -XUz
}
_socket () {
	# undefined
	builtin autoload -XUz
}
_sockstat () {
	# undefined
	builtin autoload -XUz
}
_softwareupdate () {
	# undefined
	builtin autoload -XUz
}
_sort () {
	# undefined
	builtin autoload -XUz
}
_source () {
	# undefined
	builtin autoload -XUz
}
_spamassassin () {
	# undefined
	builtin autoload -XUz
}
_sqlite () {
	# undefined
	builtin autoload -XUz
}
_sqsh () {
	# undefined
	builtin autoload -XUz
}
_ssh () {
	# undefined
	builtin autoload -XUz
}
_sshfs () {
	# undefined
	builtin autoload -XUz
}
_stat () {
	# undefined
	builtin autoload -XUz
}
_stgit () {
	# undefined
	builtin autoload -XUz
}
_store_cache () {
	# undefined
	builtin autoload -XUz
}
_strace () {
	# undefined
	builtin autoload -XUz
}
_strip () {
	# undefined
	builtin autoload -XUz
}
_stty () {
	# undefined
	builtin autoload -XUz
}
_su () {
	# undefined
	builtin autoload -XUz
}
_sub_commands () {
	# undefined
	builtin autoload -XUz
}
_subscript () {
	# undefined
	builtin autoload -XUz
}
_subversion () {
	# undefined
	builtin autoload -XUz
}
_sudo () {
	# undefined
	builtin autoload -XUz
}
_suffix_alias_files () {
	# undefined
	builtin autoload -XUz
}
_surfraw () {
	# undefined
	builtin autoload -XUz
}
_svcadm () {
	# undefined
	builtin autoload -XUz
}
_svccfg () {
	# undefined
	builtin autoload -XUz
}
_svcprop () {
	# undefined
	builtin autoload -XUz
}
_svcs () {
	# undefined
	builtin autoload -XUz
}
_svcs_fmri () {
	# undefined
	builtin autoload -XUz
}
_svn-buildpackage () {
	# undefined
	builtin autoload -XUz
}
_sysctl () {
	# undefined
	builtin autoload -XUz
}
_systemd () {
	# undefined
	builtin autoload -XUz
}
_tags () {
	local prev
	if [[ "$1" = -- ]]
	then
		prev=- 
		shift
	fi
	if (( $# ))
	then
		local curcontext="$curcontext" order tag nodef tmp
		if [[ "$1" = -C?* ]]
		then
			curcontext="${curcontext%:*}:${1[3,-1]}" 
			shift
		elif [[ "$1" = -C ]]
		then
			curcontext="${curcontext%:*}:${2}" 
			shift 2
		fi
		[[ "$1" = -(|-) ]] && shift
		zstyle -a ":completion:${curcontext}:" group-order order && compgroups "$order[@]"
		comptags "-i$prev" "$curcontext" "$@"
		if [[ -n "$_sort_tags" ]]
		then
			"$_sort_tags" "$@"
		else
			zstyle -a ":completion:${curcontext}:" tag-order order || (( ! ${@[(I)options]} )) || order=('(|*-)argument-* (|*-)option[-+]* values' options) 
			for tag in $order
			do
				case $tag in
					(-) nodef=yes  ;;
					(\!*) comptry "${(@)argv:#(${(j:|:)~${=~tag[2,-1]}})}" ;;
					(?*) comptry -m "$tag" ;;
				esac
			done
			[[ -z "$nodef" ]] && comptry "$@"
		fi
		comptags "-T$prev"
		return
	fi
	comptags "-N$prev"
}
_tar () {
	# undefined
	builtin autoload -XUz
}
_tar_archive () {
	# undefined
	builtin autoload -XUz
}
_tardy () {
	# undefined
	builtin autoload -XUz
}
_tcpdump () {
	# undefined
	builtin autoload -XUz
}
_tcpsys () {
	# undefined
	builtin autoload -XUz
}
_tcptraceroute () {
	# undefined
	builtin autoload -XUz
}
_telnet () {
	# undefined
	builtin autoload -XUz
}
_terminals () {
	# undefined
	builtin autoload -XUz
}
_tex () {
	# undefined
	builtin autoload -XUz
}
_texi () {
	# undefined
	builtin autoload -XUz
}
_texinfo () {
	# undefined
	builtin autoload -XUz
}
_tidy () {
	# undefined
	builtin autoload -XUz
}
_tiff () {
	# undefined
	builtin autoload -XUz
}
_tig () {
	_git-log
}
_tilde () {
	# undefined
	builtin autoload -XUz
}
_tilde_files () {
	# undefined
	builtin autoload -XUz
}
_time_zone () {
	# undefined
	builtin autoload -XUz
}
_tin () {
	# undefined
	builtin autoload -XUz
}
_tla () {
	# undefined
	builtin autoload -XUz
}
_tmux () {
	# undefined
	builtin autoload -XUz
}
_todo.sh () {
	# undefined
	builtin autoload -XUz
}
_toilet () {
	# undefined
	builtin autoload -XUz
}
_toolchain-source () {
	# undefined
	builtin autoload -XUz
}
_topgit () {
	# undefined
	builtin autoload -XUz
}
_totd () {
	# undefined
	builtin autoload -XUz
}
_tpb () {
	# undefined
	builtin autoload -XUz
}
_tpconfig () {
	# undefined
	builtin autoload -XUz
}
_tracepath () {
	# undefined
	builtin autoload -XUz
}
_trap () {
	# undefined
	builtin autoload -XUz
}
_tree () {
	# undefined
	builtin autoload -XUz
}
_ttyctl () {
	# undefined
	builtin autoload -XUz
}
_tune2fs () {
	# undefined
	builtin autoload -XUz
}
_twidge () {
	# undefined
	builtin autoload -XUz
}
_twisted () {
	# undefined
	builtin autoload -XUz
}
_typeset () {
	# undefined
	builtin autoload -XUz
}
_ulimit () {
	# undefined
	builtin autoload -XUz
}
_uml () {
	# undefined
	builtin autoload -XUz
}
_unace () {
	# undefined
	builtin autoload -XUz
}
_uname () {
	# undefined
	builtin autoload -XUz
}
_unexpand () {
	# undefined
	builtin autoload -XUz
}
_unhash () {
	# undefined
	builtin autoload -XUz
}
_uniq () {
	# undefined
	builtin autoload -XUz
}
_unison () {
	# undefined
	builtin autoload -XUz
}
_units () {
	# undefined
	builtin autoload -XUz
}
_unsetopt () {
	# undefined
	builtin autoload -XUz
}
_update-alternatives () {
	# undefined
	builtin autoload -XUz
}
_update-rc.d () {
	# undefined
	builtin autoload -XUz
}
_urls () {
	# undefined
	builtin autoload -XUz
}
_urpmi () {
	# undefined
	builtin autoload -XUz
}
_urxvt () {
	# undefined
	builtin autoload -XUz
}
_uscan () {
	# undefined
	builtin autoload -XUz
}
_user_admin () {
	# undefined
	builtin autoload -XUz
}
_user_at_host () {
	# undefined
	builtin autoload -XUz
}
_user_expand () {
	# undefined
	builtin autoload -XUz
}
_users () {
	# undefined
	builtin autoload -XUz
}
_users_on () {
	# undefined
	builtin autoload -XUz
}
_uzbl () {
	# undefined
	builtin autoload -XUz
}
_valgrind () {
	# undefined
	builtin autoload -XUz
}
_value () {
	# undefined
	builtin autoload -XUz
}
_values () {
	# undefined
	builtin autoload -XUz
}
_vared () {
	# undefined
	builtin autoload -XUz
}
_vars () {
	# undefined
	builtin autoload -XUz
}
_vcsh () {
	# undefined
	builtin autoload -XUz
}
_vim () {
	(( $+functions[_vim_files] )) || _vim_files () {
		case $PREFIX in
			(+*) _files -P './' $* && return 0 ;;
			((scp|http(|s)|(|s)ftp):*) _urls ;;
			(*) _files $* ;;
		esac
		case $PREFIX in
			(+) _message -e 'start at a given line (default: end of file)' ;;
			(+<1->) _message -e 'line number' ;;
		esac
	}
	local curcontext="$curcontext" state line expl
	typeset -A opt_args
	local arguments
	arguments=('(   -e -E -s -d -y)-v[vi mode]' '(-v    -E    -d -y)-e[ex mode]' '(-v -e       -d -y)-E[improved ex mode]' '(-v -e -E -s -d   )-y[easy mode]' '-m[modifications (writing files) not allowed]' '-M[modifications in text not allowed]' '-b[binary mode]' '-l[lisp mode]' '-C[start in compatible mode]' '-N[start in incompatible mode]' '(--nofork -f)'{--nofork,-f}'[do not detach the GUI version from the shell]' '-V-[verbosity level]::verbosity:((0\:"do not display any messages"
                                     1\:"display when viminfo file is read or written"
                                     2\:"display sourced files"
                                     5\:"display every searched tag-file"
                                     8\:"display files that trigger autocommands"
                                     9\:"display every triggered autocommand (default)"
                                    12\:"display every executed function"
                                    13\:"report every thrown, caught, finished, or discarded exception"
                                    14\:"display anything pending in a \:finally clause"
                                    15\:"display every executed ex-command"))' '-D[debugging mode]' '-n[no swap file (memory only)]' '-nb[start as NetBean server]' {-r,-L}'[list swap files and exit or recover from a swap file]::swap file:_vim_files -g "*.sw?(-.)"' '(   -H -F)-A[start in Arabic mode]' '(-A    -F)-H[start in Hebrew mode]' '(-A -H   )-F[start in Farsi mode]' '-T[set terminal type]:::_terminals' '-u[use given vimrc file instead of default .vimrc]::rc file:_files' '--noplugin[do not load plugin scripts]' '-o-[number of windows to open (default: one for each file)]::window count: ' '-O-[number of windows to vertically split open (default is one for each file)]::window count: ' '-p-[number of tabs to open (default: one for each file)]::tab count: ' '(* -t)-q-[quickfix file]:*:file:_vim_files' '*--cmd[execute given command before loading any RC files]:command: ' '-c[execute given command after loading the first file]:command: ' '-S[source a session file after loading the first file]:session file:_files' '-s[read normal-mode commands from script file]:script file:_files' '-w[append all typed commands to given file]:output file:_files' '-W[write all typed commands to given file, overwriting existing file]:output file:_files' '-x[edit encrypted files]' '-X[do not connect to X server]' '--remote[edit given files in a vim server if possible]:*:file:_vim_files' '--remote-silent[as --remote but without complaining if not possible]:*:file:_vim_files' '--remote-wait[as --remote but wait for files to have been edited]:*:file:_vim_files' '--remote-wait-silent[as --remote-wait but without complaining if not possible]:*:file:_vim_files' '--remote-send[send given keys to vim server if possible]:keys: ' '--remote-tab[as --remote but open tab page for each file]:*:file:_vim_files' '--remote-tab-silent[as --remote-silent but open tab page for each file]:*:file:_vim_files' '--remote-tab-wait[as --remote-wait but open tab page for each file]:*:file:_vim_files' '--remote-tab-wait-silent[as --remote-wait-silent but open tab page for each file]:*:file:_vim_files' '--remote-expr[evaluate given expression in a vim server and print result]:expression: ' '--literal[do not expand wildcards in arguments (this is useless with ZSH)]' '(- *)--serverlist[list available vim servers and exit]' '--servername[name of vim server to send to or name of server to become]:server name:->server' '--startuptime[write startup timing messages to given file]:log file:_files' '--socketid[run GVIM in another window]' '-i[use given viminfo file instead of default .viminfo]:viminfo file:_files' '(- *)'{-h,--help}'[print help and exit]' '(- *)--version[print version information and exit]' '(* -q)-t[edit file where tag is defined]:tag:_complete_tag' '(-t -q)*:file:_vim_files') 
	[[ $service != *g* ]] && arguments+='-g[start with GUI]' 
	[[ $service != r* ]] && arguments+='-Z[restricted mode]' 
	[[ $service != *diff ]] && arguments+='(-v -e -E -s -y)-d[diff mode]' 
	[[ $service != *view ]] && arguments+='-R[readonly mode]' 
	[[ $service = *g* ]] || (( ${words[(I)-g]} )) && arguments+=('-font:font:_xft_fonts' '-geometry:geometry:_x_geometry' '(-rv -reverse)'{-rv,-reverse}'[use reverse video]' '-display:display:_x_display' '--role[set unique role to identify main window]:role' '--socketid[open vim inside another GTK widget]:xid' '--echo-wid[echo window ID on stdout]' '-U[use given gvimrc file instead of default .gvimrc]::rc file:_files') 
	_arguments -C -S $arguments && return
	if [[ "$state" = server ]]
	then
		local -a servers
		servers=(${(f)"$(_call_program servers $words[1] --serverlist 2>/dev/null)"}) 
		_wanted servers expl server compadd -M 'm:{a-z}={A-Z}' -a servers && return
	fi
	return 1
}
_vim-addons () {
	# undefined
	builtin autoload -XUz
}
_vim_files () {
	case $PREFIX in
		(+*) _files -P './' $* && return 0 ;;
		((scp|http(|s)|(|s)ftp):*) _urls ;;
		(*) _files $* ;;
	esac
	case $PREFIX in
		(+) _message -e 'start at a given line (default: end of file)' ;;
		(+<1->) _message -e 'line number' ;;
	esac
}
_vnc () {
	# undefined
	builtin autoload -XUz
}
_volume_groups () {
	# undefined
	builtin autoload -XUz
}
_vorbis () {
	# undefined
	builtin autoload -XUz
}
_vorbiscomment () {
	# undefined
	builtin autoload -XUz
}
_vserver () {
	# undefined
	builtin autoload -XUz
}
_vux () {
	# undefined
	builtin autoload -XUz
}
_w3m () {
	# undefined
	builtin autoload -XUz
}
_wait () {
	# undefined
	builtin autoload -XUz
}
_wajig () {
	# undefined
	builtin autoload -XUz
}
_wakeup_capable_devices () {
	# undefined
	builtin autoload -XUz
}
_wanna-build () {
	# undefined
	builtin autoload -XUz
}
_wanted () {
	local -a __targs __gopt
	zparseopts -D -a __gopt 1 2 V J x C:=__targs
	_tags "$__targs[@]" "$1"
	while _tags
	do
		_all_labels "$__gopt[@]" "$@" && return 0
	done
	return 1
}
_webbrowser () {
	# undefined
	builtin autoload -XUz
}
_wget () {
	# undefined
	builtin autoload -XUz
}
_whereis () {
	# undefined
	builtin autoload -XUz
}
_which () {
	# undefined
	builtin autoload -XUz
}
_whois () {
	# undefined
	builtin autoload -XUz
}
_wiggle () {
	# undefined
	builtin autoload -XUz
}
_wpa_cli () {
	# undefined
	builtin autoload -XUz
}
_x_arguments () {
	# undefined
	builtin autoload -XUz
}
_x_borderwidth () {
	# undefined
	builtin autoload -XUz
}
_x_color () {
	# undefined
	builtin autoload -XUz
}
_x_colormapid () {
	# undefined
	builtin autoload -XUz
}
_x_cursor () {
	# undefined
	builtin autoload -XUz
}
_x_display () {
	# undefined
	builtin autoload -XUz
}
_x_extension () {
	# undefined
	builtin autoload -XUz
}
_x_font () {
	# undefined
	builtin autoload -XUz
}
_x_geometry () {
	# undefined
	builtin autoload -XUz
}
_x_keysym () {
	# undefined
	builtin autoload -XUz
}
_x_locale () {
	# undefined
	builtin autoload -XUz
}
_x_modifier () {
	# undefined
	builtin autoload -XUz
}
_x_name () {
	# undefined
	builtin autoload -XUz
}
_x_resource () {
	# undefined
	builtin autoload -XUz
}
_x_selection_timeout () {
	# undefined
	builtin autoload -XUz
}
_x_title () {
	# undefined
	builtin autoload -XUz
}
_x_utils () {
	# undefined
	builtin autoload -XUz
}
_x_visual () {
	# undefined
	builtin autoload -XUz
}
_x_window () {
	# undefined
	builtin autoload -XUz
}
_xargs () {
	# undefined
	builtin autoload -XUz
}
_xauth () {
	# undefined
	builtin autoload -XUz
}
_xclip () {
	# undefined
	builtin autoload -XUz
}
_xdvi () {
	# undefined
	builtin autoload -XUz
}
_xfig () {
	# undefined
	builtin autoload -XUz
}
_xft_fonts () {
	# undefined
	builtin autoload -XUz
}
_xloadimage () {
	# undefined
	builtin autoload -XUz
}
_xmlsoft () {
	# undefined
	builtin autoload -XUz
}
_xmms2 () {
	# undefined
	builtin autoload -XUz
}
_xmodmap () {
	# undefined
	builtin autoload -XUz
}
_xournal () {
	# undefined
	builtin autoload -XUz
}
_xpdf () {
	# undefined
	builtin autoload -XUz
}
_xrandr () {
	# undefined
	builtin autoload -XUz
}
_xscreensaver () {
	# undefined
	builtin autoload -XUz
}
_xset () {
	# undefined
	builtin autoload -XUz
}
_xt_arguments () {
	# undefined
	builtin autoload -XUz
}
_xt_session_id () {
	# undefined
	builtin autoload -XUz
}
_xterm () {
	# undefined
	builtin autoload -XUz
}
_xv () {
	# undefined
	builtin autoload -XUz
}
_xwit () {
	# undefined
	builtin autoload -XUz
}
_xz () {
	# undefined
	builtin autoload -XUz
}
_yast () {
	# undefined
	builtin autoload -XUz
}
_yast2 () {
	# undefined
	builtin autoload -XUz
}
_yodl () {
	# undefined
	builtin autoload -XUz
}
_yp () {
	# undefined
	builtin autoload -XUz
}
_yum () {
	# undefined
	builtin autoload -XUz
}
_zargs () {
	# undefined
	builtin autoload -XUz
}
_zattr () {
	# undefined
	builtin autoload -XUz
}
_zcalc_line () {
	# undefined
	builtin autoload -XUz
}
_zcat () {
	# undefined
	builtin autoload -XUz
}
_zcompile () {
	# undefined
	builtin autoload -XUz
}
_zdump () {
	# undefined
	builtin autoload -XUz
}
_zed () {
	# undefined
	builtin autoload -XUz
}
_zfs () {
	# undefined
	builtin autoload -XUz
}
_zfs_dataset () {
	# undefined
	builtin autoload -XUz
}
_zfs_keysource_props () {
	# undefined
	builtin autoload -XUz
}
_zfs_pool () {
	# undefined
	builtin autoload -XUz
}
_zftp () {
	# undefined
	builtin autoload -XUz
}
_zip () {
	# undefined
	builtin autoload -XUz
}
_zle () {
	# undefined
	builtin autoload -XUz
}
_zlogin () {
	# undefined
	builtin autoload -XUz
}
_zmodload () {
	# undefined
	builtin autoload -XUz
}
_zmv () {
	# undefined
	builtin autoload -XUz
}
_zoneadm () {
	# undefined
	builtin autoload -XUz
}
_zones () {
	# undefined
	builtin autoload -XUz
}
_zpool () {
	# undefined
	builtin autoload -XUz
}
_zpty () {
	# undefined
	builtin autoload -XUz
}
_zsh-mime-handler () {
	# undefined
	builtin autoload -XUz
}
_zstyle () {
	# undefined
	builtin autoload -XUz
}
_ztodo () {
	# undefined
	builtin autoload -XUz
}
_zypper () {
	# undefined
	builtin autoload -XUz
}
ackdelete () {
	ack -l $1 | xargs -n 1 sed -i '' -e "/$1/d"
}
ackreplace () {
	ack -l $1 | xargs -n 1 sed -i '' -e "s/$1/$2/g"
}
add-zsh-hook () {
	emulate -L zsh
	local -a hooktypes
	hooktypes=(chpwd precmd preexec periodic zshaddhistory zshexit zsh_directory_name) 
	local usage="Usage: $0 hook function\nValid hooks are:\n  $hooktypes"
	local opt
	local -a autoopts
	integer del list help
	while getopts "dDhLUzk" opt
	do
		case $opt in
			(d) del=1  ;;
			(D) del=2  ;;
			(h) help=1  ;;
			(L) list=1  ;;
			([Uzk]) autoopts+=(-$opt)  ;;
			(*) return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	if (( list ))
	then
		typeset -mp "(${1:-${(@j:|:)hooktypes}})_functions"
		return $?
	elif (( help || $# != 2 || ${hooktypes[(I)$1]} == 0 ))
	then
		print -u$(( 2 - help )) $usage
		return $(( 1 - help ))
	fi
	local hook="${1}_functions"
	local fn="$2"
	if (( del ))
	then
		if (( ${(P)+hook} ))
		then
			if (( del == 2 ))
			then
				set -A $hook ${(P)hook:#${~fn}}
			else
				set -A $hook ${(P)hook:#$fn}
			fi
			if (( ! ${(P)#hook} ))
			then
				unset $hook
			fi
		fi
	else
		if (( ${(P)+hook} ))
		then
			if (( ${${(P)hook}[(I)$fn]} == 0 ))
			then
				set -A $hook ${(P)hook} $fn
			fi
		else
			set -A $hook $fn
		fi
		autoload $autoopts -- $fn
	fi
}
addByPattern () {
	git st -s | grep $1 | awk '{print $2}' | xargs git add
}
cd () {
	if [[ "x$*" = "x..." ]]
	then
		cd ../..
	elif [[ "x$*" = "x...." ]]
	then
		cd ../../..
	elif [[ "x$*" = "x....." ]]
	then
		cd ../../../..
	elif [[ "x$*" = "x......" ]]
	then
		cd ../../../../..
	elif [ -d ~/.autoenv ]
	then
		source ~/.autoenv/activate.sh
		autoenv_cd "$@"
	else
		builtin cd "$@"
	fi
}
check () {
	git diff --stat $1 | grep -v -E "ruleset|state|2 \+\-"
}
checkdiff () {
	git diff --stat upstream/master | grep -v -E "ruleset|state|2 \+\-" | awk '{print $1}' | grep -v 528 | xargs git diff upstream/master --
}
colors () {
	emulate -L zsh
	typeset -Ag color colour
	color=(00 none 01 bold 02 faint 22 normal 03 standout 23 no-standout 04 underline 24 no-underline 05 blink 25 no-blink 07 reverse 27 no-reverse 08 conceal 28 no-conceal 30 black 40 bg-black 31 red 41 bg-red 32 green 42 bg-green 33 yellow 43 bg-yellow 34 blue 44 bg-blue 35 magenta 45 bg-magenta 36 cyan 46 bg-cyan 37 white 47 bg-white 39 default 49 bg-default) 
	local k
	for k in ${(k)color}
	do
		color[${color[$k]}]=$k 
	done
	for k in ${color[(I)3?]}
	do
		color[fg-${color[$k]}]=$k 
	done
	color[grey]=${color[black]} 
	color[fg-grey]=${color[grey]} 
	color[bg-grey]=${color[bg-black]} 
	colour=(${(kv)color}) 
	local lc=$'\e[' rc=m
	typeset -Hg reset_color bold_color
	reset_color="$lc${color[none]}$rc" 
	bold_color="$lc${color[bold]}$rc" 
	typeset -AHg fg fg_bold fg_no_bold
	for k in ${(k)color[(I)fg-*]}
	do
		fg[${k#fg-}]="$lc${color[$k]}$rc" 
		fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc" 
		fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
	typeset -AHg bg bg_bold bg_no_bold
	for k in ${(k)color[(I)bg-*]}
	do
		bg[${k#bg-}]="$lc${color[$k]}$rc" 
		bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc" 
		bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
}
compaudit () {
	# undefined
	builtin autoload -XUz
}
compdef () {
	local opt autol type func delete eval new i ret=0 cmd svc
	local -a match mbegin mend
	emulate -L zsh
	setopt extendedglob
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	while getopts "anpPkKde" opt
	do
		case "$opt" in
			(a) autol=yes  ;;
			(n) new=yes  ;;
			([pPkK]) if [[ -n "$type" ]]
				then
					print -u2 "$0: type already set to $type"
					return 1
				fi
				if [[ "$opt" = p ]]
				then
					type=pattern 
				elif [[ "$opt" = P ]]
				then
					type=postpattern 
				elif [[ "$opt" = K ]]
				then
					type=widgetkey 
				else
					type=key 
				fi ;;
			(d) delete=yes  ;;
			(e) eval=yes  ;;
		esac
	done
	shift OPTIND-1
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	if [[ -z "$delete" ]]
	then
		if [[ -z "$eval" ]] && [[ "$1" = *\=* ]]
		then
			while (( $# ))
			do
				if [[ "$1" = *\=* ]]
				then
					cmd="${1%%\=*}" 
					svc="${1#*\=}" 
					func="$_comps[${_services[(r)$svc]:-$svc}]" 
					[[ -n ${_services[$svc]} ]] && svc=${_services[$svc]} 
					[[ -z "$func" ]] && func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}" 
					if [[ -n "$func" ]]
					then
						_comps[$cmd]="$func" 
						_services[$cmd]="$svc" 
					else
						print -u2 "$0: unknown command or service: $svc"
						ret=1 
					fi
				else
					print -u2 "$0: invalid argument: $1"
					ret=1 
				fi
				shift
			done
			return ret
		fi
		func="$1" 
		[[ -n "$autol" ]] && autoload -Uz "$func"
		shift
		case "$type" in
			(widgetkey) while [[ -n $1 ]]
				do
					if [[ $# -lt 3 ]]
					then
						print -u2 "$0: compdef -K requires <widget> <comp-widget> <key>"
						return 1
					fi
					[[ $1 = _* ]] || 1="_$1" 
					[[ $2 = .* ]] || 2=".$2" 
					[[ $2 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$1" "$2" "$func"
					if [[ -n $new ]]
					then
						bindkey "$3" | IFS=$' \t' read -A opt
						[[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
					else
						bindkey "$3" "$1"
					fi
					shift 3
				done ;;
			(key) if [[ $# -lt 2 ]]
				then
					print -u2 "$0: missing keys"
					return 1
				fi
				if [[ $1 = .* ]]
				then
					[[ $1 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" "$1" "$func"
				else
					[[ $1 = menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" ".$1" "$func"
				fi
				shift
				for i
				do
					if [[ -n $new ]]
					then
						bindkey "$i" | IFS=$' \t' read -A opt
						[[ $opt[-1] = undefined-key ]] || continue
					fi
					bindkey "$i" "$func"
				done ;;
			(*) while (( $# ))
				do
					if [[ "$1" = -N ]]
					then
						type=normal 
					elif [[ "$1" = -p ]]
					then
						type=pattern 
					elif [[ "$1" = -P ]]
					then
						type=postpattern 
					else
						case "$type" in
							(pattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_patcomps[$match[1]]="=$match[2]=$func" 
								else
									_patcomps[$1]="$func" 
								fi ;;
							(postpattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_postpatcomps[$match[1]]="=$match[2]=$func" 
								else
									_postpatcomps[$1]="$func" 
								fi ;;
							(*) if [[ "$1" = *\=* ]]
								then
									cmd="${1%%\=*}" 
									svc=yes 
								else
									cmd="$1" 
									svc= 
								fi
								if [[ -z "$new" || -z "${_comps[$1]}" ]]
								then
									_comps[$cmd]="$func" 
									[[ -n "$svc" ]] && _services[$cmd]="${1#*\=}" 
								fi ;;
						esac
					fi
					shift
				done ;;
		esac
	else
		case "$type" in
			(pattern) unset "_patcomps[$^@]" ;;
			(postpattern) unset "_postpatcomps[$^@]" ;;
			(key) print -u2 "$0: cannot restore key bindings"
				return 1 ;;
			(*) unset "_comps[$^@]" ;;
		esac
	fi
}
compdump () {
	# undefined
	builtin autoload -XUz
}
compinit () {
	# undefined
	builtin autoload -XUz
}
compinstall () {
	# undefined
	builtin autoload -XUz
}
cs () {
	cd $1
	ls -G
}
current_branch () {
	ref=$(git symbolic-ref HEAD 2> /dev/null)  || ref=$(git rev-parse --short HEAD 2> /dev/null)  || return
	echo ${ref#refs/heads/}
}
current_repository () {
	ref=$(git symbolic-ref HEAD 2> /dev/null)  || ref=$(git rev-parse --short HEAD 2> /dev/null)  || return
	echo $(git remote -v | cut -d':' -f 2)
}
dash () {
	~/work/software/javadocset $1 $2
}
db () {
	while [ "$1" != "" ]
	do
		git branch -D $1
		deleteRemoteBranch $1
		echo "deleted branch : ${1}" && shift
	done
}
deleteRemoteBranch () {
	git branch -rd origin/$1
	git push origin :$1
}
drop () {
	git add $1
	git reset $1
	git checkout $1
	echo done
}
edit-command-line () {
	# undefined
	builtin autoload -XU
}
editAt () {
	ls -G -al | grep $1 | awk '{print $9}' | xargs -o vim
}
edit_conflict () {
	git ls-files -u | awk '{print $4}' | sort -u | grep $1 | xargs -o vim
}
gadd () {
	git ls-files -u | awk '{print $4}' | sort -u | grep $1 | xargs -n 1 git add
}
gddp () {
	REV=$1 
	git show -p $REV --no-prefix | patch -p0
}
gdv () {
	git diff -w "$@" | view -
}
getent () {
	if [[ $2 = <-> ]]
	then
		grep ":$2:[^:]*$" /etc/$1
	else
		grep "^$2:" /etc/$1
	fi
}
git_prompt_ahead () {
	if $(echo "$(command git log origin/$(current_branch)..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null)
	then
		echo "$ZSH_THEME_GIT_PROMPT_AHEAD"
	fi
}
git_prompt_info () {
	ref=$(command git symbolic-ref HEAD 2> /dev/null)  || ref=$(command git rev-parse --short HEAD 2> /dev/null)  || return
	echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
}
git_prompt_long_sha () {
	SHA=$(command git rev-parse HEAD 2> /dev/null)  && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER"
}
git_prompt_short_sha () {
	SHA=$(command git rev-parse --short HEAD 2> /dev/null)  && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER"
}
git_prompt_status () {
	INDEX=$(command git status --porcelain -b 2> /dev/null) 
	STATUS="" 
	if $(echo "$INDEX" | grep -E '^\?\? ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_UNTRACKED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^A  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS" 
	elif $(echo "$INDEX" | grep '^M  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^ M ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	elif $(echo "$INDEX" | grep '^AM ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	elif $(echo "$INDEX" | grep '^ T ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^R  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_RENAMED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^ D ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	elif $(echo "$INDEX" | grep '^D  ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	elif $(echo "$INDEX" | grep '^AD ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS" 
	fi
	if $(command git rev-parse --verify refs/stash >/dev/null 2>&1)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_STASHED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^UU ' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_UNMERGED$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^## .*ahead' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_AHEAD$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^## .*behind' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_BEHIND$STATUS" 
	fi
	if $(echo "$INDEX" | grep '^## .*diverged' &> /dev/null)
	then
		STATUS="$ZSH_THEME_GIT_PROMPT_DIVERGED$STATUS" 
	fi
	echo $STATUS
}
git_remote_status () {
	remote=${$(command git rev-parse --verify ${hook_com[branch]}@{upstream} --symbolic-full-name 2>/dev/null)/refs\/remotes\/} 
	if [[ -n ${remote} ]]
	then
		ahead=$(command git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l) 
		behind=$(command git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l) 
		if [ $ahead -eq 0 ] && [ $behind -gt 0 ]
		then
			echo "$ZSH_THEME_GIT_PROMPT_BEHIND_REMOTE"
		elif [ $ahead -gt 0 ] && [ $behind -eq 0 ]
		then
			echo "$ZSH_THEME_GIT_PROMPT_AHEAD_REMOTE"
		elif [ $ahead -gt 0 ] && [ $behind -gt 0 ]
		then
			echo "$ZSH_THEME_GIT_PROMPT_DIVERGED_REMOTE"
		fi
	fi
}
gpc () {
	find . -name '*.orig' | xargs rm
	find . -name '*.rej' | xargs rm
}
gsd () {
	TRACKING_BRANCH=`git svn info | grep URL | sed -e 's/.*\/branches\///'` 
	if [[ "$TRACKING_BRANCH" =~ URL.* ]]
	then
		TRACKING_BRANCH=`git config --get svn-remote.svn.fetch | sed -e 's/.*:refs\/remotes\///'` 
	fi
	REV=`git svn find-rev $(git rev-list --date-order --max-count=1 $TRACKING_BRANCH)` 
	git diff --no-prefix $(git rev-list --date-order --max-count=1 $TRACKING_BRANCH) $* | sed -n "
    :a
    s/^diff --git [^[:space:]]*/Index:/p
    s/^index.*/===================================================================/p
    /^--- \(.*\)/ {
        # Read a line into the pattern space
        N
        # add file 
        s|^--- /dev/null\n+++ \(.*\)|--- \1    (revision 0)\\"$'\n'"+++ \1    (revision 0)|p
        te
        # delete or update file
        s|^--- \(.*\)\n+++ \(.*\)|--- \1    (revision $REV)\\"$'\n'"+++ \1    (work copy)|p
    }
    :e
    /^@@/{
    :c
    	p;n
    	/^diff --git [^[:space:]]*/ba
    	bc
    }
    "
}
is_plugin () {
	local base_dir=$1
	local name=$2
	test -f $base_dir/plugins/$name/$name.plugin.zsh || test -f $base_dir/plugins/$name/_$name
}
lconflict () {
	git ls-files -u | awk '{print $4}' | sort -u | grep $1
}
master_win () {
	files=$(git ls-files -u | awk '{print $4}' | sort -u | grep $1) 
	while read file
	do
		echo "revert changes of $file"
		git reset -q -- $file > /dev/null && git checkout -- $file && git checkout upstream/master -- $file
	done <<< "$files"
}
merge_steps () {
	MERGE_POINT = $1
	git fetch upstream
	git checkout -B release --track upstream/release
	git merge --no-ff $MERGE_POINT
	git reset -- assembly/**/image/rule.{ruleset,state}
	git checkout -- assembly/**/image/rule.{ruleset,state}
	git status --short | grep -e "^UA" | cut -d ' ' -f 2 | xargs -n 1 git add
	git status --short | grep -e "^AU" | cut -d ' ' -f 2 | xargs -n 1 git add
	find . -type f \( -name '*yi?f' -o -name '*bim' -o -name 'Make*' \) -print0 | xargs -0 -P128 grep -EH --color master
	git diff --stat $MERGE_POINT | grep -v -E "ruleset|state|2 \+\-"
	git commit
	tag_release
	tag_master
	git push upstream master-X release-Y release
}
mkdircd () {
	mkdir -p "$@" && eval cd "\"\$$#\""
}
mp () {
	mvn -s ~/work/shell/ymaven_settings.xml archetype:create -DgroupId=$1 -DartifactId=$2
}
msp () {
	mvn -s ~/work/shell/ymaven_settings.xml archetype:generate -DgroupId=$1 -DartifactId=$2 -DremoteRepositories=http://scala-tools.org/repo-releases -DarchetypeGroupId=org.scala-tools.archetypes -DarchetypeArtifactId=scala-archetype-simple -Dversion=1.0-SNAPSHOT
}
newsbt () {
	java -Xmx512M -jar /Users/lvfm/work/software/sbt-launch-0.7.7.jar "$@"
}
omz_termsupport_precmd () {
	title $ZSH_THEME_TERM_TAB_TITLE_IDLE $ZSH_THEME_TERM_TITLE_IDLE
}
omz_termsupport_preexec () {
	emulate -L zsh
	setopt extended_glob
	local CMD=${1[(wr)^(*=*|sudo|ssh|rake|-*)]}
	local LINE="${2:gs/$/\\$}"
	LINE="${LINE:gs/%/%%}" 
	title "$CMD" "%100>...>$LINE%<<"
}
parse_git_dirty () {
	local SUBMODULE_SYNTAX=''
	local GIT_STATUS=''
	local CLEAN_MESSAGE='nothing to commit (working directory clean)'
	if [[ "$(command git config --get oh-my-zsh.hide-status)" != "1" ]]
	then
		if [[ $POST_1_7_2_GIT -gt 0 ]]
		then
			SUBMODULE_SYNTAX="--ignore-submodules=dirty" 
		fi
		if [[ "$DISABLE_UNTRACKED_FILES_DIRTY" = "true" ]]
		then
			GIT_STATUS=$(command git status -s ${SUBMODULE_SYNTAX} -uno 2> /dev/null | tail -n1) 
		else
			GIT_STATUS=$(command git status -s ${SUBMODULE_SYNTAX} 2> /dev/null | tail -n1) 
		fi
		if [[ -n $GIT_STATUS ]]
		then
			echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
		else
			echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
		fi
	else
		echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
	fi
}
rbenv_prompt_info () {
	
}
re () {
	files=(./*) 
	/usr/local/bin/vim "${files[RANDOM % ${#files[@]}]}"
}
release_win () {
	files=$(git ls-files -u | awk '{print $4}' | sort -u | grep $1) 
	while read file
	do
		echo "revert changes of $file"
		git reset -q -- $file > /dev/null
		git checkout -- $file
	done <<< "$files"
}
rvm_prompt_info () {
	[ -f $HOME/.rvm/bin/rvm-prompt ] || return
	local rvm_prompt
	rvm_prompt=$($HOME/.rvm/bin/rvm-prompt ${ZSH_THEME_RVM_PROMPT_OPTIONS} 2>/dev/null) 
	[[ "${rvm_prompt}x" = "x" ]] && return
	echo "${ZSH_THEME_RVM_PROMPT_PREFIX:=(}${rvm_prompt}${ZSH_THEME_RVM_PROMPT_SUFFIX:=)}"
}
s_test () {
	$SCALA_PATH/scalac -cp ~/.m2/repository/org/scalatest/scalatest_2.10.0/1.8/scalatest_2.10.0-1.8.jar $1
	$SCALA_PATH/scala -Dscala.repl.maxprintstring=10000 -cp ~/.m2/repository/org/scalatest/scalatest_2.10.0/1.8/scalatest_2.10.0-1.8.jar org.scalatest.run `echo $1 | cut -d '.' -f1`
	rm *.class
}
spectrum_ls () {
	for code in {000..255}
	do
		print -P -- "$code: %F{$code}Test%f"
	done
}
tag_master () {
	git tag -a -m "Open new master branch $1" master-$1 upstream/master
}
tag_release () {
	git tag -a -m "Tag for release-$1 release" release-$1 release
}
take () {
	mkdir -p $1
	cd $1
}
tarz () {
	tar -zcvf $1 $2
}
title () {
	if [[ "$DISABLE_AUTO_TITLE" = "true" ]] || [[ "$EMACS" = *term* ]]
	then
		return
	fi
	if [[ "$TERM" = screen* ]]
	then
		print -Pn "\ek$1:q\e\\"
	elif [[ "$TERM" = xterm* ]] || [[ $TERM = rxvt* ]] || [[ $TERM = ansi ]] || [[ "$TERM_PROGRAM" = "iTerm.app" ]]
	then
		print -Pn "\e]2;$2:q\a"
		print -Pn "\e]1;$1:q\a"
	fi
}
uninstall_oh_my_zsh () {
	/usr/bin/env ZSH=$ZSH /bin/sh $ZSH/tools/uninstall.sh
}
upgrade_oh_my_zsh () {
	/usr/bin/env ZSH=$ZSH /bin/sh $ZSH/tools/upgrade.sh
}
url-quote-magic () {
	setopt localoptions noksharrays extendedglob
	local qkey="${(q)KEYS}"
	local -a reply
	if [[ "$KEYS" != "$qkey" ]]
	then
		local lbuf="$LBUFFER$qkey"
		if [[ "${(Q)LBUFFER}$KEYS" = "${(Q)lbuf}" ]]
		then
			local -a words
			words=("${(@Q)${(z)lbuf}}") 
			local urlseps urlmetas urlglobbers localschema otherschema
			if [[ "$words[-1]" = (#b)([^:]##):* ]]
			then
				zstyle -s ":url-quote-magic:$match[1]" url-seps urlseps ''
				zstyle -s ":url-quote-magic:$match[1]" url-metas urlmetas ''
			fi
			zstyle -s :url-quote-magic url-globbers urlglobbers '|'
			zstyle -s :urlglobber url-other-schema otherschema '|'
			if [[ "$words[1]" = ${~urlglobbers} ]]
			then
				zstyle -s :urlglobber url-local-schema localschema '|'
			else
				localschema=' ' 
			fi
			case "$words[-1]" in
				(*[\'\"]*)  ;;
				((${~localschema}):/(|/localhost)/*) [[ "$urlseps" = *"$KEYS"* ]] && LBUFFER="$LBUFFER\\"  ;;
				((${~otherschema}):*) [[ "$urlseps$urlmetas" = *"$KEYS"* ]] && LBUFFER="$LBUFFER\\"  ;;
			esac
		fi
	fi
	zle .self-insert
}
urlglobber () {
	local -a args globbed localschema otherschema reply
	local arg command="$1"
	shift
	zstyle -s :urlglobber url-local-schema localschema '|'
	zstyle -s :urlglobber url-other-schema otherschema '|'
	for arg
	do
		case "${arg}" in
			((${~localschema}):/(|/localhost)/*) globbed=(${~${arg##ftp://(localhost|)}}) 
				args[$#args+1]=("${(M)arg##(${~localchema})://(localhost|)}${(@)^globbed}")  ;;
			((${~otherschema}):*) args[${#args}+1]="$arg"  ;;
			(*) args[${#args}+1]=(${~arg})  ;;
		esac
	done
	"$command" "${(@)args}"
}
work_in_progress () {
	if $(git log -n 1 | grep -q -c wip)
	then
		echo "WIP!!"
	fi
}
zsh_stats () {
	fc -l 1 | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n20
}
